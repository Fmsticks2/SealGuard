import{ethers as e}from"ethers";var t={d:(e,r)=>{for(var n in r)t.o(r,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},r={};t.r(r),t.d(r,{code:()=>De,digest:()=>Ee,name:()=>Ae,size:()=>Ce});var n={};t.r(n),t.d(n,{computeNode:()=>qt,create:()=>Kt,depth:()=>zt,from:()=>Qt,offset:()=>Lt,path:()=>Ft,resolveRoot:()=>Ht,truncate:()=>Gt,truncatedHash:()=>Wt,validateLevelIndex:()=>Yt,verify:()=>Vt});var o={};t.r(o),t.d(o,{tD:()=>yr,y1:()=>Sr});var i={};t.r(i),t.d(i,{FIL_COMMITMENT_UNSEALED:()=>Ar,SHA2_256_TRUNC254_PADDED:()=>Cr,asCommP:()=>Er,calculate:()=>Rr,createCommPStream:()=>Nr,downloadAndValidateCommP:()=>Tr,downloadAndValidateCommPFromUrl:()=>Ur,toPieceSize:()=>_r,toZeroPaddedSize:()=>Ir});var a={};t.r(a),t.d(a,{PDPAuthHelper:()=>cn,PDPServer:()=>an,PDPVerifier:()=>un,asProofSetData:()=>on,asProofSetRootData:()=>nn,isFindPieceResponse:()=>Xr,isProofSetCreationStatusResponse:()=>Jr,isRootAdditionStatusResponse:()=>Zr,validateFindPieceResponse:()=>rn,validateProofSetCreationStatusResponse:()=>en,validateRootAdditionStatusResponse:()=>tn});var s={};t.r(s),t.d(s,{CHAIN_IDS:()=>xr,CONTRACT_ABIS:()=>Br,CONTRACT_ADDRESSES:()=>Vr,GENESIS_TIMESTAMPS:()=>Or,MULTIHASH_CODES:()=>jr,PDPAuthHelper:()=>cn,PDPServer:()=>an,PDPVerifier:()=>un,PandoraService:()=>pn,PaymentsService:()=>ln,RPC_URLS:()=>zr,SIZE_CONSTANTS:()=>Fr,StorageService:()=>dn,SubgraphService:()=>Sn,Synapse:()=>Cn,TIME_CONSTANTS:()=>Mr,TIMING_CONSTANTS:()=>Lr,TOKENS:()=>kr,asProofSetData:()=>on,asProofSetRootData:()=>nn,calculateLastProofDate:()=>Kr,constructFindPieceUrl:()=>Yr,constructPieceUrl:()=>Qr,createError:()=>$r,dateToEpoch:()=>Wr,epochToDate:()=>Hr,getGenesisTimestamp:()=>qr,isFindPieceResponse:()=>Xr,isProofSetCreationStatusResponse:()=>Jr,isRootAdditionStatusResponse:()=>Zr,timeUntilEpoch:()=>Gr,validateFindPieceResponse:()=>rn,validateProofSetCreationStatusResponse:()=>en,validateRootAdditionStatusResponse:()=>tn});const c=new Uint8Array(0);function d(e){return e.reduce((e,t)=>e+t.toString(16).padStart(2,"0"),"")}function l(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0}function u(e){if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")}const p=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<e.length;o++){var i=e.charAt(o),a=i.charCodeAt(0);if(255!==r[a])throw new TypeError(i+" is ambiguous");r[a]=o}var s=e.length,c=e.charAt(0),d=Math.log(s)/Math.log(256),l=Math.log(256)/Math.log(s);function u(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var n=0,o=0;e[t]===c;)n++,t++;for(var i=(e.length-t)*d+1>>>0,a=new Uint8Array(i);e[t];){var l=r[e.charCodeAt(t)];if(255===l)return;for(var u=0,p=i-1;(0!==l||u<o)&&-1!==p;p--,u++)l+=s*a[p]>>>0,a[p]=l%256>>>0,l=l/256>>>0;if(0!==l)throw new Error("Non-zero carry");o=u,t++}if(" "!==e[t]){for(var h=i-o;h!==i&&0===a[h];)h++;for(var f=new Uint8Array(n+(i-h)),g=n;h!==i;)f[g++]=a[h++];return f}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,o=0,i=t.length;o!==i&&0===t[o];)o++,r++;for(var a=(i-o)*l+1>>>0,d=new Uint8Array(a);o!==i;){for(var u=t[o],p=0,h=a-1;(0!==u||p<n)&&-1!==h;h--,p++)u+=256*d[h]>>>0,d[h]=u%s>>>0,u=u/s>>>0;if(0!==u)throw new Error("Non-zero carry");n=p,o++}for(var f=a-n;f!==a&&0===d[f];)f++;for(var g=c.repeat(r);f<a;++f)g+=e.charAt(d[f]);return g},decodeUnsafe:u,decode:function(e){var r=u(e);if(r)return r;throw new Error(`Non-${t} character`)}}};class h{name;prefix;baseEncode;constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class f{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,r){this.name=e,this.prefix=t;const n=t.codePointAt(0);if(void 0===n)throw new Error("Invalid prefix character");this.prefixCodePoint=n,this.baseDecode=r}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return w(this,e)}}class g{decoders;constructor(e){this.decoders=e}or(e){return w(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(null!=r)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function w(e,t){return new g({...e.decoders??{[e.prefix]:e},...t.decoders??{[t.prefix]:t}})}class v{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,r,n){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=n,this.encoder=new h(e,t,r),this.decoder=new f(e,t,n)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function y({name:e,prefix:t,encode:r,decode:n}){return new v(e,t,r,n)}function S({name:e,prefix:t,alphabet:r}){const{encode:n,decode:o}=p(r,e);return y({prefix:t,name:e,encode:n,decode:e=>u(o(e))})}function m({name:e,prefix:t,bitsPerChar:r,alphabet:n}){const o=function(e){const t={};for(let r=0;r<e.length;++r)t[e[r]]=r;return t}(n);return y({prefix:t,name:e,encode:e=>function(e,t,r){const n="="===t[t.length-1],o=(1<<r)-1;let i="",a=0,s=0;for(let n=0;n<e.length;++n)for(s=s<<8|e[n],a+=8;a>r;)a-=r,i+=t[o&s>>a];if(0!==a&&(i+=t[o&s<<r-a]),n)for(;i.length*r&7;)i+="=";return i}(e,n,r),decode:t=>function(e,t,r,n){let o=e.length;for(;"="===e[o-1];)--o;const i=new Uint8Array(o*r/8|0);let a=0,s=0,c=0;for(let d=0;d<o;++d){const o=t[e[d]];if(void 0===o)throw new SyntaxError(`Non-${n} character`);s=s<<r|o,a+=r,a>=8&&(a-=8,i[c++]=255&s>>a)}if(a>=r||255&s<<8-a)throw new SyntaxError("Unexpected end of data");return i}(t,o,r,e)})}const P=m({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),b=(m({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),m({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),m({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),m({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),m({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),m({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),m({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),m({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),S({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"})),A=(S({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),S({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}));S({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var C=128,I=-128,_=Math.pow(2,31),E=128,D=127,R=Math.pow(2,7),N=Math.pow(2,14),T=Math.pow(2,21),U=Math.pow(2,28),$=Math.pow(2,35),k=Math.pow(2,42),x=Math.pow(2,49),B=Math.pow(2,56),M=Math.pow(2,63);const O={encode:function e(t,r,n){r=r||[];for(var o=n=n||0;t>=_;)r[n++]=255&t|C,t/=128;for(;t&I;)r[n++]=255&t|C,t>>>=7;return r[n]=0|t,e.bytes=n-o+1,r},decode:function e(t,r){var n,o=0,i=(r=r||0,0),a=r,s=t.length;do{if(a>=s)throw e.bytes=0,new RangeError("Could not decode varint");n=t[a++],o+=i<28?(n&D)<<i:(n&D)*Math.pow(2,i),i+=7}while(n>=E);return e.bytes=a-r,o},encodingLength:function(e){return e<R?1:e<N?2:e<T?3:e<U?4:e<$?5:e<k?6:e<x?7:e<B?8:e<M?9:10}};function F(e,t=0){return[O.decode(e,t),O.decode.bytes]}function L(e,t,r=0){return O.encode(e,t,r),t}function z(e){return O.encodingLength(e)}function V(e,t){const r=t.byteLength,n=z(e),o=n+z(r),i=new Uint8Array(o+r);return L(e,i,0),L(r,i,n),i.set(t,o),new j(e,r,t,i)}class j{code;size;digest;bytes;constructor(e,t,r,n){this.code=e,this.size=t,this.digest=r,this.bytes=n}}function H(e,t){const{bytes:r,version:n}=e;return 0===n?function(e,t,r){const{prefix:n}=r;if(n!==A.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const o=t.get(n);if(null==o){const o=r.encode(e).slice(1);return t.set(n,o),o}return o}(r,q(e),t??A.encoder):function(e,t,r){const{prefix:n}=r,o=t.get(n);if(null==o){const o=r.encode(e);return t.set(n,o),o}return o}(r,q(e),t??P.encoder)}const W=new WeakMap;function q(e){const t=W.get(e);if(null==t){const t=new Map;return W.set(e,t),t}return t}class G{code;version;multihash;bytes;"/";constructor(e,t,r,n){this.code=t,this.version=e,this.multihash=r,this.bytes=n,this["/"]=n}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==K)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Q)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return G.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=V(e,t);return G.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return G.equals(this,e)}static equals(e,t){const r=t;return null!=r&&e.code===r.code&&e.version===r.version&&function(e,t){if(e===t)return!0;{const r=t;return e.code===r.code&&e.size===r.size&&r.bytes instanceof Uint8Array&&l(e.bytes,r.bytes)}}(e.multihash,r.multihash)}toString(e){return H(this,e)}toJSON(){return{"/":H(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(null==e)return null;const t=e;if(t instanceof G)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:r,multihash:n,bytes:o}=t;return new G(e,r,n,o??Y(e,r,n.bytes))}if(!0===t[J]){const{version:e,multihash:r,code:n}=t,o=function(e){const t=u(e),[r,n]=F(t),[o,i]=F(t.subarray(n)),a=t.subarray(n+i);if(a.byteLength!==o)throw new Error("Incorrect length");return new j(r,o,a,t)}(r);return G.create(e,n,o)}return null}static create(e,t,r){if("number"!=typeof t)throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==K)throw new Error(`Version 0 CID must use dag-pb (code: ${K}) block encoding`);return new G(e,t,r,r.bytes);case 1:{const n=Y(e,t,r.bytes);return new G(e,t,r,n)}default:throw new Error("Invalid version")}}static createV0(e){return G.create(0,K,e)}static createV1(e,t){return G.create(1,e,t)}static decode(e){const[t,r]=G.decodeFirst(e);if(0!==r.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=G.inspectBytes(e),r=t.size-t.multihashSize,n=u(e.subarray(r,r+t.multihashSize));if(n.byteLength!==t.multihashSize)throw new Error("Incorrect length");const o=n.subarray(t.multihashSize-t.digestSize),i=new j(t.multihashCode,t.digestSize,o,n);return[0===t.version?G.createV0(i):G.createV1(t.codec,i),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[r,n]=F(e.subarray(t));return t+=n,r};let n=r(),o=K;if(18===n?(n=0,t=0):o=r(),0!==n&&1!==n)throw new RangeError(`Invalid CID version ${n}`);const i=t,a=r(),s=r(),c=t+s;return{version:n,codec:o,multihashCode:a,digestSize:s,multihashSize:c-i,size:c}}static parse(e,t){const[r,n]=function(e,t){switch(e[0]){case"Q":{const r=t??A;return[A.prefix,r.decode(`${A.prefix}${e}`)]}case A.prefix:{const r=t??A;return[A.prefix,r.decode(e)]}case P.prefix:{const r=t??P;return[P.prefix,r.decode(e)]}case b.prefix:{const r=t??b;return[b.prefix,r.decode(e)]}default:if(null==t)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}}(e,t),o=G.decode(n);if(0===o.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return q(o).set(r,e),o}}const K=112,Q=18;function Y(e,t,r){const n=z(e),o=n+z(t),i=new Uint8Array(o+r.byteLength);return L(e,i,0),L(t,i,n),i.set(r,o),i}const J=Symbol.for("@ipld/js-cid/CID"),Z=(BigInt(4),254),X=127,ee=BigInt(X),te=BigInt(128),re=.9921875,ne=32,oe=BigInt(ne),ie=2*ne+1,ae=()=>se,se=(e=>{if(e instanceof Uint8Array){if(e.length>ne)return e.subarray(0,ne);if(e.length==ne)return e}const t=new Uint8Array(ne);return t.set([...e]),t})(new Uint8Array(ne).fill(0));function ce(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function de(e,t){!function(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}Object.freeze(se.buffer);const le=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),ue=(e,t)=>e<<32-t|e>>>t;if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error("Non little-endian hardware is not supported");function pe(e){if("string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),!(e instanceof Uint8Array))throw new Error("expected Uint8Array, got "+typeof e);return e}class he{clone(){return this._cloneInto()}}function fe(e){const t=t=>e().update(pe(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}class ge extends he{constructor(e,t,r,n){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=le(this.buffer)}update(e){ce(this);const{view:t,buffer:r,blockLen:n}=this,o=(e=pe(e)).length;for(let i=0;i<o;){const a=Math.min(n-this.pos,o-i);if(a===n){const t=le(e);for(;n<=o-i;i+=n)this.process(t,i);continue}r.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===n&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){ce(this),de(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>n-i&&(this.process(r,0),i=0);for(let e=i;e<n;e++)t[e]=0;!function(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const o=BigInt(32),i=BigInt(4294967295),a=Number(r>>o&i),s=Number(r&i),c=n?4:0,d=n?0:4;e.setUint32(t+c,a,n),e.setUint32(t+d,s,n)}(r,n-8,BigInt(8*this.length),o),this.process(r,0);const a=le(e),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=s/4,d=this.get();if(c>d.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)a.setUint32(4*e,d[e],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:o,destroyed:i,pos:a}=this;return e.length=n,e.pos=a,e.finished=o,e.destroyed=i,n%t&&e.buffer.set(r),e}}const we=(e,t,r)=>e&t^~e&r,ve=(e,t,r)=>e&t^e&r^t&r,ye=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Se=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),me=new Uint32Array(64);class Pe extends ge{constructor(){super(64,32,8,!1),this.A=0|Se[0],this.B=0|Se[1],this.C=0|Se[2],this.D=0|Se[3],this.E=0|Se[4],this.F=0|Se[5],this.G=0|Se[6],this.H=0|Se[7]}get(){const{A:e,B:t,C:r,D:n,E:o,F:i,G:a,H:s}=this;return[e,t,r,n,o,i,a,s]}set(e,t,r,n,o,i,a,s){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|o,this.F=0|i,this.G=0|a,this.H=0|s}process(e,t){for(let r=0;r<16;r++,t+=4)me[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=me[e-15],r=me[e-2],n=ue(t,7)^ue(t,18)^t>>>3,o=ue(r,17)^ue(r,19)^r>>>10;me[e]=o+me[e-7]+n+me[e-16]|0}let{A:r,B:n,C:o,D:i,E:a,F:s,G:c,H:d}=this;for(let e=0;e<64;e++){const t=d+(ue(a,6)^ue(a,11)^ue(a,25))+we(a,s,c)+ye[e]+me[e]|0,l=(ue(r,2)^ue(r,13)^ue(r,22))+ve(r,n,o)|0;d=c,c=s,s=a,a=i+t|0,i=o,o=n,n=r,r=t+l|0}r=r+this.A|0,n=n+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,s=s+this.F|0,c=c+this.G|0,d=d+this.H|0,this.set(r,n,o,i,a,s,c,d)}roundClean(){me.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const be=fe(()=>new Pe),Ae="sha2-256",Ce=32,Ie=new Uint8Array([18,32]);class _e{constructor(e){this.code=18,this.name=Ae,this.bytes=e,this.size=Ce,this.digest=e.subarray(2)}}const Ee=e=>{const t=new Uint8Array(Ie.length+Ce);return t.set(Ie,0),t.set(be(e),Ie.length),new _e(t)},De=18,Re=["string","number","bigint","symbol"],Ne=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];class Te{constructor(e,t,r){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=r}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}Te.uint=new Te(0,"uint",!0),Te.negint=new Te(1,"negint",!0),Te.bytes=new Te(2,"bytes",!0),Te.string=new Te(3,"string",!0),Te.array=new Te(4,"array",!1),Te.map=new Te(5,"map",!1),Te.tag=new Te(6,"tag",!1),Te.float=new Te(7,"float",!0),Te.false=new Te(7,"false",!0),Te.true=new Te(7,"true",!0),Te.null=new Te(7,"null",!0),Te.undefined=new Te(7,"undefined",!0),Te.break=new Te(7,"break",!0);class Ue{constructor(e,t,r){this.type=e,this.value=t,this.encodedLength=r,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const $e=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"==typeof globalThis.Buffer.isBuffer,ke=new TextDecoder,xe=new TextEncoder;function Be(e){return $e&&globalThis.Buffer.isBuffer(e)}const Me=$e?(e,t,r)=>r-t>64?globalThis.Buffer.from(e.subarray(t,r)).toString("utf8"):je(e,t,r):(e,t,r)=>r-t>64?ke.decode(e.subarray(t,r)):je(e,t,r),Oe=$e?e=>e.length>64?globalThis.Buffer.from(e):Ve(e):e=>e.length>64?xe.encode(e):Ve(e),Fe=$e?(e,t,r)=>Be(e)?new Uint8Array(e.subarray(t,r)):e.slice(t,r):(e,t,r)=>e.slice(t,r),Le=$e?(e,t)=>{return e=e.map(e=>e instanceof Uint8Array?e:globalThis.Buffer.from(e)),(r=globalThis.Buffer.concat(e,t))instanceof Uint8Array?Be(r)?new Uint8Array(r.buffer,r.byteOffset,r.byteLength):r:Uint8Array.from(r);var r}:(e,t)=>{const r=new Uint8Array(t);let n=0;for(let t of e)n+t.length>r.length&&(t=t.subarray(0,r.length-n)),r.set(t,n),n+=t.length;return r},ze=$e?e=>globalThis.Buffer.allocUnsafe(e):e=>new Uint8Array(e);function Ve(e){const t=[];let r=0;for(let n=0;n<e.length;n++){let o=e.charCodeAt(n);o<128?t[r++]=o:o<2048?(t[r++]=o>>6|192,t[r++]=63&o|128):55296==(64512&o)&&n+1<e.length&&56320==(64512&e.charCodeAt(n+1))?(o=65536+((1023&o)<<10)+(1023&e.charCodeAt(++n)),t[r++]=o>>18|240,t[r++]=o>>12&63|128,t[r++]=o>>6&63|128,t[r++]=63&o|128):(t[r++]=o>>12|224,t[r++]=o>>6&63|128,t[r++]=63&o|128)}return t}function je(e,t,r){const n=[];for(;t<r;){const o=e[t];let i=null,a=o>239?4:o>223?3:o>191?2:1;if(t+a<=r){let r,n,s,c;switch(a){case 1:o<128&&(i=o);break;case 2:r=e[t+1],128==(192&r)&&(c=(31&o)<<6|63&r,c>127&&(i=c));break;case 3:r=e[t+1],n=e[t+2],128==(192&r)&&128==(192&n)&&(c=(15&o)<<12|(63&r)<<6|63&n,c>2047&&(c<55296||c>57343)&&(i=c));break;case 4:r=e[t+1],n=e[t+2],s=e[t+3],128==(192&r)&&128==(192&n)&&128==(192&s)&&(c=(15&o)<<18|(63&r)<<12|(63&n)<<6|63&s,c>65535&&c<1114112&&(i=c))}}null===i?(i=65533,a=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|1023&i),n.push(i),t+=a}return function(e){const t=e.length;if(t<=He)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=He));return r}(n)}const He=4096;const We="CBOR decode error:",qe="CBOR encode error:",Ge=[];function Ke(e,t,r){if(e.length-t<r)throw new Error(`${We} not enough data for type`)}Ge[23]=1,Ge[24]=2,Ge[25]=3,Ge[26]=5,Ge[27]=9;const Qe=[24,256,65536,4294967296,BigInt("18446744073709551616")];function Ye(e,t,r){Ke(e,t,1);const n=e[t];if(!0===r.strict&&n<Qe[0])throw new Error(`${We} integer encoded in more bytes than necessary (strict decode)`);return n}function Je(e,t,r){Ke(e,t,2);const n=e[t]<<8|e[t+1];if(!0===r.strict&&n<Qe[1])throw new Error(`${We} integer encoded in more bytes than necessary (strict decode)`);return n}function Ze(e,t,r){Ke(e,t,4);const n=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3];if(!0===r.strict&&n<Qe[2])throw new Error(`${We} integer encoded in more bytes than necessary (strict decode)`);return n}function Xe(e,t,r){Ke(e,t,8);const n=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3],o=16777216*e[t+4]+(e[t+5]<<16)+(e[t+6]<<8)+e[t+7],i=(BigInt(n)<<BigInt(32))+BigInt(o);if(!0===r.strict&&i<Qe[3])throw new Error(`${We} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(!0===r.allowBigInt)return i;throw new Error(`${We} integers outside of the safe integer range are not supported`)}function et(e,t){return tt(e,0,t.value)}function tt(e,t,r){if(r<Qe[0]){const n=Number(r);e.push([t|n])}else if(r<Qe[1]){const n=Number(r);e.push([24|t,n])}else if(r<Qe[2]){const n=Number(r);e.push([25|t,n>>>8,255&n])}else if(r<Qe[3]){const n=Number(r);e.push([26|t,n>>>24&255,n>>>16&255,n>>>8&255,255&n])}else{const n=BigInt(r);if(!(n<Qe[4]))throw new Error(`${We} encountered BigInt larger than allowable range`);{const r=[27|t,0,0,0,0,0,0,0];let o=Number(n&BigInt(4294967295)),i=Number(n>>BigInt(32)&BigInt(4294967295));r[8]=255&o,o>>=8,r[7]=255&o,o>>=8,r[6]=255&o,o>>=8,r[5]=255&o,r[4]=255&i,i>>=8,r[3]=255&i,i>>=8,r[2]=255&i,i>>=8,r[1]=255&i,e.push(r)}}}et.encodedSize=function(e){return tt.encodedSize(e.value)},tt.encodedSize=function(e){return e<Qe[0]?1:e<Qe[1]?2:e<Qe[2]?3:e<Qe[3]?5:9},et.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};const rt=BigInt(-1),nt=BigInt(1);function ot(e,t){const r=t.value,n="bigint"==typeof r?r*rt-nt:-1*r-1;tt(e,t.type.majorEncoded,n)}function it(e,t,r,n){Ke(e,t,r+n);const o=Fe(e,t+r,t+r+n);return new Ue(Te.bytes,o,r+n)}function at(e,t,r,n){return it(e,t,1,r)}function st(e){return void 0===e.encodedBytes&&(e.encodedBytes=e.type===Te.string?Oe(e.value):e.value),e.encodedBytes}function ct(e,t){const r=st(t);tt(e,t.type.majorEncoded,r.length),e.push(r)}function dt(e,t,r,n,o){const i=r+n;Ke(e,t,i);const a=new Ue(Te.string,Me(e,t+r,t+i),i);return!0===o.retainStringBytes&&(a.byteValue=Fe(e,t+r,t+i)),a}function lt(e,t,r,n){return dt(e,t,1,r,n)}ot.encodedSize=function(e){const t=e.value,r="bigint"==typeof t?t*rt-nt:-1*t-1;return r<Qe[0]?1:r<Qe[1]?2:r<Qe[2]?3:r<Qe[3]?5:9},ot.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0},ct.encodedSize=function(e){const t=st(e);return tt.encodedSize(t.length)+t.length},ct.compareTokens=function(e,t){return r=st(e),n=st(t),r.length<n.length?-1:r.length>n.length?1:function(e,t){if(Be(e)&&Be(t))return e.compare(t);for(let r=0;r<e.length;r++)if(e[r]!==t[r])return e[r]<t[r]?-1:1;return 0}(r,n);var r,n};const ut=ct;function pt(e,t,r,n){return new Ue(Te.array,n,r)}function ht(e,t,r,n){return pt(0,0,1,r)}function ft(e,t){tt(e,Te.array.majorEncoded,t.value)}function gt(e,t,r,n){return new Ue(Te.map,n,r)}function wt(e,t,r,n){return gt(0,0,1,r)}function vt(e,t){tt(e,Te.map.majorEncoded,t.value)}function yt(e,t,r,n){return new Ue(Te.tag,r,1)}function St(e,t){tt(e,Te.tag.majorEncoded,t.value)}function mt(e,t,r){if(r){if(!1===r.allowNaN&&Number.isNaN(e))throw new Error(`${We} NaN values are not supported`);if(!1===r.allowInfinity&&(e===1/0||e===-1/0))throw new Error(`${We} Infinity values are not supported`)}return new Ue(Te.float,e,t)}function Pt(e,t,r){const n=t.value;if(!1===n)e.push([20|Te.float.majorEncoded]);else if(!0===n)e.push([21|Te.float.majorEncoded]);else if(null===n)e.push([22|Te.float.majorEncoded]);else if(void 0===n)e.push([23|Te.float.majorEncoded]);else{let t,i=!1;r&&!0===r.float64||(It(n),t=_t(Ct,1),n===t||Number.isNaN(n)?(Ct[0]=249,e.push(Ct.slice(0,3)),i=!0):(Et(n),t=Dt(Ct,1),n===t&&(Ct[0]=250,e.push(Ct.slice(0,5)),i=!0))),i||(o=n,At.setFloat64(0,o,!1),t=Rt(Ct,1),Ct[0]=251,e.push(Ct.slice(0,9)))}var o}ft.compareTokens=et.compareTokens,ft.encodedSize=function(e){return tt.encodedSize(e.value)},vt.compareTokens=et.compareTokens,vt.encodedSize=function(e){return tt.encodedSize(e.value)},St.compareTokens=et.compareTokens,St.encodedSize=function(e){return tt.encodedSize(e.value)},Pt.encodedSize=function(e,t){const r=e.value;if(!1===r||!0===r||null==r)return 1;if(!t||!0!==t.float64){It(r);let e=_t(Ct,1);if(r===e||Number.isNaN(r))return 3;if(Et(r),e=Dt(Ct,1),r===e)return 5}return 9};const bt=new ArrayBuffer(9),At=new DataView(bt,1),Ct=new Uint8Array(bt,0);function It(e){if(e===1/0)At.setUint16(0,31744,!1);else if(e===-1/0)At.setUint16(0,64512,!1);else if(Number.isNaN(e))At.setUint16(0,32256,!1);else{At.setFloat32(0,e);const t=At.getUint32(0),r=(2139095040&t)>>23,n=8388607&t;if(255===r)At.setUint16(0,31744,!1);else if(0===r)At.setUint16(0,(2147483648&e)>>16|n>>13,!1);else{const e=r-127;e<-24?At.setUint16(0,0):e<-14?At.setUint16(0,(2147483648&t)>>16|1<<24+e,!1):At.setUint16(0,(2147483648&t)>>16|e+15<<10|n>>13,!1)}}}function _t(e,t){if(e.length-t<2)throw new Error(`${We} not enough data for float16`);const r=(e[t]<<8)+e[t+1];if(31744===r)return 1/0;if(64512===r)return-1/0;if(32256===r)return NaN;const n=r>>10&31,o=1023&r;let i;return i=0===n?o*2**-24:31!==n?(o+1024)*2**(n-25):0===o?1/0:NaN,32768&r?-i:i}function Et(e){At.setFloat32(0,e,!1)}function Dt(e,t){if(e.length-t<4)throw new Error(`${We} not enough data for float32`);const r=(e.byteOffset||0)+t;return new DataView(e.buffer,r,4).getFloat32(0,!1)}function Rt(e,t){if(e.length-t<8)throw new Error(`${We} not enough data for float64`);const r=(e.byteOffset||0)+t;return new DataView(e.buffer,r,8).getFloat64(0,!1)}function Nt(e,t,r){throw new Error(`${We} encountered invalid minor (${r}) for major ${e[t]>>>5}`)}function Tt(e){return()=>{throw new Error(`${We} ${e}`)}}Pt.compareTokens=et.compareTokens;const Ut=[];for(let e=0;e<=23;e++)Ut[e]=Nt;Ut[24]=function(e,t,r,n){return new Ue(Te.uint,Ye(e,t+1,n),2)},Ut[25]=function(e,t,r,n){return new Ue(Te.uint,Je(e,t+1,n),3)},Ut[26]=function(e,t,r,n){return new Ue(Te.uint,Ze(e,t+1,n),5)},Ut[27]=function(e,t,r,n){return new Ue(Te.uint,Xe(e,t+1,n),9)},Ut[28]=Nt,Ut[29]=Nt,Ut[30]=Nt,Ut[31]=Nt;for(let e=32;e<=55;e++)Ut[e]=Nt;Ut[56]=function(e,t,r,n){return new Ue(Te.negint,-1-Ye(e,t+1,n),2)},Ut[57]=function(e,t,r,n){return new Ue(Te.negint,-1-Je(e,t+1,n),3)},Ut[58]=function(e,t,r,n){return new Ue(Te.negint,-1-Ze(e,t+1,n),5)},Ut[59]=function(e,t,r,n){const o=Xe(e,t+1,n);if("bigint"!=typeof o){const e=-1-o;if(e>=Number.MIN_SAFE_INTEGER)return new Ue(Te.negint,e,9)}if(!0!==n.allowBigInt)throw new Error(`${We} integers outside of the safe integer range are not supported`);return new Ue(Te.negint,rt-BigInt(o),9)},Ut[60]=Nt,Ut[61]=Nt,Ut[62]=Nt,Ut[63]=Nt;for(let e=64;e<=87;e++)Ut[e]=at;Ut[88]=function(e,t,r,n){return it(e,t,2,Ye(e,t+1,n))},Ut[89]=function(e,t,r,n){return it(e,t,3,Je(e,t+1,n))},Ut[90]=function(e,t,r,n){return it(e,t,5,Ze(e,t+1,n))},Ut[91]=function(e,t,r,n){const o=Xe(e,t+1,n);if("bigint"==typeof o)throw new Error(`${We} 64-bit integer bytes lengths not supported`);return it(e,t,9,o)},Ut[92]=Nt,Ut[93]=Nt,Ut[94]=Nt,Ut[95]=Tt("indefinite length bytes/strings are not supported");for(let e=96;e<=119;e++)Ut[e]=lt;Ut[120]=function(e,t,r,n){return dt(e,t,2,Ye(e,t+1,n),n)},Ut[121]=function(e,t,r,n){return dt(e,t,3,Je(e,t+1,n),n)},Ut[122]=function(e,t,r,n){return dt(e,t,5,Ze(e,t+1,n),n)},Ut[123]=function(e,t,r,n){const o=Xe(e,t+1,n);if("bigint"==typeof o)throw new Error(`${We} 64-bit integer string lengths not supported`);return dt(e,t,9,o,n)},Ut[124]=Nt,Ut[125]=Nt,Ut[126]=Nt,Ut[127]=Tt("indefinite length bytes/strings are not supported");for(let e=128;e<=151;e++)Ut[e]=ht;Ut[152]=function(e,t,r,n){return pt(0,0,2,Ye(e,t+1,n))},Ut[153]=function(e,t,r,n){return pt(0,0,3,Je(e,t+1,n))},Ut[154]=function(e,t,r,n){return pt(0,0,5,Ze(e,t+1,n))},Ut[155]=function(e,t,r,n){const o=Xe(e,t+1,n);if("bigint"==typeof o)throw new Error(`${We} 64-bit integer array lengths not supported`);return pt(0,0,9,o)},Ut[156]=Nt,Ut[157]=Nt,Ut[158]=Nt,Ut[159]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${We} indefinite length items not allowed`);return pt(0,0,1,1/0)};for(let e=160;e<=183;e++)Ut[e]=wt;Ut[184]=function(e,t,r,n){return gt(0,0,2,Ye(e,t+1,n))},Ut[185]=function(e,t,r,n){return gt(0,0,3,Je(e,t+1,n))},Ut[186]=function(e,t,r,n){return gt(0,0,5,Ze(e,t+1,n))},Ut[187]=function(e,t,r,n){const o=Xe(e,t+1,n);if("bigint"==typeof o)throw new Error(`${We} 64-bit integer map lengths not supported`);return gt(0,0,9,o)},Ut[188]=Nt,Ut[189]=Nt,Ut[190]=Nt,Ut[191]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${We} indefinite length items not allowed`);return gt(0,0,1,1/0)};for(let e=192;e<=215;e++)Ut[e]=yt;Ut[216]=function(e,t,r,n){return new Ue(Te.tag,Ye(e,t+1,n),2)},Ut[217]=function(e,t,r,n){return new Ue(Te.tag,Je(e,t+1,n),3)},Ut[218]=function(e,t,r,n){return new Ue(Te.tag,Ze(e,t+1,n),5)},Ut[219]=function(e,t,r,n){return new Ue(Te.tag,Xe(e,t+1,n),9)},Ut[220]=Nt,Ut[221]=Nt,Ut[222]=Nt,Ut[223]=Nt;for(let e=224;e<=243;e++)Ut[e]=Tt("simple values are not supported");Ut[244]=Nt,Ut[245]=Nt,Ut[246]=Nt,Ut[247]=function(e,t,r,n){if(!1===n.allowUndefined)throw new Error(`${We} undefined values are not supported`);return!0===n.coerceUndefinedToNull?new Ue(Te.null,null,1):new Ue(Te.undefined,void 0,1)},Ut[248]=Tt("simple values are not supported"),Ut[249]=function(e,t,r,n){return mt(_t(e,t+1),3,n)},Ut[250]=function(e,t,r,n){return mt(Dt(e,t+1),5,n)},Ut[251]=function(e,t,r,n){return mt(Rt(e,t+1),9,n)},Ut[252]=Nt,Ut[253]=Nt,Ut[254]=Nt,Ut[255]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${We} indefinite length items not allowed`);return new Ue(Te.break,void 0,1)};const $t=[];for(let e=0;e<24;e++)$t[e]=new Ue(Te.uint,e,1);for(let e=-1;e>=-24;e--)$t[31-e]=new Ue(Te.negint,e,1);$t[64]=new Ue(Te.bytes,new Uint8Array(0),1),$t[96]=new Ue(Te.string,"",1),$t[128]=new Ue(Te.array,0,1),$t[160]=new Ue(Te.map,0,1),$t[244]=new Ue(Te.false,!1,1),$t[245]=new Ue(Te.true,!0,1),$t[246]=new Ue(Te.null,null,1),function(){const e=[];e[Te.uint.major]=et,e[Te.negint.major]=ot,e[Te.bytes.major]=ct,e[Te.string.major]=ut,e[Te.array.major]=ft,e[Te.map.major]=vt,e[Te.tag.major]=St,e[Te.float.major]=Pt}(),new class{constructor(e=256){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),null!==this._initReuseChunk&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let t=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const r=t.length-(this.maxCursor-this.cursor)-1;t.set(e,r)}else{if(t){const e=t.length-(this.maxCursor-this.cursor)-1;e<t.length&&(this.chunks[this.chunks.length-1]=t.subarray(0,e),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(t=ze(this.chunkSize),this.chunks.push(t),this.maxCursor+=t.length,null===this._initReuseChunk&&(this._initReuseChunk=t),t.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let t;if(1===this.chunks.length){const r=this.chunks[0];e&&this.cursor>r.length/2?(t=this.cursor===r.length?r:r.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):t=Fe(r,0,this.cursor)}else t=Le(this.chunks,this.cursor);return e&&this.reset(),t}};class kt{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do{if(t.obj===e)return!0}while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${qe} object contains circular references`);return new kt(t,e)}}const xt={null:new Ue(Te.null,null),undefined:new Ue(Te.undefined,void 0),true:new Ue(Te.true,!0),false:new Ue(Te.false,!1),emptyArray:new Ue(Te.array,0),emptyMap:new Ue(Te.map,0)},Bt={number:(e,t,r,n)=>Number.isInteger(e)&&Number.isSafeInteger(e)?new Ue(e>=0?Te.uint:Te.negint,e):new Ue(Te.float,e),bigint:(e,t,r,n)=>e>=BigInt(0)?new Ue(Te.uint,e):new Ue(Te.negint,e),Uint8Array:(e,t,r,n)=>new Ue(Te.bytes,e),string:(e,t,r,n)=>new Ue(Te.string,e),boolean:(e,t,r,n)=>e?xt.true:xt.false,null:(e,t,r,n)=>xt.null,undefined:(e,t,r,n)=>xt.undefined,ArrayBuffer:(e,t,r,n)=>new Ue(Te.bytes,new Uint8Array(e)),DataView:(e,t,r,n)=>new Ue(Te.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,t,r,n){if(!e.length)return!0===r.addBreakTokens?[xt.emptyArray,new Ue(Te.break)]:xt.emptyArray;n=kt.createCheck(n,e);const o=[];let i=0;for(const t of e)o[i++]=Mt(t,r,n);return r.addBreakTokens?[new Ue(Te.array,e.length),o,new Ue(Te.break)]:[new Ue(Te.array,e.length),o]},Object(e,t,r,n){const o="Object"!==t,i=o?e.keys():Object.keys(e),a=o?e.size:i.length;if(!a)return!0===r.addBreakTokens?[xt.emptyMap,new Ue(Te.break)]:xt.emptyMap;n=kt.createCheck(n,e);const s=[];let c=0;for(const t of i)s[c++]=[Mt(t,r,n),Mt(o?e.get(t):e[t],r,n)];return function(e,t){t.mapSorter&&e.sort(t.mapSorter)}(s,r),r.addBreakTokens?[new Ue(Te.map,a),s,new Ue(Te.break)]:[new Ue(Te.map,a),s]}};Bt.Map=Bt.Object,Bt.Buffer=Bt.Uint8Array;for(const e of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))Bt[`${e}Array`]=Bt.DataView;function Mt(e,t={},r){const n=function(e){if(null===e)return"null";if(void 0===e)return"undefined";if(!0===e||!1===e)return"boolean";const t=typeof e;if(Re.includes(t))return t;if("function"===t)return"Function";if(Array.isArray(e))return"Array";if(function(e){return e&&e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer.call(null,e)}(e))return"Buffer";return function(e){const t=Object.prototype.toString.call(e).slice(8,-1);if(Ne.includes(t))return t}(e)||"Object"}(e),o=t&&t.typeEncoders&&t.typeEncoders[n]||Bt[n];if("function"==typeof o){const i=o(e,n,t,r);if(null!=i)return i}const i=Bt[n];if(!i)throw new Error(`${qe} unsupported type: ${n}`);return i(e,n,t,r)}Symbol.for("DONE"),Symbol.for("BREAK");const Ot={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,rejectDuplicateMapKeys:!0,tags:[]};Ot.tags[42]=function(e){if(0!==e[0])throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return G.decode(e.subarray(1))},Ot.tags.slice();const Ft=([,e])=>e,Lt=([e])=>e,zt=e=>Ft(e).length,Vt=(e,{tree:t,node:r})=>{const n=Ht(e,r);return n.error?{error:new Error(`computing root: ${n.error.message}`)}:l(n.ok,t)?{ok:{}}:{error:new Error("inclusion proof does not lead to the same root")}},jt=63;function Ht(e,t){if(zt(e)>jt)return{error:new RangeError("merkle proofs with depths greater than 63 are not supported")};let r=Lt(e);if(r>>BigInt(zt(e))!==0n)return{error:new RangeError("offset greater than width of the tree")};let n=t,o=0n;for(const t of Ft(e))o=1n&r,r>>=1n,n=1n===o?qt(t,n):qt(n,t);return{ok:n}}function Wt(e,t={}){const n=t.hasher||r,{digest:o}=n.digest(e);return Gt(o)}const qt=(e,t,r)=>{const n=new Uint8Array(e.length+t.length);return n.set(e,0),n.set(t,e.length),Wt(n,r)};function Gt(e){return e[ne-1]&=63,e}const Kt=({offset:e,path:t})=>[e,t],Qt=e=>{const[t,r]=Array.isArray(e)?e:[e.offset,e.path];return Kt({offset:BigInt(t),path:r})},Yt=(e,t,r)=>{if(t<0)throw new RangeError("level can not be negative");if(t>e)throw new RangeError(`level too high: ${t} >= ${e}`);if(r>(1<<e-t)-1)throw new RangeError(`index too large for level: idx ${r}, level ${t} : ${(1<<e-t)-1}`)},Jt=e=>{return 2n**BigInt((t=(e+ee-1n)/ee)<=1n?0:(e=>{let t=0n;for(;e>>=1n;)t++;return Number(t)})(BigInt(t)-1n)+1);var t},Zt=e=>Xt(2n**BigInt(e)),Xt=e=>e*oe,er=4113,tr=Ce,rr=10+Ce,nr=z(er),or=nr+z(rr)+rr;Zt(255),BigInt(Z),BigInt(256);class ir{constructor(e){this.bytes=e;const[t]=F(e);if(t!==er)throw new RangeError("Expected multihash with code 4113");let r=nr;const[n,o]=F(e,r);r+=o;const i=e.subarray(r);if(i.length!==n)throw new RangeError(`Invalid multihash size expected ${r+n} bytes, got ${e.length} bytes`);this.digest=i}get name(){return"fr32-sha2-256-trunc254-padded-binary-tree"}get code(){return er}get size(){return this.digest.length}get padding(){return(({digest:e})=>{const[t]=F(e);return BigInt(t)})(this)}get height(){return(({digest:e})=>{const[,t]=F(e);return e[t]})(this)}get root(){return(({digest:e})=>{const[,t]=F(e);return e.subarray(t+1,t+1+Ce)})(this)}}const ar=new class{constructor(){this.bytes=new Uint8Array(64*ne),this.bytes.set(ae(),0),this.node=ae(),this.length=ne}slice(e,t){for(;this.length<t;)this.node=qt(this.node,this.node),this.bytes.set(this.node,this.length),this.length+=ne;return this.bytes.subarray(e,t)}},sr=e=>{if(e<0||e>=64)throw new Error("Only levels between 0 and 63 inclusive are available");return ar.slice(ne*e,ne*(e+1))},cr=e=>{const t=e.length/ne,r=new Array(t);for(let n=0;n<t;n++){const t=n*ne,o=e.subarray(t,t+ne);r[n]=o}return r};function dr(e){const t=Math.max(e,ie),r=Math.floor(Math.log2(t)),n=Math.ceil(re*2**(r+1));return t<=n?n:Math.ceil(re*2**(r+2))}const lr=e=>dr(e)/re,ur=(e,t=new Uint8Array(lr(e.length)))=>{const r=dr(e.byteLength)/X;for(let n=0;n<r;n++){const r=n*X,o=128*n;t.set(e.subarray(r,r+32),o),t[o+31]&=63;for(let n=32;n<64;n++)t[o+n]=e[r+n]<<2|e[r+n-1]>>6;t[o+63]&=63;for(let n=64;n<96;n++)t[o+n]=e[r+n]<<4|e[r+n-1]>>4;t[o+95]&=63;for(let n=96;n<127;n++)t[o+n]=e[r+n]<<6|e[r+n-1]>>2;t[o+127]=e[r+126]>>2}return t},pr=Zt(255)*BigInt(Z)/BigInt(256),hr=()=>new fr;class fr{constructor(){this.bytesWritten=0n,this.buffer=new Uint8Array(X),this.offset=0,this.layers=[[]]}count(){return this.bytesWritten}digest(){const e=new Uint8Array(or),t=this.digestInto(e,0,!0);return(e=>new ir(e))(e.subarray(0,t))}digestInto(e,t=0,r=!0){const{buffer:n,layers:o,offset:i,bytesWritten:a}=this;let[s,...c]=o;(i>0||0n===a)&&(s=[...s,...cr(ur(n.fill(0,i)))]);const d=wr([s,...c]),l=d.length-1,[u]=d[l],p=Number((e=>(e=>Jt(e)*ee)(e)-e)(this.bytesWritten)),h=z(p);let f=t;if(r){L(4113,e,f),f+=nr;const t=h+1+tr,r=z(t);L(t,e,f),f+=r}return L(p,e,f),f+=h,e[f]=l,f+=1,e.set(u,f),f+=u.length,f-t}write(e){const{buffer:t,offset:r,layers:n}=this,o=n[0],{length:i}=e;if(0===i)return this;if(this.bytesWritten+BigInt(i)>pr)throw new RangeError(`Writing ${i} bytes exceeds max payload size of ${pr}`);if(r+i<t.length)return t.set(e,r),this.offset+=i,this.bytesWritten+=BigInt(i),this;{const n=t.length-r;t.set(e.subarray(0,n),r),o.push(...cr(ur(t)));let a=n;for(;a+X<i;){const t=e.subarray(a,a+X);o.push(...cr(ur(t))),a+=X}return this.buffer.set(e.subarray(a),0),this.offset=i-a,this.bytesWritten+=BigInt(i),gr(this.layers),this}}reset(){return this.offset=0,this.bytesWritten=0n,this.layers.length=1,this.layers[0].length=0,this}dispose(){this.reset()}get code(){return 4113}get name(){return"fr32-sha2-256-trunc254-padded-binary-tree"}}const gr=e=>vr(e,!1),wr=e=>vr([...e],!0),vr=(e,t)=>{let r=0;for(;r<e.length;){let n=e[r+1];const o=e[r];t&&o.length%2>0&&n&&o.push(sr(r)),r+=1,n=n?t?[...n]:n:[];let i=0;for(;i+1<o.length;){const e=qt(o[i],o[i+1]);delete o[i],delete o[i+1],n.push(e),i+=2}n.length&&(e[r]=n),o.splice(0,i)}return e};BigInt(256);const yr=16,Sr=8,{y1:mr,tD:Pr}=o,br=BigInt(ne+mr+mr+Pr);BigInt(ne),Number(br),Zt(60),(()=>{const e=(e=>{const t=BigInt(e);return t<te?{error:RangeError(`Minimum piece size is ${te} bytes`)}:1!==(e=>{let t=0;for(let r=0n;r<64n;r++)0n!=(e&1n<<r)&&t++;return t})(t)?{error:RangeError("Piece size must be a power of 2")}:{ok:t}})(2n**35n);if(e.error)throw e.error;e.ok})();const Ar=61697,Cr=4114;function Ir(e){return dr(e)}function _r(e){return lr(e)}function Er(e){return"string"==typeof e?function(e){try{const t=G.parse(e);return t.code!==Ar||t.multihash.code!==Cr?null:t}catch{return null}}(e):"object"==typeof e&&null!==G.asCID(e)?(t=e).code!==Ar||t.multihash.code!==Cr?null:e:null;var t}function Dr(e){const t=V(Cr,e.bytes.subarray(e.bytes.length-tr));return G.create(1,Ar,t)}function Rr(e){const t=hr();for(let r=0;r<e.length;r+=2048)t.write(e.subarray(r,r+2048));return Dr(t.digest())}function Nr(){const e=hr();let t=!1,r=null;return{stream:new TransformStream({transform(t,r){e.write(t),r.enqueue(t)},flush(){const n=e.digest();r=Dr(n),t=!0}}),getCommP:()=>t?r:null}}async function Tr(e,t){const r=Er(t);if(null==r)throw new Error(`Invalid CommP: ${String(t)}`);if(!e.ok)throw new Error(`Download failed: ${e.status} ${e.statusText}`);if(null==e.body)throw new Error("Response body is null");const{stream:n,getCommP:o}=Nr(),i=[],a=new TransformStream({transform(e,t){i.push(e),t.enqueue(e)}}),s=e.body.pipeThrough(n).pipeThrough(a).getReader();try{for(;;){const{done:e}=await s.read();if(e)break}}finally{s.releaseLock()}const c=o();if(null==c)throw new Error("Failed to calculate CommP from stream");if(c.toString()!==r.toString())throw new Error(`CommP verification failed. Expected: ${String(r)}, Got: ${String(c)}`);const d=i.reduce((e,t)=>e+t.length,0),l=new Uint8Array(d);let u=0;for(const e of i)l.set(e,u),u+=e.length;return l}async function Ur(e,t){const r=await fetch(e);return await Tr(r,t)}function $r(e,t,r,n){let o=`${e} ${t} failed: ${r}`;return null!=n&&n instanceof Error&&(o=`${o} - ${n.message}`),null!=n?new Error(o,{cause:n}):new Error(o)}const kr={USDFC:"USDFC",FIL:"FIL"},xr={mainnet:314,calibration:314159},Br={ERC20:["function balanceOf(address owner) view returns (uint256)","function decimals() view returns (uint8)","function symbol() view returns (string)","function approve(address spender, uint256 amount) returns (bool)","function allowance(address owner, address spender) view returns (uint256)","function transfer(address to, uint256 amount) returns (bool)"],PAYMENTS:["function deposit(address token, address to, uint256 amount)","function withdraw(address token, uint256 amount)","function accounts(address token, address owner) view returns (uint256 funds, uint256 lockupCurrent, uint256 lockupRate, uint256 lockupLastSettledAt)","function setOperatorApproval(address token, address operator, bool approved, uint256 rateAllowance, uint256 lockupAllowance)","function operatorApprovals(address token, address client, address operator) view returns (bool isApproved, uint256 rateAllowance, uint256 rateUsed, uint256 lockupAllowance, uint256 lockupUsed)"],PANDORA_SERVICE:["function registerServiceProvider(string pdpUrl, string pieceRetrievalUrl) external","function approveServiceProvider(address provider) external","function rejectServiceProvider(address provider) external","function removeServiceProvider(uint256 providerId) external","function addServiceProvider(address provider, string pdpUrl, string pieceRetrievalUrl) external","function isProviderApproved(address provider) external view returns (bool)","function getProviderIdByAddress(address provider) external view returns (uint256)","function getApprovedProvider(uint256 providerId) external view returns (tuple(address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt))","function pendingProviders(address provider) external view returns (string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt)","function approvedProviders(uint256 providerId) external view returns (address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt)","function nextServiceProviderId() external view returns (uint256)","function owner() external view returns (address)","function getServicePrice() external view returns (tuple(uint256 pricePerTiBPerMonthNoCDN, uint256 pricePerTiBPerMonthWithCDN, address tokenAddress, uint256 epochsPerMonth) pricing)","function approvedProvidersMap(address) external view returns (bool)","function providerToId(address) external view returns (uint256)","function getAllApprovedProviders() external view returns (tuple(address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt)[])","function getClientProofSets(address client) external view returns (tuple(uint256 railId, address payer, address payee, uint256 commissionBps, string metadata, string[] rootMetadata, uint256 clientDataSetId, bool withCDN)[])","function clientDataSetIDs(address client) external view returns (uint256)","function railToProofSet(uint256 railId) external view returns (uint256 proofSetId)","function getProofSet(uint256 id) public view returns (tuple(uint256 railId, address payer, address payee, uint256 commissionBps, string metadata, string[] rootMetadata, uint256 clientDataSetId, bool withCDN) info)","function getMaxProvingPeriod() external view returns (uint64)","function challengeWindow() external view returns (uint256)","function maxProvingPeriod() external view returns (uint64)","function challengeWindowSize() external view returns (uint256)"],PDP_VERIFIER:["function getNextRootId(uint256 setId) public view returns (uint256)","function proofSetLive(uint256 setId) public view returns (bool)","function getProofSetLeafCount(uint256 setId) public view returns (uint256)","function getProofSetOwner(uint256 setId) public view returns (address, address)","function getProofSetListener(uint256 setId) public view returns (address)","event ProofSetCreated(uint256 indexed setId, address indexed owner)"]},Mr={EPOCH_DURATION:30,EPOCHS_PER_DAY:2880n,EPOCHS_PER_MONTH:86400n,DAYS_PER_MONTH:30n,DEFAULT_LOCKUP_DAYS:10n},Or={mainnet:1598306400,calibration:1667326380},Fr={KiB:1024n,MiB:1048576n,GiB:1073741824n,TiB:1099511627776n,MAX_UPLOAD_SIZE:209715200,MIN_UPLOAD_SIZE:65},Lr={TRANSACTION_PROPAGATION_TIMEOUT_MS:3e4,TRANSACTION_PROPAGATION_POLL_INTERVAL_MS:2e3,PROOF_SET_CREATION_TIMEOUT_MS:42e4,PROOF_SET_CREATION_POLL_INTERVAL_MS:2e3,PIECE_PARKING_TIMEOUT_MS:42e4,PIECE_PARKING_POLL_INTERVAL_MS:5e3,TRANSACTION_CONFIRMATIONS:1,ROOT_ADDITION_TIMEOUT_MS:42e4,ROOT_ADDITION_POLL_INTERVAL_MS:1e3},zr={mainnet:{http:"https://api.node.glif.io/rpc/v1",websocket:"wss://wss.node.glif.io/apigw/lotus/rpc/v1"},calibration:{http:"https://api.calibration.node.glif.io/rpc/v1",websocket:"wss://wss.calibration.node.glif.io/apigw/lotus/rpc/v1"}},Vr={USDFC:{mainnet:"0x80B98d3aa09ffff255c3ba4A241111Ff1262F045",calibration:"0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0"},PAYMENTS:{mainnet:"",calibration:"0x0E690D3e60B0576D01352AB03b258115eb84A047"},PANDORA_SERVICE:{mainnet:"",calibration:"0xf49ba5eaCdFD5EE3744efEdf413791935FE4D4c5"},PDP_VERIFIER:{mainnet:"",calibration:"0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC"}},jr={SHA2_256_TRUNC254_PADDED:"sha2-256-trunc254-padded"};function Hr(e,t){const r=Or[t],n=Mr.EPOCH_DURATION;return new Date(1e3*(r+e*n))}function Wr(e,t){const r=Or[t],n=Mr.EPOCH_DURATION,o=Math.floor(e.getTime()/1e3)-r;return Math.floor(o/n)}function qr(e){return Or[e]}function Gr(e,t){const r=e-t,n=r*Mr.EPOCH_DURATION;return{epochs:r,seconds:n,minutes:n/60,hours:n/3600,days:n/86400}}function Kr(e,t,r){if(0===e)return null;const n=e-t;return n<=0?null:Hr(n,r)}function Qr(e,t){return`${e.replace(/\/$/,"")}/piece/${t.toString()}`}function Yr(e,t,r=0){const n=e.replace(/\/$/,""),o=d(t.multihash.digest);return`${n}/pdp/piece?${new URLSearchParams({name:jr.SHA2_256_TRUNC254_PADDED,hash:o,size:r.toString()}).toString()}`}function Jr(e){if("object"!=typeof e||null==e)return!1;const t=e;if("string"!=typeof t.createMessageHash)return!1;const r="boolean"==typeof t.proofSetCreated,n="boolean"==typeof t.proofsetCreated;return!(!r&&!n||"string"!=typeof t.service||"string"!=typeof t.txStatus||null!==t.ok&&"boolean"!=typeof t.ok||void 0!==t.proofSetId&&"number"!=typeof t.proofSetId)}function Zr(e){if("object"!=typeof e||null==e)return!1;const t=e;if("string"!=typeof t.txHash)return!1;if("string"!=typeof t.txStatus)return!1;if("number"!=typeof t.proofSetId)return!1;if("number"!=typeof t.rootCount)return!1;if(null!==t.addMessageOk&&"boolean"!=typeof t.addMessageOk)return!1;if(void 0!==t.confirmedRootIds){if(!Array.isArray(t.confirmedRootIds))return!1;for(const e of t.confirmedRootIds)if("number"!=typeof e)return!1}return!0}function Xr(e){if("object"!=typeof e||null==e)return!1;const t=e,r="string"==typeof t.pieceCid,n="string"==typeof t.piece_cid;return!(!r&&!n)&&null!=Er(t.pieceCid??t.piece_cid)}function en(e){if(!Jr(e))throw new Error("Invalid proof set creation status response format");const t=e,r={createMessageHash:t.createMessageHash,proofSetCreated:t.proofSetCreated??t.proofsetCreated,service:t.service,txStatus:t.txStatus,ok:t.ok};return void 0!==t.proofSetId&&(r.proofSetId=t.proofSetId),r}function tn(e){if(!Zr(e))throw new Error("Invalid root addition status response format");return e}function rn(e){if(!Xr(e)){if("object"==typeof e&&null!=e){const t=e,r=t.pieceCid??t.piece_cid;if(null!=r&&null==Er(r))throw new Error("Invalid find piece response: pieceCid is not a valid CommP")}throw new Error("Invalid find piece response format")}const t=e,r=Er(t.pieceCid??t.piece_cid);if(null==r)throw new Error("Invalid find piece response: pieceCid is not a valid CommP");return{pieceCid:r,piece_cid:t.piece_cid}}function nn(e){if("object"!=typeof e||null==e)return null;const t=e;if("number"!=typeof t.rootId)return null;if("string"!=typeof t.rootCid)return null;if("string"!=typeof t.subrootCid)return null;if("number"!=typeof t.subrootOffset)return null;const r=Er(t.rootCid),n=Er(t.subrootCid);return null==r||null==n?null:{rootId:t.rootId,rootCid:r,subrootCid:n,subrootOffset:t.subrootOffset}}function on(e){if("object"!=typeof e||null==e)return null;const t=e;if("number"!=typeof t.id)return null;if(!Array.isArray(t.roots))return null;const r=[];for(const e of t.roots){const t=nn(e);if(null==t)return null;r.push(t)}return"number"!=typeof t.nextChallengeEpoch?null:{id:t.id,roots:r,nextChallengeEpoch:t.nextChallengeEpoch}}class an{_apiEndpoint;_retrievalEndpoint;_authHelper;_serviceName;constructor(e,t,r,n="public"){if(""===t.trim())throw new Error("PDP API endpoint is required");if(""===r.trim())throw new Error("PDP retrieval endpoint is required");this._apiEndpoint=t.replace(/\/$/,""),this._retrievalEndpoint=r.replace(/\/$/,""),this._authHelper=e,this._serviceName=n}async createProofSet(e,t,r,n){const o=await this.getAuthHelper().signCreateProofSet(e,t,r),i={recordKeeper:n,extraData:`0x${this._encodeProofSetCreateData({metadata:"",payer:await this.getAuthHelper().getSignerAddress(),withCDN:r,signature:o.signature})}`},a=await fetch(`${this._apiEndpoint}/pdp/proof-sets`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(i)});if(201!==a.status){const e=await a.text();throw new Error(`Failed to create proof set: ${a.status} ${a.statusText} - ${e}`)}const s=a.headers.get("Location");if(null==s)throw new Error("Server did not provide Location header in response");const c=s.match(/\/pdp\/proof-sets\/created\/(.+)$/);if(null==c)throw new Error(`Invalid Location header format: ${s}`);return{txHash:c[1],statusUrl:`${this._apiEndpoint}${s}`}}async addRoots(e,t,r,n){if(0===n.length)throw new Error("At least one root must be provided");for(const e of n)if(null==Er(e.cid))throw new Error(`Invalid CommP: ${String(e.cid)}`);const o=await this.getAuthHelper().signAddRoots(t,r,n),i=this._encodeAddRootsExtraData({signature:o.signature,metadata:""}),a={roots:n.map(e=>{const t="string"==typeof e.cid?e.cid:e.cid.toString();return{rootCid:t,subroots:[{subrootCid:t}]}}),extraData:`0x${i}`},s=await fetch(`${this._apiEndpoint}/pdp/proof-sets/${e}/roots`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(a)});if(201!==s.status){const e=await s.text();throw new Error(`Failed to add roots to proof set: ${s.status} ${s.statusText} - ${e}`)}const c=s.headers.get("Location");let d,l;if(null!=c){const e=c.match(/\/roots\/added\/([0-9a-fA-Fx]+)$/);null!=e&&(d=e[1],d.startsWith("0x")||(d="0x"+d),l=`${this._apiEndpoint}${c}`)}const u=await s.text();return{message:""!==u?u:`Roots added to proof set ID ${e} successfully`,txHash:d,statusUrl:l}}async getProofSetCreationStatus(e){const t=await fetch(`${this._apiEndpoint}/pdp/proof-sets/created/${e}`,{method:"GET",headers:{"Content-Type":"application/json"}});if(404===t.status)throw new Error(`Proof set creation not found for transaction hash: ${e}`);if(200!==t.status){const e=await t.text();throw new Error(`Failed to get proof set creation status: ${t.status} ${t.statusText} - ${e}`)}return en(await t.json())}async getRootAdditionStatus(e,t){const r=await fetch(`${this._apiEndpoint}/pdp/proof-sets/${e}/roots/added/${t}`,{method:"GET",headers:{"Content-Type":"application/json"}});if(404===r.status)throw new Error(`Root addition not found for transaction: ${t}`);if(200!==r.status){const e=await r.text();throw new Error(`Failed to get root addition status: ${r.status} ${r.statusText} - ${e}`)}return tn(await r.json())}async findPiece(e,t){const r=Er(e);if(null==r)throw new Error(`Invalid CommP: ${String(e)}`);const n=Yr(this._apiEndpoint,r,t),o=await fetch(n,{method:"GET",headers:{}});if(404===o.status)throw new Error(`Piece not found: ${r.toString()}`);if(!o.ok){const e=await o.text();throw new Error(`Failed to find piece: ${o.status} ${o.statusText} - ${e}`)}return rn(await o.json())}async uploadPiece(e){const t=e instanceof ArrayBuffer?new Uint8Array(e):e,r=await Rr(t),n=t.length,o=d(r.multihash.digest),i={check:{name:jr.SHA2_256_TRUNC254_PADDED,hash:o,size:n}},a=await fetch(`${this._apiEndpoint}/pdp/piece`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(i)});if(200===a.status)return{commP:r,size:n};if(201!==a.status){const e=await a.text();throw new Error(`Failed to create upload session: ${a.status} ${a.statusText} - ${e}`)}const s=a.headers.get("Location");if(null==s)throw new Error("Server did not provide Location header in response (may be restricted by CORS policy)");const c=s.match(/\/(?:pdp\/)?piece\/upload\/([a-fA-F0-9-]+)/);if(null==c)throw new Error(`Invalid Location header format: ${s}`);const l=c[1],u=await fetch(`${this._apiEndpoint}/pdp/piece/upload/${l}`,{method:"PUT",headers:{"Content-Type":"application/octet-stream","Content-Length":t.length.toString()},body:t});if(204!==u.status){const e=await u.text();throw new Error(`Failed to upload piece: ${u.status} ${u.statusText} - ${e}`)}return{commP:r,size:n}}async downloadPiece(e){const t=Er(e);if(null==t)throw new Error(`Invalid CommP: ${String(e)}`);const r=Qr(this._retrievalEndpoint,t),n=await fetch(r);return await Tr(n,t)}async getProofSet(e){const t=await fetch(`${this._apiEndpoint}/pdp/proof-sets/${e}`,{method:"GET",headers:{Accept:"application/json"}});if(404===t.status)throw new Error(`Proof set not found: ${e}`);if(!t.ok){const e=await t.text();throw new Error(`Failed to fetch proof set: ${t.status} ${t.statusText} - ${e}`)}const r=on(await t.json());if(null==r)throw new Error("Invalid proof set data response format");return r}_encodeProofSetCreateData(t){const r=t.signature.startsWith("0x")?t.signature:`0x${t.signature}`;return e.AbiCoder.defaultAbiCoder().encode(["string","address","bool","bytes"],[t.metadata,t.payer,t.withCDN,r]).slice(2)}_encodeAddRootsExtraData(t){const r=t.signature.startsWith("0x")?t.signature:`0x${t.signature}`;return e.AbiCoder.defaultAbiCoder().encode(["bytes","string"],[r,t.metadata]).slice(2)}async ping(){const e=await fetch(`${this._apiEndpoint}/pdp/ping`,{method:"GET",headers:{}});if(200!==e.status){const t=await e.text().catch(()=>"Unknown error");throw new Error(`Provider ping failed: ${e.status} ${e.statusText} - ${t}`)}}getApiEndpoint(){return this._apiEndpoint}getAuthHelper(){if(null==this._authHelper)throw new Error("AuthHelper is not available for an operation that requires signing");return this._authHelper}}const sn={CreateProofSet:[{name:"clientDataSetId",type:"uint256"},{name:"withCDN",type:"bool"},{name:"payee",type:"address"}],Cid:[{name:"data",type:"bytes"}],RootData:[{name:"root",type:"Cid"},{name:"rawSize",type:"uint256"}],AddRoots:[{name:"clientDataSetId",type:"uint256"},{name:"firstAdded",type:"uint256"},{name:"rootData",type:"RootData[]"}],ScheduleRemovals:[{name:"clientDataSetId",type:"uint256"},{name:"rootIds",type:"uint256[]"}],DeleteProofSet:[{name:"clientDataSetId",type:"uint256"}]};class cn{signer;domain;constructor(e,t,r){this.signer=t,this.domain={name:"PandoraService",version:"1",chainId:Number(r),verifyingContract:e}}getUnderlyingSigner(){return"signer"in this.signer&&"NonceManager"===this.signer.constructor.name?this.signer.signer:this.signer}async isMetaMaskSigner(){try{const e=this.getUnderlyingSigner();if("Wallet"===e.constructor.name)return!1;const t=e.provider;if(null==t)return!1;if("_eip1193Provider"in t)return!0;if("undefined"!=typeof globalThis&&"window"in globalThis){const e=globalThis;if(null!=e.window?.ethereum)return!0}if("send"in t||"request"in t)return!0}catch(e){}return!1}async signWithMetaMask(e,t){const r=this.signer.provider;if(null==r)throw new Error("No provider available");const n=await this.signer.getAddress();let o="";for(const t of Object.keys(e))if("Cid"!==t&&"RootData"!==t){o=t;break}const i={types:{EIP712Domain:[{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"}],...e},primaryType:o,domain:this.domain,message:t};let a,s;return a="_eip1193Provider"in r?r._eip1193Provider:r,s=null!=a&&"request"in a?await a.request({method:"eth_signTypedData_v4",params:[n.toLowerCase(),JSON.stringify(i)]}):await r.send("eth_signTypedData_v4",[n.toLowerCase(),JSON.stringify(i)]),s}async signCreateProofSet(t,r,n=!1){let o;if(await this.isMetaMaskSigner()){const e={clientDataSetId:t.toString(),withCDN:n,payee:r};o=await this.signWithMetaMask({CreateProofSet:sn.CreateProofSet},e)}else{const e={clientDataSetId:BigInt(t),withCDN:n,payee:r},i=this.getUnderlyingSigner();o=await i.signTypedData(this.domain,{CreateProofSet:sn.CreateProofSet},e)}const i=e.Signature.from(o),a=e.TypedDataEncoder.hash(this.domain,{CreateProofSet:sn.CreateProofSet},{clientDataSetId:BigInt(t),withCDN:n,payee:r});return{signature:o,v:i.v,r:i.r,s:i.s,signedData:a}}async signAddRoots(t,r,n){const o=[];for(const e of n){const t="string"==typeof e.cid?Er(e.cid):e.cid;if(null==t)throw new Error(`Invalid CommP: ${String(e.cid)}`);o.push({root:{data:t.bytes},rawSize:BigInt(_r(e.rawSize))})}let i;if(await this.isMetaMaskSigner()){const n={clientDataSetId:t.toString(),firstAdded:r.toString(),rootData:o.map(t=>({root:{data:e.hexlify(t.root.data)},rawSize:t.rawSize.toString()}))},a={AddRoots:sn.AddRoots,RootData:sn.RootData,Cid:sn.Cid};i=await this.signWithMetaMask(a,n)}else{const e={clientDataSetId:BigInt(t),firstAdded:BigInt(r),rootData:o},n={AddRoots:sn.AddRoots,RootData:sn.RootData,Cid:sn.Cid},a=this.getUnderlyingSigner();i=await a.signTypedData(this.domain,n,e)}const a=e.Signature.from(i),s=e.TypedDataEncoder.hash(this.domain,{AddRoots:sn.AddRoots,RootData:sn.RootData,Cid:sn.Cid},{clientDataSetId:BigInt(t),firstAdded:BigInt(r),rootData:o});return{signature:i,v:a.v,r:a.r,s:a.s,signedData:s}}async signScheduleRemovals(t,r){const n=r.map(e=>BigInt(e));let o;if(await this.isMetaMaskSigner()){const e={clientDataSetId:t.toString(),rootIds:n.map(e=>e.toString())};o=await this.signWithMetaMask({ScheduleRemovals:sn.ScheduleRemovals},e)}else{const e={clientDataSetId:BigInt(t),rootIds:n},r=this.getUnderlyingSigner();o=await r.signTypedData(this.domain,{ScheduleRemovals:sn.ScheduleRemovals},e)}const i=e.Signature.from(o),a=e.TypedDataEncoder.hash(this.domain,{ScheduleRemovals:sn.ScheduleRemovals},{clientDataSetId:BigInt(t),rootIds:n});return{signature:o,v:i.v,r:i.r,s:i.s,signedData:a}}async signDeleteProofSet(t){let r;if(await this.isMetaMaskSigner()){const e={clientDataSetId:t.toString()};r=await this.signWithMetaMask({DeleteProofSet:sn.DeleteProofSet},e)}else{const e={clientDataSetId:BigInt(t)},n=this.getUnderlyingSigner();r=await n.signTypedData(this.domain,{DeleteProofSet:sn.DeleteProofSet},e)}const n=e.Signature.from(r),o=e.TypedDataEncoder.hash(this.domain,{DeleteProofSet:sn.DeleteProofSet},{clientDataSetId:BigInt(t)});return{signature:r,v:n.v,r:n.r,s:n.s,signedData:o}}async getSignerAddress(){return await this.signer.getAddress()}}class dn{_synapse;_provider;_pdpServer;_pandoraService;_pandoraAddress;_withCDN;_proofSetId;_signer;proofSetId;storageProvider;static validateRawSize(e,t){if(e<Fr.MIN_UPLOAD_SIZE)throw $r("StorageService",t,`Data size (${e} bytes) is below minimum allowed size (${Fr.MIN_UPLOAD_SIZE} bytes).`);if(e>Fr.MAX_UPLOAD_SIZE)throw $r("StorageService",t,`Data size (${e} bytes) exceeds maximum allowed size (${Fr.MAX_UPLOAD_SIZE} bytes)`)}constructor(e,t,r,n,o){this._synapse=e,this._provider=r,this._proofSetId=n,this._withCDN=o.withCDN??!1,this._signer=e.getSigner(),this._pandoraService=t,this.proofSetId=n.toString(),this.storageProvider=r.owner,this._pandoraAddress=e.getPandoraAddress();const i=new cn(this._pandoraAddress,this._signer,e.getChainId());this._pdpServer=new an(i,r.pdpUrl,r.pieceRetrievalUrl)}static async create(e,t,r){const n=e.getSigner(),o=await n.getAddress(),i=await dn.resolveProviderAndProofSet(e,t,o,r);try{r.callbacks?.onProviderSelected?.(i.provider)}catch(e){console.error("Error in onProviderSelected callback:",e)}let a;if(-1===i.proofSetId)a=await dn.createProofSet(e,t,i.provider,r.withCDN??!1,r.callbacks);else{a=i.proofSetId;try{r.callbacks?.onProofSetResolved?.({isExisting:!0,proofSetId:a,provider:i.provider})}catch(e){console.error("Error in onProofSetResolved callback:",e)}}return new dn(e,t,i.provider,a,r)}static async createProofSet(e,t,r,n,o){const i=e.getSigner(),a=await i.getAddress(),s=await t.getNextClientDataSetId(a),c=e.getPandoraAddress(),d=new cn(c,i,e.getChainId()),l=new an(d,r.pdpUrl,r.pieceRetrievalUrl),u=await l.createProofSet(s,r.owner,n,c),{txHash:p,statusUrl:h}=u,f=e.getProvider();let g=null;const w=Date.now(),v=Lr.TRANSACTION_PROPAGATION_TIMEOUT_MS,y=Lr.TRANSACTION_PROPAGATION_POLL_INTERVAL_MS;for(;Date.now()-w<v;){try{if(g=await f.getTransaction(p),null!==g)break}catch(e){console.warn(`Failed to fetch transaction ${p}, retrying...`,e)}await new Promise(e=>setTimeout(e,y))}if(null===g)throw $r("StorageService","create",`Transaction ${p} not found after ${v/1e3} seconds. The transaction may not have propagated to the RPC node.`);try{o?.onProofSetCreationStarted?.(g,h)}catch(e){console.error("Error in onProofSetCreationStarted callback:",e)}let S;try{S=await t.waitForProofSetCreationWithStatus(g,l,Lr.PROOF_SET_CREATION_TIMEOUT_MS,Lr.PROOF_SET_CREATION_POLL_INTERVAL_MS,async(e,t)=>{if(null!=o?.onProofSetCreationProgress)try{let r;if(e.chainStatus.transactionMined&&null!=e.chainStatus.blockNumber)try{r=await g.wait(Lr.TRANSACTION_CONFIRMATIONS)??void 0}catch(e){console.error("Failed to fetch transaction receipt:",e)}o.onProofSetCreationProgress({transactionMined:e.chainStatus.transactionMined,transactionSuccess:e.chainStatus.transactionSuccess,proofSetLive:e.chainStatus.proofSetLive,serverConfirmed:!0===e.serverStatus?.ok,proofSetId:e.summary.proofSetId??void 0,elapsedMs:t,receipt:r})}catch(e){console.error("Error in onProofSetCreationProgress callback:",e)}})}catch(e){throw $r("StorageService","waitForProofSetCreation",e instanceof Error?e.message:"Proof set creation failed")}if(!S.summary.isComplete||null==S.summary.proofSetId)throw $r("StorageService","waitForProofSetCreation",`Proof set creation failed: ${S.summary.error??"Transaction may have failed"}`);const m=S.summary.proofSetId;try{o?.onProofSetResolved?.({isExisting:!1,proofSetId:m,provider:r})}catch(e){console.error("Error in onProofSetResolved callback:",e)}return m}static async resolveProviderAndProofSet(e,t,r,n){return null!=n.proofSetId?await dn.resolveByProofSetId(n.proofSetId,t,r,n):null!=n.providerId?await dn.resolveByProviderId(n.providerId,t,r,n.withCDN??!1):null!=n.providerAddress?await dn.resolveByProviderAddress(n.providerAddress,t,r,n.withCDN??!1):await dn.smartSelectProvider(t,r,n.withCDN??!1,e.getSigner())}static async resolveByProofSetId(e,t,r,n){const o=(await t.getClientProofSetsWithDetails(r)).find(t=>t.pdpVerifierProofSetId===e);if(null==o||!o.isLive||!o.isManaged)throw $r("StorageService","resolveByProofSetId",`Proof set ${e} not found, not owned by ${r}, or not managed by the current Pandora contract`);null==n.providerId&&null==n.providerAddress||await dn.validateProofSetConsistency(o,n,t);const i=await t.getProviderIdByAddress(o.payee);if(0===i)throw $r("StorageService","resolveByProofSetId",`Provider ${o.payee} for proof set ${e} is not currently approved`);return{provider:await t.getApprovedProvider(i),proofSetId:e,isExisting:!0}}static async validateProofSetConsistency(e,t,r){if(null!=t.providerId){const n=await r.getProviderIdByAddress(e.payee);if(n!==t.providerId)throw $r("StorageService","validateProofSetConsistency",`Proof set ${e.pdpVerifierProofSetId} belongs to provider ID ${n}, but provider ID ${t.providerId} was requested`)}if(null!=t.providerAddress&&e.payee.toLowerCase()!==t.providerAddress.toLowerCase())throw $r("StorageService","validateProofSetConsistency",`Proof set ${e.pdpVerifierProofSetId} belongs to provider ${e.payee}, but provider ${t.providerAddress} was requested`)}static async resolveByProviderId(e,t,r,n){const[o,i]=await Promise.all([t.getApprovedProvider(e),t.getClientProofSetsWithDetails(r)]);if("0x0000000000000000000000000000000000000000"===o.owner)throw $r("StorageService","resolveByProviderId",`Provider ID ${e} not found or not approved`);const a=i.filter(e=>e.payee.toLowerCase()===o.owner.toLowerCase()&&e.isLive&&e.isManaged&&e.withCDN===n);if(a.length>0){const e=a.sort((e,t)=>e.currentRootCount>0&&0===t.currentRootCount?-1:t.currentRootCount>0&&0===e.currentRootCount?1:e.pdpVerifierProofSetId-t.pdpVerifierProofSetId);return{provider:o,proofSetId:e[0].pdpVerifierProofSetId,isExisting:!0}}return{provider:o,proofSetId:-1,isExisting:!1}}static async resolveByProviderAddress(e,t,r,n){const o=await t.getProviderIdByAddress(e);if(0===o)throw $r("StorageService","resolveByProviderAddress",`Provider ${e} is not currently approved`);return await dn.resolveByProviderId(o,t,r,n)}static async smartSelectProvider(e,t,r,n){const o=(await e.getClientProofSetsWithDetails(t)).filter(e=>e.isLive&&e.isManaged&&e.withCDN===r);if(o.length>0){const a=o.sort((e,t)=>e.currentRootCount>0&&0===t.currentRootCount?-1:t.currentRootCount>0&&0===e.currentRootCount?1:e.pdpVerifierProofSetId-t.pdpVerifierProofSetId);async function*s(){const t=new Set;for(const r of a){const n=r.payee.toLowerCase();if(t.has(n))continue;t.add(n);const o=await e.getProviderIdByAddress(r.payee);if(0===o){console.warn(`Provider ${r.payee} for proof set ${r.pdpVerifierProofSetId} is not currently approved, skipping`);continue}const i=await e.getApprovedProvider(o);yield i}}const c=await dn.selectProviderWithPing(s()),d=a.find(e=>e.payee.toLowerCase()===c.owner.toLowerCase());if(null==d)throw $r("StorageService","smartSelectProvider","Selected provider not found in proof sets");return{provider:c,proofSetId:d.pdpVerifierProofSetId,isExisting:!0}}const i=await e.getAllApprovedProviders();if(0===i.length)throw $r("StorageService","smartSelectProvider","No approved storage providers available");return{provider:await dn.selectRandomProvider(i,n),proofSetId:-1,isExisting:!1}}static async selectRandomProvider(e,t){if(0===e.length)throw $r("StorageService","selectRandomProvider","No providers available");return await dn.selectProviderWithPing(async function*(){const r=[...e];for(;r.length>0;){let e;if(void 0!==globalThis.crypto&&null!=globalThis.crypto.getRandomValues){const t=new Uint8Array(1);globalThis.crypto.getRandomValues(t),e=t[0]%r.length}else{const n=Date.now()*Math.random()*(await t.getAddress()).split("").reduce((e,t)=>e+t.charCodeAt(0),0)%r.length;e=Math.floor(Math.abs(n))}const n=r.splice(e,1)[0];yield n}}())}static async selectProviderWithPing(e){let t=0;for await(const r of e){t++;try{const e=new an(null,r.pdpUrl,r.pieceRetrievalUrl);return await e.ping(),r}catch(e){console.warn(`Provider ${r.owner} failed ping test:`,e instanceof Error?e.message:String(e))}}if(0===t)throw $r("StorageService","selectProviderWithPing","No reachable storage providers available after ping validation");throw $r("StorageService","selectProviderWithPing",`All ${t} available storage providers failed ping validation`)}async preflightUpload(e){dn.validateRawSize(e,"preflightUpload");const t=await this._pandoraService.checkAllowanceForStorage(e,this._withCDN,this._synapse.payments);return{estimatedCost:{perEpoch:t.costs.perEpoch,perDay:t.costs.perDay,perMonth:t.costs.perMonth},allowanceCheck:{sufficient:t.sufficient,message:t.message},selectedProvider:this._provider,selectedProofSetId:this._proofSetId}}async upload(e,t){const r=e instanceof ArrayBuffer?new Uint8Array(e):e,n=r.length;let o;dn.validateRawSize(n,"upload");try{o=await this._pdpServer.uploadPiece(r)}catch(e){throw $r("StorageService","uploadPiece","Failed to upload piece to storage provider",e)}const i=Lr.PIECE_PARKING_TIMEOUT_MS,a=Lr.PIECE_PARKING_POLL_INTERVAL_MS,s=Date.now();let c=!1;for(;Date.now()-s<i;)try{await this._pdpServer.findPiece(o.commP,o.size),c=!0;break}catch{Date.now()-s+a<i&&await new Promise(e=>setTimeout(e,a))}if(!c)throw $r("StorageService","findPiece","Timeout waiting for piece to be parked on storage provider");null!=t?.onUploadComplete&&t.onUploadComplete(o.commP);try{const e=await this._pandoraService.getAddRootsInfo(this._proofSetId),r=[{cid:o.commP,rawSize:o.size}],n=await this._pdpServer.addRoots(this._proofSetId,e.clientDataSetId,e.nextRootId,r);let i=e.nextRootId;if(null!=n.txHash){let e=null;const r=Date.now(),o=Lr.TRANSACTION_PROPAGATION_TIMEOUT_MS,a=Lr.TRANSACTION_PROPAGATION_POLL_INTERVAL_MS;for(;Date.now()-r<o;){try{if(e=await this._synapse.getProvider().getTransaction(n.txHash),null!==e)break}catch{}await new Promise(e=>setTimeout(e,a))}if(null==e)throw $r("StorageService","addRoots",`Server returned transaction hash ${n.txHash} but transaction was not found on-chain after ${o/1e3} seconds`);let s;t?.onRootAdded?.(e);try{s=await e.wait(Lr.TRANSACTION_CONFIRMATIONS)}catch(e){throw $r("StorageService","addRoots","Failed to wait for transaction confirmation",e)}if(1!==s?.status)throw $r("StorageService","addRoots","Root addition transaction failed on-chain");const c=Lr.ROOT_ADDITION_TIMEOUT_MS,d=Lr.ROOT_ADDITION_POLL_INTERVAL_MS,l=Date.now();let u=null,p=!1;for(;Date.now()-l<c;)try{const e=await this._pdpServer.getRootAdditionStatus(this._proofSetId,n.txHash);if("pending"===e.txStatus){await new Promise(e=>setTimeout(e,d));continue}if(!1===e.addMessageOk)throw new Error("Root addition failed: Transaction was unsuccessful");if(null!=e.confirmedRootIds&&e.confirmedRootIds.length>0){i=e.confirmedRootIds[0],t?.onRootConfirmed?.(e.confirmedRootIds),p=!0;break}await new Promise(e=>setTimeout(e,d))}catch(e){if(u=e,e instanceof Error&&e.message.includes("not found")){await new Promise(e=>setTimeout(e,d));continue}throw $r("StorageService","addRoots",`Failed to verify root addition with server: ${e instanceof Error?e.message:"Unknown error"}`,e)}if(!p)throw $r("StorageService","addRoots",`Failed to verify root addition after ${c/1e3} seconds: ${null!=u?u.message:"Server did not provide confirmation"}. The transaction was confirmed on-chain but the server failed to acknowledge it.`,u)}else t?.onRootAdded?.();return{commp:o.commP,size:o.size,rootId:i}}catch(e){throw $r("StorageService","addRoots","Failed to add root to proof set",e)}}async providerDownload(e,t){return await this._synapse.download(e,{providerAddress:this._provider.owner,withCDN:this._withCDN})}async download(e,t){return await this.providerDownload(e,t)}async getProviderInfo(){return await this._synapse.getProviderInfo(this.storageProvider)}async getProofSetRoots(){return(await this._pdpServer.getProofSet(this._proofSetId)).roots.map(e=>e.rootCid)}async pieceStatus(e){const t=Er(e);if(null==t)throw $r("StorageService","pieceStatus","Invalid CommP provided");const[r,n,o]=await Promise.all([this._pdpServer.findPiece(t,0).then(()=>!0).catch(()=>!1),this._pdpServer.getProofSet(this._proofSetId).catch(e=>(console.debug("Failed to get proof set data:",e),null)),this._synapse.payments.getCurrentEpoch()]),i=r,a=this._synapse.getNetwork();let s,c=null,d=null,l=null,u=!1,p=0,h=!1;if(i){const[e,r]=await Promise.all([this.getProviderInfo().catch(()=>null),null!=n?Promise.all([this._pandoraService.getMaxProvingPeriod(),this._pandoraService.getChallengeWindow()]).then(([e,t])=>({maxProvingPeriod:e,challengeWindow:t})).catch(()=>null):Promise.resolve(null)]);if(null!=e&&(c=`${e.pieceRetrievalUrl.replace(/\/$/,"")}/piece/${t.toString()}`),null!=n&&null!=r){const e=n.roots.find(e=>e.rootCid.toString()===t.toString());if(null!=e)if(s=e.rootId,n.nextChallengeEpoch>0){const e=n.nextChallengeEpoch,t=e+r.challengeWindow;l=Hr(t,a);const i=Kr(n.nextChallengeEpoch,r.maxProvingPeriod,a);null!=i&&(d=i),u=o>=e&&o<t,h=o>=t,o<e&&(p=Gr(e,Number(o)).hours)}else console.debug("Proof set has nextChallengeEpoch=0, may have just been proven")}}return{exists:i,proofSetLastProven:d,proofSetNextProofDue:l,retrievalUrl:c,rootId:s,inChallengeWindow:u,hoursUntilChallengeWindow:p,isProofOverdue:h}}}class ln{_provider;_signer;_network;_disableNonceManager;_usdfcContract=null;_paymentsContract=null;constructor(e,t,r,n){this._provider=e,this._signer=t,this._network=r,this._disableNonceManager=n}_getUsdfcContract(){if(null==this._usdfcContract){const t=Vr.USDFC[this._network];if(null==t)throw new Error(`USDFC contract not deployed on ${this._network} network`);this._usdfcContract=new e.Contract(t,Br.ERC20,this._signer)}return this._usdfcContract}_getPaymentsContract(){if(null==this._paymentsContract){const t=Vr.PAYMENTS[this._network];if(null==t||""===t)throw new Error(`Payments contract not deployed on ${this._network} network. Currently only Calibration testnet is supported.`);this._paymentsContract=new e.Contract(t,Br.PAYMENTS,this._signer)}return this._paymentsContract}async balance(e=kr.USDFC){if(e!==kr.USDFC)throw $r("PaymentsService","payments contract balance check",`Token "${e}" is not supported. Currently only USDFC token is supported for payments contract balance queries.`);return(await this.accountInfo(e)).availableFunds}async accountInfo(e=kr.USDFC){if(e!==kr.USDFC)throw $r("PaymentsService","account info",`Token "${e}" is not supported. Currently only USDFC token is supported.`);const t=await this._signer.getAddress(),r=Vr.USDFC[this._network],n=this._getPaymentsContract();let o;try{o=await n.accounts(r,t)}catch(e){throw $r("PaymentsService","account info","Failed to read account information from payments contract. This could indicate the contract is not properly deployed, the ABI is incorrect, or there are network connectivity issues.",e)}const[i,a,s,c]=o,d=await this.getCurrentEpoch()-BigInt(c),l=BigInt(a)+BigInt(s)*d,u=BigInt(i)-l;return{funds:BigInt(i),lockupCurrent:BigInt(a),lockupRate:BigInt(s),lockupLastSettledAt:BigInt(c),availableFunds:u>0n?u:0n}}async getCurrentEpoch(){const e=await this._provider.getBlock("latest");if(null==e)throw $r("PaymentsService","getCurrentEpoch","Failed to get latest block");return BigInt(e.number)}async walletBalance(e){if(null==e||e===kr.FIL)try{const e=await this._signer.getAddress();return await this._provider.getBalance(e)}catch(e){throw $r("PaymentsService","wallet FIL balance check","Unable to retrieve FIL balance from wallet. This could be due to network connectivity issues, RPC endpoint problems, or wallet connection issues.",e)}if(e===kr.USDFC)try{const e=await this._signer.getAddress(),t=this._getUsdfcContract();return await t.balanceOf(e)}catch(e){throw $r("PaymentsService","wallet USDFC balance check","Unexpected error while checking USDFC token balance in wallet.",e)}throw $r("PaymentsService","wallet balance check",`Token "${e}" is not supported. Currently only USDFC token is supported for balance queries.`)}decimals(e=kr.USDFC){return 18}async allowance(e,t){if(e!==kr.USDFC)throw $r("PaymentsService","allowance",`Token "${e}" is not supported. Currently only USDFC token is supported.`);const r=await this._signer.getAddress(),n=this._getUsdfcContract();try{return await n.allowance(r,t)}catch(e){throw $r("PaymentsService","allowance check","Failed to check token allowance. This could indicate network connectivity issues or an invalid spender address.",e)}}async approve(e,t,r){if(e!==kr.USDFC)throw $r("PaymentsService","approve",`Token "${e}" is not supported. Currently only USDFC token is supported.`);const n="bigint"==typeof r?r:BigInt(r);if(n<0n)throw $r("PaymentsService","approve","Approval amount cannot be negative");const o=await this._signer.getAddress(),i=this._getUsdfcContract(),a={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(o,"pending");a.nonce=e}try{return await i.approve(t,n,a)}catch(r){throw $r("PaymentsService","approve",`Failed to approve ${t} to spend ${n.toString()} ${e}`,r)}}async approveService(e,t,r,n=kr.USDFC){if(n!==kr.USDFC)throw $r("PaymentsService","approveService",`Token "${n}" is not supported. Currently only USDFC token is supported.`);const o="bigint"==typeof t?t:BigInt(t),i="bigint"==typeof r?r:BigInt(r);if(o<0n||i<0n)throw $r("PaymentsService","approveService","Allowance values cannot be negative");const a=await this._signer.getAddress(),s=Vr.USDFC[this._network],c=this._getPaymentsContract(),d={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(a,"pending");d.nonce=e}try{return await c.setOperatorApproval(s,e,!0,o,i,d)}catch(t){throw $r("PaymentsService","approveService",`Failed to approve service ${e} as operator for ${n}`,t)}}async revokeService(e,t=kr.USDFC){if(t!==kr.USDFC)throw $r("PaymentsService","revokeService",`Token "${t}" is not supported. Currently only USDFC token is supported.`);const r=await this._signer.getAddress(),n=Vr.USDFC[this._network],o=this._getPaymentsContract(),i={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(r,"pending");i.nonce=e}try{return await o.setOperatorApproval(n,e,!1,0n,0n,i)}catch(r){throw $r("PaymentsService","revokeService",`Failed to revoke service ${e} as operator for ${t}`,r)}}async serviceApproval(e,t=kr.USDFC){if(t!==kr.USDFC)throw $r("PaymentsService","serviceApproval",`Token "${t}" is not supported. Currently only USDFC token is supported.`);const r=await this._signer.getAddress(),n=Vr.USDFC[this._network],o=this._getPaymentsContract();try{const t=await o.operatorApprovals(n,r,e);return{isApproved:t[0],rateAllowance:t[1],lockupAllowance:t[2],rateUsed:t[3],lockupUsed:t[4]}}catch(t){throw $r("PaymentsService","serviceApproval",`Failed to check service approval status for ${e}`,t)}}async deposit(e,t=kr.USDFC,r){if(t!==kr.USDFC)throw $r("PaymentsService","deposit",`Unsupported token: ${t}`);const n="bigint"==typeof e?e:BigInt(e);if(n<=0n)throw $r("PaymentsService","deposit","Invalid amount");const o=await this._signer.getAddress(),i=Vr.USDFC[this._network],a=this._getUsdfcContract(),s=this._getPaymentsContract(),c=await a.balanceOf(o);if(c<n)throw $r("PaymentsService","deposit",`Insufficient USDFC: have ${BigInt(c).toString()}, need ${n.toString()}`);const d=Vr.PAYMENTS[this._network];if(null==d)throw $r("PaymentsService","deposit",`Payments contract not deployed on ${this._network}`);const l=await this.allowance(t,d);if(r?.onAllowanceCheck?.(l,n),l<n){const e=await this.approve(t,d,n);r?.onApprovalTransaction?.(e);const o=await e.wait(Lr.TRANSACTION_CONFIRMATIONS);null!=o&&r?.onApprovalConfirmed?.(o)}r?.onDepositStarting?.();const u={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(o,"pending");u.nonce=e}return await s.deposit(i,o,n,u)}async withdraw(e,t=kr.USDFC){if(t!==kr.USDFC)throw $r("PaymentsService","withdraw",`Unsupported token: ${t}`);const r="bigint"==typeof e?e:BigInt(e);if(r<=0n)throw $r("PaymentsService","withdraw","Invalid amount");const n=await this._signer.getAddress(),o=Vr.USDFC[this._network],i=this._getPaymentsContract(),a=await this.accountInfo(t);if(a.availableFunds<r)throw $r("PaymentsService","withdraw",`Insufficient available balance: have ${a.availableFunds.toString()}, need ${r.toString()}`);const s={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(n,"pending");s.nonce=e}return await i.withdraw(o,r,s)}}class un{_provider;_contractAddress;_contract;constructor(t,r){this._provider=t,this._contractAddress=r,this._contract=new e.Contract(this._contractAddress,Br.PDP_VERIFIER,this._provider)}async proofSetLive(e){return await this._contract.proofSetLive(e)}async getNextRootId(e){const t=await this._contract.getNextRootId(e);return Number(t)}async getProofSetListener(e){return await this._contract.getProofSetListener(e)}async getProofSetOwner(e){const[t,r]=await this._contract.getProofSetOwner(e);return{owner:t,proposedOwner:r}}async getProofSetLeafCount(e){const t=await this._contract.getProofSetLeafCount(e);return Number(t)}extractProofSetIdFromReceipt(e){try{for(const t of e.logs)try{const e=this._contract.interface.parseLog({topics:t.topics,data:t.data});if(null!=e&&"ProofSetCreated"===e.name)return Number(e.args.setId)}catch(e){continue}return null}catch(e){throw new Error(`Failed to extract proof set ID from receipt: ${e instanceof Error?e.message:String(e)}`)}}getContractAddress(){return this._contract.target}}class pn{_provider;_pandoraAddress;_pdpVerifierAddress;_pandoraContract=null;_pdpVerifier=null;constructor(e,t,r){this._provider=e,this._pandoraAddress=t,this._pdpVerifierAddress=r}_getPandoraContract(){return null==this._pandoraContract&&(this._pandoraContract=new e.Contract(this._pandoraAddress,Br.PANDORA_SERVICE,this._provider)),this._pandoraContract}_getPDPVerifier(){return null==this._pdpVerifier&&(this._pdpVerifier=new un(this._provider,this._pdpVerifierAddress)),this._pdpVerifier}async getClientProofSets(e){const t=this._getPandoraContract();try{const r=await t.getClientProofSets(e),n=[];for(let e=0;e<r.length;e++){const t=r[e];"0x0000000000000000000000000000000000000000"!==t.payer&&0!==Number(t.railId)&&n.push({railId:Number(t.railId),payer:t.payer,payee:t.payee,commissionBps:Number(t.commissionBps),metadata:t.metadata,rootMetadata:t.rootMetadata,clientDataSetId:Number(t.clientDataSetId),withCDN:t.withCDN})}return n}catch(e){throw new Error(`Failed to get client proof sets: ${e instanceof Error?e.message:String(e)}`)}}async getClientProofSetsWithDetails(e,t=!1){const r=await this.getClientProofSets(e),n=this._getPDPVerifier(),o=this._getPandoraContract(),i=r.map(async e=>{try{const r=await o.railToProofSet(e.railId);if(0===Number(r))return t?null:{...e,pdpVerifierProofSetId:0,nextRootId:0,currentRootCount:0,isLive:!1,isManaged:!1};const[i,a]=await Promise.all([n.proofSetLive(Number(r)),n.getProofSetListener(Number(r)).catch(()=>null)]),s=null!=a&&a.toLowerCase()===this._pandoraAddress.toLowerCase();if(t&&!s)return null;const c=i?await n.getNextRootId(Number(r)):0;return{...e,pdpVerifierProofSetId:Number(r),nextRootId:Number(c),currentRootCount:Number(c),isLive:i,isManaged:s}}catch(t){throw new Error(`Failed to get details for proof set with rail ID ${e.railId}: ${t instanceof Error?t.message:String(t)}`)}});return(await Promise.all(i)).filter(e=>null!==e)}async getAddRootsInfo(e){try{const t=this._getPandoraContract(),r=this._getPDPVerifier(),[n,o,i,a]=await Promise.all([r.proofSetLive(Number(e)),r.getNextRootId(Number(e)),r.getProofSetListener(Number(e)),t.getProofSet(Number(e))]);if(!n)throw new Error(`Proof set ${e} does not exist or is not live`);if(i.toLowerCase()!==this._pandoraAddress.toLowerCase())throw new Error(`Proof set ${e} is not managed by this Pandora contract (${this._pandoraAddress}), managed by ${String(i)}`);const s=Number(a.clientDataSetId);return{nextRootId:Number(o),clientDataSetId:s,currentRootCount:Number(o)}}catch(e){throw new Error(`Failed to get add roots info: ${e instanceof Error?e.message:String(e)}`)}}async getNextClientDataSetId(e){try{const t=this._getPandoraContract(),r=await t.clientDataSetIDs(e);return Number(r)}catch(e){throw new Error(`Failed to get next client dataset ID: ${e instanceof Error?e.message:String(e)}`)}}async verifyProofSetCreation(e){try{const t="string"==typeof e?e:e.hash;let r;if(r="string"==typeof e?await this._provider.getTransactionReceipt(t):await e.wait(Lr.TRANSACTION_CONFIRMATIONS),null==r)return{transactionMined:!1,transactionSuccess:!1,proofSetLive:!1};if(1!==r.status)return{transactionMined:!0,transactionSuccess:!1,proofSetLive:!1,blockNumber:r.blockNumber,gasUsed:r.gasUsed,error:"Transaction failed"};const n=this._getPDPVerifier(),o=await n.extractProofSetIdFromReceipt(r);return null==o?{transactionMined:!0,transactionSuccess:!0,proofSetLive:!1,blockNumber:r.blockNumber,gasUsed:r.gasUsed,error:"Could not find ProofSetCreated event in transaction"}:{transactionMined:!0,transactionSuccess:!0,proofSetId:o,proofSetLive:await n.proofSetLive(o),blockNumber:r.blockNumber,gasUsed:r.gasUsed}}catch(e){return{transactionMined:!1,transactionSuccess:!1,proofSetLive:!1,error:`Verification failed: ${e instanceof Error?e.message:String(e)}`}}}async getComprehensiveProofSetStatus(e,t){const r="string"==typeof e?e:e.hash;let n=null;try{n=await t.getProofSetCreationStatus(r)}catch(e){}const o=await this.verifyProofSetCreation(e);return{txHash:r,serverStatus:n,chainStatus:o,summary:{isComplete:o.transactionMined&&o.proofSetLive&&null!=n&&!0===n.ok,isLive:o.proofSetLive,proofSetId:o.proofSetId??n?.proofSetId??null,error:o.error??null}}}async waitForProofSetCreationWithStatus(e,t,r=Lr.PROOF_SET_CREATION_TIMEOUT_MS,n=Lr.PROOF_SET_CREATION_POLL_INTERVAL_MS,o){const i=Date.now();for(;Date.now()-i<r;){const r=await this.getComprehensiveProofSetStatus(e,t);if(null!=o)try{await o(r,Date.now()-i)}catch(e){console.error("Error in progress callback:",e)}if(r.summary.isComplete||null!=r.summary.error)return r;await new Promise(e=>setTimeout(e,n))}throw new Error(`Timeout waiting for proof set creation after ${r}ms`)}async calculateStorageCost(e){const t=this._getPandoraContract();let r,n,o;try{const e=await t.getServicePrice();r=BigInt(e.pricePerTiBPerMonthNoCDN),n=BigInt(e.pricePerTiBPerMonthWithCDN),o=BigInt(e.epochsPerMonth)}catch(e){throw console.error("Error calling getServicePrice:",e),e}const i=BigInt(e),a=r*i/(Fr.TiB*o),s=n*i/(Fr.TiB*o);return{perEpoch:a,perDay:a*Mr.EPOCHS_PER_DAY,perMonth:a*o,withCDN:{perEpoch:s,perDay:s*Mr.EPOCHS_PER_DAY,perMonth:s*o}}}async checkAllowanceForStorage(e,t,r,n){const o=await r.serviceApproval(this._pandoraAddress,kr.USDFC),i=await this.calculateStorageCost(e),a=t?i.withCDN:i,s=a.perEpoch,c=s*(BigInt(n??Mr.DEFAULT_LOCKUP_DAYS)*Mr.EPOCHS_PER_DAY),d=BigInt(o.rateUsed)+s,l=BigInt(o.lockupUsed)+c,u=o.rateAllowance>=d&&o.lockupAllowance>=l;let p;if(!u){const e=[];o.rateAllowance<d&&e.push(`Rate allowance insufficient: current ${String(o.rateAllowance)}, need ${String(d)}`),o.lockupAllowance<l&&e.push(`Lockup allowance insufficient: current ${String(o.lockupAllowance)}, need ${String(l)}`),p=e.join(". ")}return{rateAllowanceNeeded:d,lockupAllowanceNeeded:l,currentRateAllowance:o.rateAllowance,currentLockupAllowance:o.lockupAllowance,currentRateUsed:o.rateUsed,currentLockupUsed:o.lockupUsed,sufficient:u,message:p,costs:{perEpoch:a.perEpoch,perDay:a.perDay,perMonth:a.perMonth},depositAmountNeeded:c}}async prepareStorageUpload(e,t){const r=await this.calculateStorageCost(e.dataSize),n=!0===e.withCDN?r.withCDN:r,o=await this.checkAllowanceForStorage(e.dataSize,e.withCDN??!1,t),i=[],a=await t.accountInfo(kr.USDFC),s=n.perMonth;if(a.availableFunds<s){const e=s-a.availableFunds;i.push({type:"deposit",description:`Deposit ${e} USDFC to payments contract`,execute:async()=>await t.deposit(e,kr.USDFC)})}return o.sufficient||i.push({type:"approveService",description:`Approve service with rate allowance ${o.rateAllowanceNeeded} and lockup allowance ${o.lockupAllowanceNeeded}`,execute:async()=>await t.approveService(this._pandoraAddress,o.rateAllowanceNeeded,o.lockupAllowanceNeeded,kr.USDFC)}),{estimatedCost:{perEpoch:n.perEpoch,perDay:n.perDay,perMonth:n.perMonth},allowanceCheck:{sufficient:o.sufficient,message:o.message},actions:i}}async registerServiceProvider(e,t,r){const n=this._getPandoraContract().connect(e);return await n.registerServiceProvider(t,r)}async approveServiceProvider(e,t){const r=this._getPandoraContract().connect(e);return await r.approveServiceProvider(t)}async rejectServiceProvider(e,t){const r=this._getPandoraContract().connect(e);return await r.rejectServiceProvider(t)}async removeServiceProvider(e,t){const r=this._getPandoraContract().connect(e);return await r.removeServiceProvider(t)}async addServiceProvider(e,t,r,n){const o=this._getPandoraContract().connect(e);return await o.addServiceProvider(t,r,n)}async isProviderApproved(e){const t=this._getPandoraContract();return await t.isProviderApproved(e)}async getProviderIdByAddress(e){const t=this._getPandoraContract(),r=await t.getProviderIdByAddress(e);return Number(r)}async getApprovedProvider(e){const t=this._getPandoraContract(),r=await t.getApprovedProvider(e);return{owner:r.owner,pdpUrl:r.pdpUrl,pieceRetrievalUrl:r.pieceRetrievalUrl,registeredAt:Number(r.registeredAt),approvedAt:Number(r.approvedAt)}}async getPendingProvider(e){const t=this._getPandoraContract(),r=await t.pendingProviders(e);return{pdpUrl:r.pdpUrl,pieceRetrievalUrl:r.pieceRetrievalUrl,registeredAt:Number(r.registeredAt)}}async getNextProviderId(){const e=this._getPandoraContract(),t=await e.nextServiceProviderId();return Number(t)}async getOwner(){const e=this._getPandoraContract();return await e.owner()}async isOwner(e){const t=await e.getAddress(),r=await this.getOwner();return t.toLowerCase()===r.toLowerCase()}async getAllApprovedProviders(){const e=this._getPandoraContract();return(await e.getAllApprovedProviders()).map(e=>({owner:e.owner,pdpUrl:e.pdpUrl,pieceRetrievalUrl:e.pieceRetrievalUrl,registeredAt:Number(e.registeredAt),approvedAt:Number(e.approvedAt)}))}async getServicePrice(){const e=this._getPandoraContract(),t=await e.getServicePrice();return{pricePerTiBPerMonthNoCDN:t.pricePerTiBPerMonthNoCDN,pricePerTiBPerMonthWithCDN:t.pricePerTiBPerMonthWithCDN,tokenAddress:t.tokenAddress,epochsPerMonth:t.epochsPerMonth}}async getMaxProvingPeriod(){const e=this._getPandoraContract(),t=await e.getMaxProvingPeriod();return Number(t)}async getChallengeWindow(){const e=this._getPandoraContract(),t=await e.challengeWindow();return Number(t)}async getProvingPeriodInHours(){return 30*await this.getMaxProvingPeriod()/3600}async getChallengeWindowInMinutes(){return 30*await this.getChallengeWindow()/60}async getProvingPeriodInfo(){const[e,t]=await Promise.all([this.getMaxProvingPeriod(),this.getChallengeWindow()]);return{maxProvingPeriodEpochs:e,challengeWindowEpochs:t,maxProvingPeriodHours:30*e/3600,challengeWindowMinutes:30*t/60,epochDurationSeconds:30}}}const hn="\n    query GetApprovedProvidersForCommP($cid: Bytes!) {\n      roots(where: { cid: $cid }) {\n        id\n        proofSet {\n          setId\n          owner {\n            id\n            address\n            pdpUrl\n            pieceRetrievalUrl\n            registeredAt\n            status\n            approvedAt\n          }\n        }\n      }\n    }\n  ",fn="\n    query Provider($providerId: ID!) {\n      provider(id: $providerId) {\n        id\n        address\n        pdpUrl\n        pieceRetrievalUrl\n        registeredAt\n        approvedAt\n      }\n    }\n  ",gn="\n    query ProvidersFlexible($where: Provider_filter, $first: Int, $skip: Int, $orderBy: Provider_orderBy, $orderDirection: OrderDirection) {\n      providers(\n        where: $where\n        first: $first\n        skip: $skip\n        orderBy: $orderBy\n        orderDirection: $orderDirection\n      ) {\n        id\n        address\n        pdpUrl\n        pieceRetrievalUrl\n        registeredAt\n        approvedAt\n        status\n        totalFaultedPeriods\n        totalFaultedRoots\n        totalProofSets\n        totalRoots\n        totalDataSize\n        createdAt\n        updatedAt\n      }\n    }\n  ",wn="\n    query ProofSetsFlexible($where: ProofSet_filter, $first: Int, $skip: Int, $orderBy: ProofSet_orderBy, $orderDirection: OrderDirection) {\n      proofSets(\n        where: $where\n        first: $first\n        skip: $skip\n        orderBy: $orderBy\n        orderDirection: $orderDirection\n      ) {\n        id\n        setId\n        listener\n        clientAddr\n        withCDN\n        isActive\n        leafCount\n        challengeRange\n        lastProvenEpoch\n        nextChallengeEpoch\n        totalRoots\n        totalDataSize\n        totalProofs\n        totalProvedRoots\n        totalFaultedPeriods\n        totalFaultedRoots\n        metadata\n        createdAt\n        updatedAt\n        owner {\n          id\n          address\n          pdpUrl\n          pieceRetrievalUrl\n          registeredAt\n          approvedAt\n        }\n        rail {\n          id\n          railId\n          token\n          paymentRate\n          lockupPeriod\n          settledUpto\n          endEpoch\n        }\n      }\n    }\n  ",vn="\n    query RootsFlexible($where: Root_filter, $first: Int, $skip: Int, $orderBy: Root_orderBy, $orderDirection: OrderDirection) {\n      roots(\n        where: $where\n        first: $first\n        skip: $skip\n        orderBy: $orderBy\n        orderDirection: $orderDirection\n      ) {\n        id\n        setId\n        rootId\n        rawSize\n        leafCount\n        cid\n        removed\n        totalProofsSubmitted\n        totalPeriodsFaulted\n        lastProvenEpoch\n        lastProvenAt\n        lastFaultedEpoch\n        lastFaultedAt\n        createdAt\n        metadata\n        proofSet {\n          id\n          setId\n          isActive\n          owner {\n            id\n            address\n            pdpUrl\n            pieceRetrievalUrl\n            registeredAt\n            approvedAt\n          }\n        }\n      }\n    }\n  ",yn="\n    query FaultRecordsFlexible($where: FaultRecord_filter, $first: Int, $skip: Int, $orderBy: FaultRecord_orderBy, $orderDirection: OrderDirection) {\n      faultRecords(\n        where: $where\n        first: $first\n        skip: $skip\n        orderBy: $orderBy\n        orderDirection: $orderDirection\n      ) {\n        id\n        proofSetId\n        rootIds\n        currentChallengeEpoch\n        nextChallengeEpoch\n        periodsFaulted\n        deadline\n        createdAt\n        proofSet {\n          id\n          setId\n          owner {\n            id\n            address\n            pdpUrl\n            pieceRetrievalUrl\n            registeredAt\n            approvedAt\n          }\n        }\n      }\n    }\n  ";class Sn{endpoint;headers;constructor(e){this.endpoint=this.resolveEndpoint(e),this.headers=this.buildHeaders(e.apiKey)}resolveEndpoint(e){if(null!=e.endpoint&&""!==e.endpoint.trim())return e.endpoint.trim();if(null!=e.goldsky)return this.buildGoldskyEndpoint(e.goldsky);throw $r("SubgraphService","constructor","Invalid configuration: provide either endpoint or complete goldsky config")}buildGoldskyEndpoint(e){const{projectId:t,subgraphName:r,version:n}=e;if(null==t?.trim()||""===t?.trim()||null==r?.trim()||""===r?.trim()||null==n?.trim()||""===n?.trim())throw $r("SubgraphService","constructor","Incomplete Goldsky config: projectId, subgraphName, and version required");return`https://api.goldsky.com/api/public/${t}/subgraphs/${r}/${n}/gn`}buildHeaders(e){const t={"Content-Type":"application/json"};return null!=e&&""!==e?{...t,Authorization:`Bearer ${e}`}:t}normalizeQueryOptions(e={}){return{where:{},first:10,skip:0,orderBy:"createdAt",orderDirection:"desc",...e}}async executeQuery(e,t,r){try{const n=await fetch(this.endpoint,{method:"POST",headers:this.headers,body:JSON.stringify({query:e,variables:t})});if(!n.ok){const e=await n.text();throw $r("SubgraphService",r,`HTTP ${n.status}: ${e}`)}const o=await n.json();if(null!=o.errors&&o.errors.length>0)throw $r("SubgraphService",r,`GraphQL errors: ${o.errors.map(e=>e.message).join("; ")}`);return o.data}catch(e){if(e instanceof Error&&"SynapseError"===e.name)throw e;throw $r("SubgraphService",r,`Query execution failed: ${e.message}`,{cause:e})}}transformProviderData(e){return{owner:null!=e.address&&""!==e.address?e.address:e.id,pdpUrl:e.pdpUrl,pieceRetrievalUrl:e.pieceRetrievalUrl,registeredAt:this.parseTimestamp(e.registeredAt),approvedAt:this.parseTimestamp(e.approvedAt)}}parseTimestamp(e){if(null==e)return 0;const t=Number(e);return isNaN(t)?0:t}safeConvertHexToCid(e){try{const t=function(e){const t=e.match(/../g);return null!=t?new Uint8Array(t.map(e=>parseInt(e,16))):c}(e.startsWith("0x")?e.slice(2):e),r=Er(G.decode(t));if(null==r)throw new Error(`Failed to convert CID to CommP format: ${e}`);return r}catch(e){return console.warn(`SubgraphService: queryProviders: Failed to convert CID to CommP format: ${e instanceof Error?e.message:"Unknown error"}`),null}}isValidProviderData(e){return null!=e?.id&&""!==e.id.trim()&&null!=e?.pdpUrl&&""!==e.pdpUrl.trim()&&null!=e?.pieceRetrievalUrl&&""!==e.pieceRetrievalUrl.trim()}async getApprovedProvidersForCommP(e){const t=Er(e);if(null==t)throw $r("SubgraphService","getApprovedProvidersForCommP","Invalid CommP");const r=d(t.bytes),n=await this.executeQuery(hn,{cid:r},"getApprovedProvidersForCommP");if(null==n?.roots||0===n.roots.length)return console.log(`SubgraphService: No providers found for CommP: ${t.toString()}`),[];const o=n.roots.reduce((e,t)=>{const r=t.proofSet.owner,n=r?.address?.toLowerCase();return"Approved"!==r?.status||null==n||""===n||e.has(n)?e:this.isValidProviderData(r)?(e.set(n,r),e):(console.warn("SubgraphService: Skipping incomplete provider data for approved provider:",r),e)},new Map);return Array.from(o.values()).map(e=>this.transformProviderData(e))}async getProviderByAddress(e){const t=await this.executeQuery(fn,{providerId:e},"getProviderByAddress");return null==t?.provider?(console.log(`SubgraphService: No provider found for address: ${e}`),null):this.transformProviderData(t.provider)}async queryProviders(e={}){const t=await this.executeQuery(gn,this.normalizeQueryOptions(e),"queryProviders");return null==t?.providers||0===t?.providers?.length?(console.log("SubgraphService: No providers found for the given criteria"),[]):t.providers.filter(e=>this.isValidProviderData(e)).map(e=>this.transformProviderData(e))}async queryProofSets(e={}){const t=await this.executeQuery(wn,this.normalizeQueryOptions(e),"queryProofSets");return null==t?.proofSets||0===t?.proofSets?.length?(console.log("SubgraphService: No proof sets found for the given criteria"),[]):t.proofSets.map(e=>({id:e.id,setId:this.parseTimestamp(e.setId),listener:e.listener??"",clientAddr:e.clientAddr??"",withCDN:e.withCDN??!1,isActive:e.isActive,leafCount:this.parseTimestamp(e.leafCount),challengeRange:this.parseTimestamp(e.challengeRange),lastProvenEpoch:this.parseTimestamp(e.lastProvenEpoch),nextChallengeEpoch:this.parseTimestamp(e.nextChallengeEpoch),totalRoots:this.parseTimestamp(e.totalRoots),totalDataSize:this.parseTimestamp(e.totalDataSize),totalProofs:this.parseTimestamp(e.totalProofs),totalProvedRoots:this.parseTimestamp(e.totalProvedRoots),totalFaultedPeriods:this.parseTimestamp(e.totalFaultedPeriods),totalFaultedRoots:this.parseTimestamp(e.totalFaultedRoots),metadata:e.metadata??"",createdAt:this.parseTimestamp(e.createdAt),updatedAt:this.parseTimestamp(e.updatedAt),owner:null!=e.owner?this.transformProviderData(e.owner):{owner:"",pdpUrl:"",pieceRetrievalUrl:"",registeredAt:0,approvedAt:0},rail:null!=e.rail?{id:e.rail.id,railId:this.parseTimestamp(e.rail.railId),token:e.rail.token,paymentRate:this.parseTimestamp(e.rail.paymentRate),lockupPeriod:this.parseTimestamp(e.rail.lockupPeriod),settledUpto:this.parseTimestamp(e.rail.settledUpto),endEpoch:this.parseTimestamp(e.rail.endEpoch)}:void 0}))}async queryRoots(e={}){const t=await this.executeQuery(vn,this.normalizeQueryOptions(e),"queryRoots");return null==t?.roots||0===t?.roots?.length?(console.log("SubgraphService: No roots found for the given criteria"),[]):t.roots.map(e=>({id:e.id,setId:this.parseTimestamp(e.setId),rootId:this.parseTimestamp(e.rootId),rawSize:this.parseTimestamp(e.rawSize),leafCount:this.parseTimestamp(e.leafCount),cid:this.safeConvertHexToCid(e.cid),removed:e.removed,totalProofsSubmitted:this.parseTimestamp(e.totalProofsSubmitted),totalPeriodsFaulted:this.parseTimestamp(e.totalPeriodsFaulted),lastProvenEpoch:this.parseTimestamp(e.lastProvenEpoch),lastProvenAt:this.parseTimestamp(e.lastProvenAt),lastFaultedEpoch:this.parseTimestamp(e.lastFaultedEpoch),lastFaultedAt:this.parseTimestamp(e.lastFaultedAt),createdAt:this.parseTimestamp(e.createdAt),metadata:e.metadata??"",proofSet:{id:e.proofSet.id,setId:this.parseTimestamp(e.proofSet.setId),isActive:e.proofSet.isActive,owner:this.transformProviderData(e.proofSet.owner)}}))}async queryFaultRecords(e={}){const t=await this.executeQuery(yn,this.normalizeQueryOptions(e),"queryFaultRecords");return null==t?.faultRecords||0===t?.faultRecords?.length?(console.log("SubgraphService: No fault records found for the given criteria"),[]):t.faultRecords.map(e=>({id:e.id,proofSetId:this.parseTimestamp(e.proofSetId),rootIds:e.rootIds.map(e=>this.parseTimestamp(e)),currentChallengeEpoch:this.parseTimestamp(e.currentChallengeEpoch),nextChallengeEpoch:this.parseTimestamp(e.nextChallengeEpoch),periodsFaulted:this.parseTimestamp(e.periodsFaulted),deadline:this.parseTimestamp(e.deadline),createdAt:this.parseTimestamp(e.createdAt),proofSet:{id:e.proofSet.id,setId:this.parseTimestamp(e.proofSet.setId),owner:this.transformProviderData(e.proofSet.owner)}}))}}async function mn(e,t,r,n){const o=[],i=[],a=e.map(async(e,r)=>{const a=new AbortController;i[r]=a,null!=n&&(n.addEventListener("abort",()=>{a.abort(n.reason)},{once:!0}),n.aborted&&a.abort(n.reason));try{const n=Yr(e.pdpUrl,t),i=await fetch(n,{signal:a.signal});if(!i.ok)throw o.push({provider:e.owner,error:`findPiece returned ${i.status}`}),new Error("Provider does not have piece");const s=Qr(e.pieceRetrievalUrl,t),c=await fetch(s,{signal:a.signal});if(c.ok)return{response:c,index:r};throw o.push({provider:e.owner,error:`download returned ${c.status}`}),new Error(`Download failed with status ${c.status}`)}catch(t){const r=t.message??"Unknown error";throw o.some(t=>t.provider===e.owner)||o.push({provider:e.owner,error:r}),console.warn(`Failed to fetch from provider ${e.owner}:`,r),t}});try{const{response:e,index:t}=await Promise.any(a);return i.forEach((e,r)=>{r!==t&&e.abort()}),e}catch(e){if(e instanceof AggregateError){const e=o.map(e=>`${e.provider}: ${e.error}`).join("; ");throw $r(r,"fetchPiecesFromProviders",`All providers failed to serve piece ${t.toString()}. Details: ${e}`)}throw e}}class Pn{pandoraService;childRetriever;constructor(e,t){this.pandoraService=e,this.childRetriever=t}async findProviders(e,t){if(null!=t){const e=await this.pandoraService.getProviderIdByAddress(t);if(0===e)throw $r("ChainRetriever","findProviders",`Provider ${t} not found or not approved`);return[await this.pandoraService.getApprovedProvider(e)]}const r=(await this.pandoraService.getClientProofSetsWithDetails(e)).filter(e=>e.isLive&&e.currentRootCount>0);if(0===r.length)throw $r("ChainRetriever","findProviders",`No active proof sets with data found for client ${e}`);const n=[...new Set(r.map(e=>e.payee))];return await Promise.all(n.map(async e=>{const t=await this.pandoraService.getProviderIdByAddress(e);return await this.pandoraService.getApprovedProvider(t)}))}async fetchPiece(e,t,r){const n=async n=>{if(void 0!==this.childRetriever)return await this.childRetriever.fetchPiece(e,t,r);throw $r("ChainRetriever","fetchPiece",`Failed to retrieve piece ${e.toString()}: ${n}`)};let o=[];try{o=await this.findProviders(t,r?.providerAddress)}catch(e){return await n("Provider discovery failed and no additional retriever method was configured")}if(0===o.length)return await n("No providers found and no additional retriever method was configured");try{return await mn(o,e,"ChainRetriever",r?.signal)}catch(e){return await n("All provider retrieval attempts failed and no additional retriever method was configured")}}}class bn{baseRetriever;network;constructor(e,t){this.baseRetriever=e,this.network=t}hostname(){return"mainnet"===this.network?"filcdn.io":"calibration.filcdn.io"}async fetchPiece(e,t,r){if(!0===r?.withCDN){const n=`https://${t}.${this.hostname()}/${e.toString()}`;try{const e=await fetch(n,{signal:r?.signal});if(e.ok)return e;402===e.status?console.warn("CDN requires payment. Please initialise Synapse SDK with the option `withCDN: true` and re-upload your files."):console.warn("CDN fetch failed with status:",e.status)}catch(e){console.warn("CDN fetch failed:",e)}}return console.log("Falling back to direct retrieval"),await this.baseRetriever.fetchPiece(e,t,r)}}class An{subgraphService;childRetriever;constructor(e,t){this.subgraphService=e,this.childRetriever=t}async findProviders(e,t){if(null!=t){const e=await this.subgraphService.getProviderByAddress(t);return null!==e?[e]:[]}return await this.subgraphService.getApprovedProvidersForCommP(e)}async fetchPiece(e,t,r){const n=async n=>{if(void 0!==this.childRetriever)return await this.childRetriever.fetchPiece(e,t,r);throw $r("SubgraphRetriever","fetchPiece",`Failed to retrieve piece ${e.toString()}: ${n}`)};let o=[];try{o=await this.findProviders(e,r?.providerAddress)}catch(e){return await n("Provider discovery failed and no additional retriever method was configured")}if(0===o.length)return await n("No providers found and no additional retriever method was configured");try{return await mn(o,e,"SubgraphRetriever",r?.signal)}catch(e){return await n("All provider retrieval attempts failed and no additional retriever method was configured")}}}class Cn{_signer;_network;_withCDN;_payments;_provider;_pandoraAddress;_pdpVerifierAddress;_pandoraService;_pieceRetriever;static async create(t){if(1!==[t.privateKey,t.provider,t.signer].filter(Boolean).length)throw new Error("Must provide exactly one of: privateKey, provider, or signer");if(null!=t.privateKey&&null==t.rpcURL)throw new Error("rpcURL is required when using privateKey");let r,n,o;if(null!=t.privateKey&&null!=t.rpcURL){if(t.rpcURL.startsWith("ws://")||t.rpcURL.startsWith("wss://"))r=new e.WebSocketProvider(t.rpcURL);else if(null!=t.authorization){const n=new e.FetchRequest(t.rpcURL);n.setHeader("Authorization",t.authorization),r=new e.JsonRpcProvider(n)}else r=new e.JsonRpcProvider(t.rpcURL);const o=new e.Wallet(t.privateKey,r);n=!0!==t.disableNonceManager?new e.NonceManager(o):o}else if(null!=t.provider){if(r=t.provider,!("getSigner"in r)||"function"!=typeof r.getSigner)throw new Error("Provider must support getSigner() method");{const o=await r.getSigner();n=!0!==t.disableNonceManager?new e.NonceManager(o):o}}else{if(null==t.signer)throw new Error("Invalid configuration");if(n=t.signer,null==n.provider)throw new Error("Signer must have a provider attached");r=n.provider,!0!==t.disableNonceManager&&(n=new e.NonceManager(n))}try{const e=await r.getNetwork(),t=Number(e.chainId);if(t===xr.mainnet)o="mainnet";else{if(t!==xr.calibration)throw new Error(`Unsupported network with chain ID ${t}. Synapse SDK only supports Filecoin mainnet (${xr.mainnet}) and calibration (${xr.calibration}) networks.`);o="calibration"}}catch(e){throw new Error("Failed to detect network from provider. Please ensure your RPC endpoint is accessible and responds to network queries. "+(e instanceof Error?`Underlying error: ${e.message}`:""))}const i=t.pandoraAddress??Vr.PANDORA_SERVICE[o],a=t.pdpVerifierAddress??Vr.PDP_VERIFIER[o],s=new pn(r,i,a);let c;if(null!=t.pieceRetriever)c=t.pieceRetriever;else{const e=new Pn(s);let r=e;if(null!=t.subgraphService||null!=t.subgraphConfig)try{let n;if(null!=t.subgraphService)n=t.subgraphService;else{if(null==t.subgraphConfig)throw new Error("Invalid subgraph configuration: neither service nor config provided");n=new Sn(t.subgraphConfig)}r=new An(n,e)}catch(e){throw new Error(`Failed to initialize subgraph piece retriever: ${e instanceof Error?e.message:String(e)}`)}c=new bn(r,o)}return new Cn(r,n,o,!0===t.disableNonceManager,!0===t.withCDN,t.pandoraAddress,t.pdpVerifierAddress,s,c)}constructor(e,t,r,n,o,i,a,s,c){if(this._provider=e,this._signer=t,this._network=r,this._withCDN=o,this._payments=new ln(e,t,r,n),this._pandoraService=s,this._pieceRetriever=c,this._pandoraAddress=i??Vr.PANDORA_SERVICE[r],""===this._pandoraAddress||void 0===this._pandoraAddress)throw new Error(`No Pandora service address configured for network: ${r}`);if(this._pdpVerifierAddress=a??Vr.PDP_VERIFIER[r],""===this._pdpVerifierAddress||void 0===this._pdpVerifierAddress)throw new Error(`No PDPVerifier contract address configured for network: ${r}`)}get payments(){return this._payments}getProvider(){return this._provider}getSigner(){return this._signer}getChainId(){return BigInt(xr[this._network])}getPandoraAddress(){return this._pandoraAddress}getPDPVerifierAddress(){return this._pdpVerifierAddress}async createStorage(e){try{const t={...e,withCDN:e?.withCDN??this._withCDN};return await dn.create(this,this._pandoraService,t)}catch(e){throw $r("Synapse","createStorage","Failed to create storage service",e)}}getNetwork(){return this._network}async getProviderInfo(t){try{if(!e.isAddress(t))throw new Error(`Invalid provider address: ${String(t)}`);const r=await this._pandoraService.getProviderIdByAddress(t);if(0===r)throw new Error(`Provider ${t} is not approved`);const n=await this._pandoraService.getApprovedProvider(r);if(n.owner===e.ZeroAddress)throw new Error(`Provider ${t} not found`);return n}catch(e){throw $r("Synapse","getProviderInfo",`Failed to get provider info for ${t}`,e)}}async download(e,t){const r=Er(e);if(null==r)throw $r("Synapse","download",`Invalid CommP: ${String(e)}`);const n=await this._signer.getAddress(),o=await this._pieceRetriever.fetchPiece(r,n,{withCDN:t?.withCDN??this._withCDN,providerAddress:t?.providerAddress});return await Tr(o,r)}async getStorageInfo(){try{const t=async()=>{try{const e=await this._payments.serviceApproval(this._pandoraAddress,kr.USDFC);return{service:this._pandoraAddress,rateAllowance:e.rateAllowance,lockupAllowance:e.lockupAllowance,rateUsed:e.rateUsed,lockupUsed:e.lockupUsed}}catch(e){return null}},[r,n,o]=await Promise.all([this._pandoraService.getServicePrice(),this._pandoraService.getAllApprovedProviders(),t()]),i=BigInt(r.epochsPerMonth),a=Mr.EPOCHS_PER_DAY,s=BigInt(r.pricePerTiBPerMonthNoCDN)/i,c=BigInt(r.pricePerTiBPerMonthWithCDN)/i,d=BigInt(r.pricePerTiBPerMonthNoCDN)/Mr.DAYS_PER_MONTH,l=BigInt(r.pricePerTiBPerMonthWithCDN)/Mr.DAYS_PER_MONTH,u=n.filter(t=>t.owner!==e.ZeroAddress);return{pricing:{noCDN:{perTiBPerMonth:BigInt(r.pricePerTiBPerMonthNoCDN),perTiBPerDay:d,perTiBPerEpoch:s},withCDN:{perTiBPerMonth:BigInt(r.pricePerTiBPerMonthWithCDN),perTiBPerDay:l,perTiBPerEpoch:c},tokenAddress:r.tokenAddress,tokenSymbol:"USDFC"},providers:u,serviceParameters:{network:this._network,epochsPerMonth:i,epochsPerDay:a,epochDuration:Mr.EPOCH_DURATION,minUploadSize:Fr.MIN_UPLOAD_SIZE,maxUploadSize:Fr.MAX_UPLOAD_SIZE,pandoraAddress:this._pandoraAddress,paymentsAddress:Vr.PAYMENTS[this._network],pdpVerifierAddress:this._pdpVerifierAddress},allowances:o}}catch(e){throw $r("Synapse","getStorageInfo","Failed to get storage service information",e)}}}const In={...s,...i,...a};export{In as default};