import { ethers } from 'ethers';
import { StorageService } from './storage/index.js';
import { PaymentsService } from './payments/index.js';
import { PandoraService } from './pandora/index.js';
import { SubgraphService } from './subgraph/service.js';
import { ChainRetriever, FilCdnRetriever, SubgraphRetriever } from './retriever/index.js';
import { asCommP, downloadAndValidateCommP } from './commp/index.js';
import { CHAIN_IDS, CONTRACT_ADDRESSES, SIZE_CONSTANTS, TIME_CONSTANTS, TOKENS, createError } from './utils/index.js';
export class Synapse {
    _signer;
    _network;
    _withCDN;
    _payments;
    _provider;
    _pandoraAddress;
    _pdpVerifierAddress;
    _pandoraService;
    _pieceRetriever;
    static async create(options) {
        const providedOptions = [options.privateKey, options.provider, options.signer].filter(Boolean).length;
        if (providedOptions !== 1) {
            throw new Error('Must provide exactly one of: privateKey, provider, or signer');
        }
        if (options.privateKey != null && options.rpcURL == null) {
            throw new Error('rpcURL is required when using privateKey');
        }
        let provider;
        let signer;
        if (options.privateKey != null && options.rpcURL != null) {
            if (options.rpcURL.startsWith('ws://') || options.rpcURL.startsWith('wss://')) {
                provider = new ethers.WebSocketProvider(options.rpcURL);
            }
            else {
                if (options.authorization != null) {
                    const fetchRequest = new ethers.FetchRequest(options.rpcURL);
                    fetchRequest.setHeader('Authorization', options.authorization);
                    provider = new ethers.JsonRpcProvider(fetchRequest);
                }
                else {
                    provider = new ethers.JsonRpcProvider(options.rpcURL);
                }
            }
            const wallet = new ethers.Wallet(options.privateKey, provider);
            if (options.disableNonceManager !== true) {
                signer = new ethers.NonceManager(wallet);
            }
            else {
                signer = wallet;
            }
        }
        else if (options.provider != null) {
            provider = options.provider;
            if ('getSigner' in provider && typeof provider.getSigner === 'function') {
                const providerSigner = await provider.getSigner();
                if (options.disableNonceManager !== true) {
                    signer = new ethers.NonceManager(providerSigner);
                }
                else {
                    signer = providerSigner;
                }
            }
            else {
                throw new Error('Provider must support getSigner() method');
            }
        }
        else if (options.signer != null) {
            signer = options.signer;
            if (signer.provider != null) {
                provider = signer.provider;
            }
            else {
                throw new Error('Signer must have a provider attached');
            }
            if (options.disableNonceManager !== true) {
                signer = new ethers.NonceManager(signer);
            }
        }
        else {
            throw new Error('Invalid configuration');
        }
        let network;
        try {
            const ethersNetwork = await provider.getNetwork();
            const chainId = Number(ethersNetwork.chainId);
            if (chainId === CHAIN_IDS.mainnet) {
                network = 'mainnet';
            }
            else if (chainId === CHAIN_IDS.calibration) {
                network = 'calibration';
            }
            else {
                throw new Error(`Unsupported network with chain ID ${chainId}. Synapse SDK only supports Filecoin mainnet (${CHAIN_IDS.mainnet}) and calibration (${CHAIN_IDS.calibration}) networks.`);
            }
        }
        catch (error) {
            throw new Error(`Failed to detect network from provider. Please ensure your RPC endpoint is accessible and responds to network queries. ${error instanceof Error ? `Underlying error: ${error.message}` : ''}`);
        }
        const pandoraAddress = options.pandoraAddress ?? CONTRACT_ADDRESSES.PANDORA_SERVICE[network];
        const pdpVerifierAddress = options.pdpVerifierAddress ?? CONTRACT_ADDRESSES.PDP_VERIFIER[network];
        const pandoraService = new PandoraService(provider, pandoraAddress, pdpVerifierAddress);
        let pieceRetriever;
        if (options.pieceRetriever != null) {
            pieceRetriever = options.pieceRetriever;
        }
        else {
            const chainRetriever = new ChainRetriever(pandoraService);
            let underlyingRetriever = chainRetriever;
            if (options.subgraphService != null || options.subgraphConfig != null) {
                try {
                    let subgraphService;
                    if (options.subgraphService != null) {
                        subgraphService = options.subgraphService;
                    }
                    else if (options.subgraphConfig != null) {
                        subgraphService = new SubgraphService(options.subgraphConfig);
                    }
                    else {
                        throw new Error('Invalid subgraph configuration: neither service nor config provided');
                    }
                    underlyingRetriever = new SubgraphRetriever(subgraphService, chainRetriever);
                }
                catch (error) {
                    throw new Error(`Failed to initialize subgraph piece retriever: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            pieceRetriever = new FilCdnRetriever(underlyingRetriever, network);
        }
        return new Synapse(provider, signer, network, options.disableNonceManager === true, options.withCDN === true, options.pandoraAddress, options.pdpVerifierAddress, pandoraService, pieceRetriever);
    }
    constructor(provider, signer, network, disableNonceManager, withCDN, pandoraAddressOverride, pdpVerifierAddressOverride, pandoraService, pieceRetriever) {
        this._provider = provider;
        this._signer = signer;
        this._network = network;
        this._withCDN = withCDN;
        this._payments = new PaymentsService(provider, signer, network, disableNonceManager);
        this._pandoraService = pandoraService;
        this._pieceRetriever = pieceRetriever;
        this._pandoraAddress = pandoraAddressOverride ?? CONTRACT_ADDRESSES.PANDORA_SERVICE[network];
        if (this._pandoraAddress === '' || this._pandoraAddress === undefined) {
            throw new Error(`No Pandora service address configured for network: ${network}`);
        }
        this._pdpVerifierAddress = pdpVerifierAddressOverride ?? CONTRACT_ADDRESSES.PDP_VERIFIER[network];
        if (this._pdpVerifierAddress === '' || this._pdpVerifierAddress === undefined) {
            throw new Error(`No PDPVerifier contract address configured for network: ${network}`);
        }
    }
    get payments() {
        return this._payments;
    }
    getProvider() {
        return this._provider;
    }
    getSigner() {
        return this._signer;
    }
    getChainId() {
        return BigInt(CHAIN_IDS[this._network]);
    }
    getPandoraAddress() {
        return this._pandoraAddress;
    }
    getPDPVerifierAddress() {
        return this._pdpVerifierAddress;
    }
    async createStorage(options) {
        try {
            const mergedOptions = {
                ...options,
                withCDN: options?.withCDN ?? this._withCDN
            };
            const storageService = await StorageService.create(this, this._pandoraService, mergedOptions);
            return storageService;
        }
        catch (error) {
            throw createError('Synapse', 'createStorage', 'Failed to create storage service', error);
        }
    }
    getNetwork() {
        return this._network;
    }
    async getProviderInfo(providerAddress) {
        try {
            if (!ethers.isAddress(providerAddress)) {
                throw new Error(`Invalid provider address: ${String(providerAddress)}`);
            }
            const providerId = await this._pandoraService.getProviderIdByAddress(providerAddress);
            if (providerId === 0) {
                throw new Error(`Provider ${providerAddress} is not approved`);
            }
            const providerInfo = await this._pandoraService.getApprovedProvider(providerId);
            if (providerInfo.owner === ethers.ZeroAddress) {
                throw new Error(`Provider ${providerAddress} not found`);
            }
            return providerInfo;
        }
        catch (error) {
            throw createError('Synapse', 'getProviderInfo', `Failed to get provider info for ${providerAddress}`, error);
        }
    }
    async download(commp, options) {
        const parsedCommP = asCommP(commp);
        if (parsedCommP == null) {
            throw createError('Synapse', 'download', `Invalid CommP: ${String(commp)}`);
        }
        const client = await this._signer.getAddress();
        const response = await this._pieceRetriever.fetchPiece(parsedCommP, client, {
            withCDN: options?.withCDN ?? this._withCDN,
            providerAddress: options?.providerAddress
        });
        return await downloadAndValidateCommP(response, parsedCommP);
    }
    async getStorageInfo() {
        try {
            const getOptionalAllowances = async () => {
                try {
                    const approval = await this._payments.serviceApproval(this._pandoraAddress, TOKENS.USDFC);
                    return {
                        service: this._pandoraAddress,
                        rateAllowance: approval.rateAllowance,
                        lockupAllowance: approval.lockupAllowance,
                        rateUsed: approval.rateUsed,
                        lockupUsed: approval.lockupUsed
                    };
                }
                catch (error) {
                    return null;
                }
            };
            const [pricingData, providers, allowances] = await Promise.all([
                this._pandoraService.getServicePrice(),
                this._pandoraService.getAllApprovedProviders(),
                getOptionalAllowances()
            ]);
            const epochsPerMonth = BigInt(pricingData.epochsPerMonth);
            const epochsPerDay = TIME_CONSTANTS.EPOCHS_PER_DAY;
            const noCDNPerEpoch = BigInt(pricingData.pricePerTiBPerMonthNoCDN) / epochsPerMonth;
            const withCDNPerEpoch = BigInt(pricingData.pricePerTiBPerMonthWithCDN) / epochsPerMonth;
            const noCDNPerDay = BigInt(pricingData.pricePerTiBPerMonthNoCDN) / TIME_CONSTANTS.DAYS_PER_MONTH;
            const withCDNPerDay = BigInt(pricingData.pricePerTiBPerMonthWithCDN) / TIME_CONSTANTS.DAYS_PER_MONTH;
            const validProviders = providers.filter((p) => p.owner !== ethers.ZeroAddress);
            return {
                pricing: {
                    noCDN: {
                        perTiBPerMonth: BigInt(pricingData.pricePerTiBPerMonthNoCDN),
                        perTiBPerDay: noCDNPerDay,
                        perTiBPerEpoch: noCDNPerEpoch
                    },
                    withCDN: {
                        perTiBPerMonth: BigInt(pricingData.pricePerTiBPerMonthWithCDN),
                        perTiBPerDay: withCDNPerDay,
                        perTiBPerEpoch: withCDNPerEpoch
                    },
                    tokenAddress: pricingData.tokenAddress,
                    tokenSymbol: 'USDFC'
                },
                providers: validProviders,
                serviceParameters: {
                    network: this._network,
                    epochsPerMonth,
                    epochsPerDay,
                    epochDuration: TIME_CONSTANTS.EPOCH_DURATION,
                    minUploadSize: SIZE_CONSTANTS.MIN_UPLOAD_SIZE,
                    maxUploadSize: SIZE_CONSTANTS.MAX_UPLOAD_SIZE,
                    pandoraAddress: this._pandoraAddress,
                    paymentsAddress: CONTRACT_ADDRESSES.PAYMENTS[this._network],
                    pdpVerifierAddress: this._pdpVerifierAddress
                },
                allowances
            };
        }
        catch (error) {
            throw createError('Synapse', 'getStorageInfo', 'Failed to get storage service information', error);
        }
    }
}
export { Synapse as default };
//# sourceMappingURL=synapse.js.map