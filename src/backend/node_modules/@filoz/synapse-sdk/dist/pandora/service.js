import { ethers } from 'ethers';
import { CONTRACT_ABIS, TOKENS } from '../utils/index.js';
import { PDPVerifier } from '../pdp/verifier.js';
import { SIZE_CONSTANTS, TIME_CONSTANTS, TIMING_CONSTANTS } from '../utils/constants.js';
export class PandoraService {
    _provider;
    _pandoraAddress;
    _pdpVerifierAddress;
    _pandoraContract = null;
    _pdpVerifier = null;
    constructor(provider, pandoraAddress, pdpVerifierAddress) {
        this._provider = provider;
        this._pandoraAddress = pandoraAddress;
        this._pdpVerifierAddress = pdpVerifierAddress;
    }
    _getPandoraContract() {
        if (this._pandoraContract == null) {
            this._pandoraContract = new ethers.Contract(this._pandoraAddress, CONTRACT_ABIS.PANDORA_SERVICE, this._provider);
        }
        return this._pandoraContract;
    }
    _getPDPVerifier() {
        if (this._pdpVerifier == null) {
            this._pdpVerifier = new PDPVerifier(this._provider, this._pdpVerifierAddress);
        }
        return this._pdpVerifier;
    }
    async getClientProofSets(clientAddress) {
        const pandoraContract = this._getPandoraContract();
        try {
            const proofSetsData = await pandoraContract.getClientProofSets(clientAddress);
            const proofSets = [];
            for (let i = 0; i < proofSetsData.length; i++) {
                const data = proofSetsData[i];
                if (data.payer === '0x0000000000000000000000000000000000000000' || Number(data.railId) === 0) {
                    continue;
                }
                proofSets.push({
                    railId: Number(data.railId),
                    payer: data.payer,
                    payee: data.payee,
                    commissionBps: Number(data.commissionBps),
                    metadata: data.metadata,
                    rootMetadata: data.rootMetadata,
                    clientDataSetId: Number(data.clientDataSetId),
                    withCDN: data.withCDN
                });
            }
            return proofSets;
        }
        catch (error) {
            throw new Error(`Failed to get client proof sets: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async getClientProofSetsWithDetails(clientAddress, onlyManaged = false) {
        const proofSets = await this.getClientProofSets(clientAddress);
        const pdpVerifier = this._getPDPVerifier();
        const pandoraContract = this._getPandoraContract();
        const enhancedProofSetsPromises = proofSets.map(async (proofSet) => {
            try {
                const pdpVerifierProofSetId = await pandoraContract.railToProofSet(proofSet.railId);
                if (Number(pdpVerifierProofSetId) === 0) {
                    return onlyManaged
                        ? null
                        : {
                            ...proofSet,
                            pdpVerifierProofSetId: 0,
                            nextRootId: 0,
                            currentRootCount: 0,
                            isLive: false,
                            isManaged: false
                        };
                }
                const [isLive, listenerResult] = await Promise.all([
                    pdpVerifier.proofSetLive(Number(pdpVerifierProofSetId)),
                    pdpVerifier.getProofSetListener(Number(pdpVerifierProofSetId)).catch(() => null)
                ]);
                const isManaged = listenerResult != null && listenerResult.toLowerCase() === this._pandoraAddress.toLowerCase();
                if (onlyManaged && !isManaged) {
                    return null;
                }
                const nextRootId = isLive ? await pdpVerifier.getNextRootId(Number(pdpVerifierProofSetId)) : 0;
                return {
                    ...proofSet,
                    pdpVerifierProofSetId: Number(pdpVerifierProofSetId),
                    nextRootId: Number(nextRootId),
                    currentRootCount: Number(nextRootId),
                    isLive,
                    isManaged
                };
            }
            catch (error) {
                throw new Error(`Failed to get details for proof set with rail ID ${proofSet.railId}: ${error instanceof Error ? error.message : String(error)}`);
            }
        });
        const results = await Promise.all(enhancedProofSetsPromises);
        return results.filter((result) => result !== null);
    }
    async getAddRootsInfo(proofSetId) {
        try {
            const pandoraContract = this._getPandoraContract();
            const pdpVerifier = this._getPDPVerifier();
            const [isLive, nextRootId, listener, proofSetInfo] = await Promise.all([
                pdpVerifier.proofSetLive(Number(proofSetId)),
                pdpVerifier.getNextRootId(Number(proofSetId)),
                pdpVerifier.getProofSetListener(Number(proofSetId)),
                pandoraContract.getProofSet(Number(proofSetId))
            ]);
            if (!isLive) {
                throw new Error(`Proof set ${proofSetId} does not exist or is not live`);
            }
            if (listener.toLowerCase() !== this._pandoraAddress.toLowerCase()) {
                throw new Error(`Proof set ${proofSetId} is not managed by this Pandora contract (${this._pandoraAddress}), managed by ${String(listener)}`);
            }
            const clientDataSetId = Number(proofSetInfo.clientDataSetId);
            return {
                nextRootId: Number(nextRootId),
                clientDataSetId,
                currentRootCount: Number(nextRootId)
            };
        }
        catch (error) {
            throw new Error(`Failed to get add roots info: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async getNextClientDataSetId(clientAddress) {
        try {
            const pandoraContract = this._getPandoraContract();
            const currentCounter = await pandoraContract.clientDataSetIDs(clientAddress);
            return Number(currentCounter);
        }
        catch (error) {
            throw new Error(`Failed to get next client dataset ID: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async verifyProofSetCreation(txHashOrTransaction) {
        try {
            const txHash = typeof txHashOrTransaction === 'string' ? txHashOrTransaction : txHashOrTransaction.hash;
            let receipt;
            if (typeof txHashOrTransaction === 'string') {
                receipt = await this._provider.getTransactionReceipt(txHash);
            }
            else {
                receipt = await txHashOrTransaction.wait(TIMING_CONSTANTS.TRANSACTION_CONFIRMATIONS);
            }
            if (receipt == null) {
                return {
                    transactionMined: false,
                    transactionSuccess: false,
                    proofSetLive: false
                };
            }
            const transactionSuccess = receipt.status === 1;
            if (!transactionSuccess) {
                return {
                    transactionMined: true,
                    transactionSuccess: false,
                    proofSetLive: false,
                    blockNumber: receipt.blockNumber,
                    gasUsed: receipt.gasUsed,
                    error: 'Transaction failed'
                };
            }
            const pdpVerifier = this._getPDPVerifier();
            const proofSetId = await pdpVerifier.extractProofSetIdFromReceipt(receipt);
            if (proofSetId == null) {
                return {
                    transactionMined: true,
                    transactionSuccess: true,
                    proofSetLive: false,
                    blockNumber: receipt.blockNumber,
                    gasUsed: receipt.gasUsed,
                    error: 'Could not find ProofSetCreated event in transaction'
                };
            }
            const isLive = await pdpVerifier.proofSetLive(proofSetId);
            return {
                transactionMined: true,
                transactionSuccess: true,
                proofSetId,
                proofSetLive: isLive,
                blockNumber: receipt.blockNumber,
                gasUsed: receipt.gasUsed
            };
        }
        catch (error) {
            return {
                transactionMined: false,
                transactionSuccess: false,
                proofSetLive: false,
                error: `Verification failed: ${error instanceof Error ? error.message : String(error)}`
            };
        }
    }
    async getComprehensiveProofSetStatus(txHashOrTransaction, pdpServer) {
        const txHash = typeof txHashOrTransaction === 'string' ? txHashOrTransaction : txHashOrTransaction.hash;
        let serverStatus = null;
        try {
            serverStatus = await pdpServer.getProofSetCreationStatus(txHash);
        }
        catch (error) {
        }
        const chainStatus = await this.verifyProofSetCreation(txHashOrTransaction);
        const summary = {
            isComplete: chainStatus.transactionMined && chainStatus.proofSetLive && serverStatus != null && serverStatus.ok === true,
            isLive: chainStatus.proofSetLive,
            proofSetId: chainStatus.proofSetId ?? serverStatus?.proofSetId ?? null,
            error: chainStatus.error ?? null
        };
        return {
            txHash,
            serverStatus,
            chainStatus,
            summary
        };
    }
    async waitForProofSetCreationWithStatus(txHashOrTransaction, pdpServer, timeoutMs = TIMING_CONSTANTS.PROOF_SET_CREATION_TIMEOUT_MS, pollIntervalMs = TIMING_CONSTANTS.PROOF_SET_CREATION_POLL_INTERVAL_MS, onProgress) {
        const startTime = Date.now();
        while (Date.now() - startTime < timeoutMs) {
            const status = await this.getComprehensiveProofSetStatus(txHashOrTransaction, pdpServer);
            if (onProgress != null) {
                try {
                    await onProgress(status, Date.now() - startTime);
                }
                catch (error) {
                    console.error('Error in progress callback:', error);
                }
            }
            if (status.summary.isComplete || status.summary.error != null) {
                return status;
            }
            await new Promise(resolve => setTimeout(resolve, pollIntervalMs));
        }
        throw new Error(`Timeout waiting for proof set creation after ${timeoutMs}ms`);
    }
    async calculateStorageCost(sizeInBytes) {
        const pandoraContract = this._getPandoraContract();
        let pricePerTiBPerMonthNoCDN;
        let pricePerTiBPerMonthWithCDN;
        let epochsPerMonth;
        try {
            const result = await pandoraContract.getServicePrice();
            pricePerTiBPerMonthNoCDN = BigInt(result.pricePerTiBPerMonthNoCDN);
            pricePerTiBPerMonthWithCDN = BigInt(result.pricePerTiBPerMonthWithCDN);
            epochsPerMonth = BigInt(result.epochsPerMonth);
        }
        catch (error) {
            console.error('Error calling getServicePrice:', error);
            throw error;
        }
        const sizeInBytesBigint = BigInt(sizeInBytes);
        const pricePerEpochNoCDN = (pricePerTiBPerMonthNoCDN * sizeInBytesBigint) / (SIZE_CONSTANTS.TiB * epochsPerMonth);
        const pricePerEpochWithCDN = (pricePerTiBPerMonthWithCDN * sizeInBytesBigint) / (SIZE_CONSTANTS.TiB * epochsPerMonth);
        return {
            perEpoch: pricePerEpochNoCDN,
            perDay: pricePerEpochNoCDN * TIME_CONSTANTS.EPOCHS_PER_DAY,
            perMonth: pricePerEpochNoCDN * epochsPerMonth,
            withCDN: {
                perEpoch: pricePerEpochWithCDN,
                perDay: pricePerEpochWithCDN * TIME_CONSTANTS.EPOCHS_PER_DAY,
                perMonth: pricePerEpochWithCDN * epochsPerMonth
            }
        };
    }
    async checkAllowanceForStorage(sizeInBytes, withCDN, paymentsService, lockupDays) {
        const approval = await paymentsService.serviceApproval(this._pandoraAddress, TOKENS.USDFC);
        const costs = await this.calculateStorageCost(sizeInBytes);
        const selectedCosts = withCDN ? costs.withCDN : costs;
        const rateNeeded = selectedCosts.perEpoch;
        const lockupPeriod = BigInt(lockupDays ?? TIME_CONSTANTS.DEFAULT_LOCKUP_DAYS) * TIME_CONSTANTS.EPOCHS_PER_DAY;
        const lockupNeeded = rateNeeded * lockupPeriod;
        const totalRateNeeded = BigInt(approval.rateUsed) + rateNeeded;
        const totalLockupNeeded = BigInt(approval.lockupUsed) + lockupNeeded;
        const sufficient = approval.rateAllowance >= totalRateNeeded &&
            approval.lockupAllowance >= totalLockupNeeded;
        let message;
        if (!sufficient) {
            const messages = [];
            if (approval.rateAllowance < totalRateNeeded) {
                messages.push(`Rate allowance insufficient: current ${String(approval.rateAllowance)}, need ${String(totalRateNeeded)}`);
            }
            if (approval.lockupAllowance < totalLockupNeeded) {
                messages.push(`Lockup allowance insufficient: current ${String(approval.lockupAllowance)}, need ${String(totalLockupNeeded)}`);
            }
            message = messages.join('. ');
        }
        return {
            rateAllowanceNeeded: totalRateNeeded,
            lockupAllowanceNeeded: totalLockupNeeded,
            currentRateAllowance: approval.rateAllowance,
            currentLockupAllowance: approval.lockupAllowance,
            currentRateUsed: approval.rateUsed,
            currentLockupUsed: approval.lockupUsed,
            sufficient,
            message,
            costs: {
                perEpoch: selectedCosts.perEpoch,
                perDay: selectedCosts.perDay,
                perMonth: selectedCosts.perMonth
            },
            depositAmountNeeded: lockupNeeded
        };
    }
    async prepareStorageUpload(options, paymentsService) {
        const costs = await this.calculateStorageCost(options.dataSize);
        const estimatedCost = (options.withCDN === true) ? costs.withCDN : costs;
        const allowanceCheck = await this.checkAllowanceForStorage(options.dataSize, options.withCDN ?? false, paymentsService);
        const actions = [];
        const accountInfo = await paymentsService.accountInfo(TOKENS.USDFC);
        const requiredBalance = estimatedCost.perMonth;
        if (accountInfo.availableFunds < requiredBalance) {
            const depositAmount = requiredBalance - accountInfo.availableFunds;
            actions.push({
                type: 'deposit',
                description: `Deposit ${depositAmount} USDFC to payments contract`,
                execute: async () => await paymentsService.deposit(depositAmount, TOKENS.USDFC)
            });
        }
        if (!allowanceCheck.sufficient) {
            actions.push({
                type: 'approveService',
                description: `Approve service with rate allowance ${allowanceCheck.rateAllowanceNeeded} and lockup allowance ${allowanceCheck.lockupAllowanceNeeded}`,
                execute: async () => await paymentsService.approveService(this._pandoraAddress, allowanceCheck.rateAllowanceNeeded, allowanceCheck.lockupAllowanceNeeded, TOKENS.USDFC)
            });
        }
        return {
            estimatedCost: {
                perEpoch: estimatedCost.perEpoch,
                perDay: estimatedCost.perDay,
                perMonth: estimatedCost.perMonth
            },
            allowanceCheck: {
                sufficient: allowanceCheck.sufficient,
                message: allowanceCheck.message
            },
            actions
        };
    }
    async registerServiceProvider(signer, pdpUrl, pieceRetrievalUrl) {
        const contract = this._getPandoraContract().connect(signer);
        return await contract.registerServiceProvider(pdpUrl, pieceRetrievalUrl);
    }
    async approveServiceProvider(signer, providerAddress) {
        const contract = this._getPandoraContract().connect(signer);
        return await contract.approveServiceProvider(providerAddress);
    }
    async rejectServiceProvider(signer, providerAddress) {
        const contract = this._getPandoraContract().connect(signer);
        return await contract.rejectServiceProvider(providerAddress);
    }
    async removeServiceProvider(signer, providerId) {
        const contract = this._getPandoraContract().connect(signer);
        return await contract.removeServiceProvider(providerId);
    }
    async addServiceProvider(signer, providerAddress, pdpUrl, pieceRetrievalUrl) {
        const contract = this._getPandoraContract().connect(signer);
        return await contract.addServiceProvider(providerAddress, pdpUrl, pieceRetrievalUrl);
    }
    async isProviderApproved(providerAddress) {
        const contract = this._getPandoraContract();
        return await contract.isProviderApproved(providerAddress);
    }
    async getProviderIdByAddress(providerAddress) {
        const contract = this._getPandoraContract();
        const id = await contract.getProviderIdByAddress(providerAddress);
        return Number(id);
    }
    async getApprovedProvider(providerId) {
        const contract = this._getPandoraContract();
        const info = await contract.getApprovedProvider(providerId);
        return {
            owner: info.owner,
            pdpUrl: info.pdpUrl,
            pieceRetrievalUrl: info.pieceRetrievalUrl,
            registeredAt: Number(info.registeredAt),
            approvedAt: Number(info.approvedAt)
        };
    }
    async getPendingProvider(providerAddress) {
        const contract = this._getPandoraContract();
        const info = await contract.pendingProviders(providerAddress);
        return {
            pdpUrl: info.pdpUrl,
            pieceRetrievalUrl: info.pieceRetrievalUrl,
            registeredAt: Number(info.registeredAt)
        };
    }
    async getNextProviderId() {
        const contract = this._getPandoraContract();
        const id = await contract.nextServiceProviderId();
        return Number(id);
    }
    async getOwner() {
        const contract = this._getPandoraContract();
        return await contract.owner();
    }
    async isOwner(signer) {
        const signerAddress = await signer.getAddress();
        const ownerAddress = await this.getOwner();
        return signerAddress.toLowerCase() === ownerAddress.toLowerCase();
    }
    async getAllApprovedProviders() {
        const contract = this._getPandoraContract();
        const providers = await contract.getAllApprovedProviders();
        return providers.map((p) => ({
            owner: p.owner,
            pdpUrl: p.pdpUrl,
            pieceRetrievalUrl: p.pieceRetrievalUrl,
            registeredAt: Number(p.registeredAt),
            approvedAt: Number(p.approvedAt)
        }));
    }
    async getServicePrice() {
        const contract = this._getPandoraContract();
        const result = await contract.getServicePrice();
        return {
            pricePerTiBPerMonthNoCDN: result.pricePerTiBPerMonthNoCDN,
            pricePerTiBPerMonthWithCDN: result.pricePerTiBPerMonthWithCDN,
            tokenAddress: result.tokenAddress,
            epochsPerMonth: result.epochsPerMonth
        };
    }
    async getMaxProvingPeriod() {
        const contract = this._getPandoraContract();
        const maxProvingPeriod = await contract.getMaxProvingPeriod();
        return Number(maxProvingPeriod);
    }
    async getChallengeWindow() {
        const contract = this._getPandoraContract();
        const challengeWindow = await contract.challengeWindow();
        return Number(challengeWindow);
    }
    async getProvingPeriodInHours() {
        const maxProvingPeriod = await this.getMaxProvingPeriod();
        return (maxProvingPeriod * 30) / 3600;
    }
    async getChallengeWindowInMinutes() {
        const challengeWindow = await this.getChallengeWindow();
        return (challengeWindow * 30) / 60;
    }
    async getProvingPeriodInfo() {
        const [maxProvingPeriod, challengeWindow] = await Promise.all([
            this.getMaxProvingPeriod(),
            this.getChallengeWindow()
        ]);
        return {
            maxProvingPeriodEpochs: maxProvingPeriod,
            challengeWindowEpochs: challengeWindow,
            maxProvingPeriodHours: (maxProvingPeriod * 30) / 3600,
            challengeWindowMinutes: (challengeWindow * 30) / 60,
            epochDurationSeconds: 30
        };
    }
}
//# sourceMappingURL=service.js.map