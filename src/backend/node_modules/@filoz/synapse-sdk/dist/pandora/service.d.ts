import { ethers } from 'ethers';
import type { ProofSetInfo, EnhancedProofSetInfo, ApprovedProviderInfo } from '../types.js';
import type { PDPServer, ProofSetCreationStatusResponse } from '../pdp/server.js';
import { PaymentsService } from '../payments/service.js';
export interface AddRootsInfo {
    nextRootId: number;
    clientDataSetId: number;
    currentRootCount: number;
}
export interface ProofSetCreationVerification {
    transactionMined: boolean;
    transactionSuccess: boolean;
    proofSetId?: number;
    proofSetLive: boolean;
    blockNumber?: number;
    gasUsed?: bigint;
    error?: string;
}
export interface PendingProviderInfo {
    pdpUrl: string;
    pieceRetrievalUrl: string;
    registeredAt: number;
}
export interface ComprehensiveProofSetStatus {
    txHash: string;
    serverStatus: ProofSetCreationStatusResponse | null;
    chainStatus: ProofSetCreationVerification;
    summary: {
        isComplete: boolean;
        isLive: boolean;
        proofSetId: number | null;
        error: string | null;
    };
}
export declare class PandoraService {
    private readonly _provider;
    private readonly _pandoraAddress;
    private readonly _pdpVerifierAddress;
    private _pandoraContract;
    private _pdpVerifier;
    constructor(provider: ethers.Provider, pandoraAddress: string, pdpVerifierAddress: string);
    private _getPandoraContract;
    private _getPDPVerifier;
    getClientProofSets(clientAddress: string): Promise<ProofSetInfo[]>;
    getClientProofSetsWithDetails(clientAddress: string, onlyManaged?: boolean): Promise<EnhancedProofSetInfo[]>;
    getAddRootsInfo(proofSetId: number): Promise<AddRootsInfo>;
    getNextClientDataSetId(clientAddress: string): Promise<number>;
    verifyProofSetCreation(txHashOrTransaction: string | ethers.TransactionResponse): Promise<ProofSetCreationVerification>;
    getComprehensiveProofSetStatus(txHashOrTransaction: string | ethers.TransactionResponse, pdpServer: PDPServer): Promise<ComprehensiveProofSetStatus>;
    waitForProofSetCreationWithStatus(txHashOrTransaction: string | ethers.TransactionResponse, pdpServer: PDPServer, timeoutMs?: number, pollIntervalMs?: number, onProgress?: (status: ComprehensiveProofSetStatus, elapsedMs: number) => void | Promise<void>): Promise<ComprehensiveProofSetStatus>;
    calculateStorageCost(sizeInBytes: number): Promise<{
        perEpoch: bigint;
        perDay: bigint;
        perMonth: bigint;
        withCDN: {
            perEpoch: bigint;
            perDay: bigint;
            perMonth: bigint;
        };
    }>;
    checkAllowanceForStorage(sizeInBytes: number, withCDN: boolean, paymentsService: PaymentsService, lockupDays?: number): Promise<{
        rateAllowanceNeeded: bigint;
        lockupAllowanceNeeded: bigint;
        currentRateAllowance: bigint;
        currentLockupAllowance: bigint;
        currentRateUsed: bigint;
        currentLockupUsed: bigint;
        sufficient: boolean;
        message?: string;
        costs: {
            perEpoch: bigint;
            perDay: bigint;
            perMonth: bigint;
        };
        depositAmountNeeded: bigint;
    }>;
    prepareStorageUpload(options: {
        dataSize: number;
        withCDN?: boolean;
    }, paymentsService: PaymentsService): Promise<{
        estimatedCost: {
            perEpoch: bigint;
            perDay: bigint;
            perMonth: bigint;
        };
        allowanceCheck: {
            sufficient: boolean;
            message?: string;
        };
        actions: Array<{
            type: 'deposit' | 'approve' | 'approveService';
            description: string;
            execute: () => Promise<ethers.TransactionResponse>;
        }>;
    }>;
    registerServiceProvider(signer: ethers.Signer, pdpUrl: string, pieceRetrievalUrl: string): Promise<ethers.TransactionResponse>;
    approveServiceProvider(signer: ethers.Signer, providerAddress: string): Promise<ethers.TransactionResponse>;
    rejectServiceProvider(signer: ethers.Signer, providerAddress: string): Promise<ethers.TransactionResponse>;
    removeServiceProvider(signer: ethers.Signer, providerId: number): Promise<ethers.TransactionResponse>;
    addServiceProvider(signer: ethers.Signer, providerAddress: string, pdpUrl: string, pieceRetrievalUrl: string): Promise<ethers.TransactionResponse>;
    isProviderApproved(providerAddress: string): Promise<boolean>;
    getProviderIdByAddress(providerAddress: string): Promise<number>;
    getApprovedProvider(providerId: number): Promise<ApprovedProviderInfo>;
    getPendingProvider(providerAddress: string): Promise<PendingProviderInfo>;
    getNextProviderId(): Promise<number>;
    getOwner(): Promise<string>;
    isOwner(signer: ethers.Signer): Promise<boolean>;
    getAllApprovedProviders(): Promise<ApprovedProviderInfo[]>;
    getServicePrice(): Promise<{
        pricePerTiBPerMonthNoCDN: bigint;
        pricePerTiBPerMonthWithCDN: bigint;
        tokenAddress: string;
        epochsPerMonth: bigint;
    }>;
    getMaxProvingPeriod(): Promise<number>;
    getChallengeWindow(): Promise<number>;
    getProvingPeriodInHours(): Promise<number>;
    getChallengeWindowInMinutes(): Promise<number>;
    getProvingPeriodInfo(): Promise<{
        maxProvingPeriodEpochs: number;
        challengeWindowEpochs: number;
        maxProvingPeriodHours: number;
        challengeWindowMinutes: number;
        epochDurationSeconds: number;
    }>;
}
//# sourceMappingURL=service.d.ts.map