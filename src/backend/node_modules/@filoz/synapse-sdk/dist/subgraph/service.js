import { toHex, fromHex } from 'multiformats/bytes';
import { CID } from 'multiformats/cid';
import { asCommP } from '../commp/commp.js';
import { createError } from '../utils/errors.js';
import { QUERIES } from './queries.js';
export class SubgraphService {
    endpoint;
    headers;
    constructor(subgraphConfig) {
        this.endpoint = this.resolveEndpoint(subgraphConfig);
        this.headers = this.buildHeaders(subgraphConfig.apiKey);
    }
    resolveEndpoint(config) {
        if (config.endpoint != null && config.endpoint.trim() !== '') {
            return config.endpoint.trim();
        }
        if (config.goldsky != null) {
            return this.buildGoldskyEndpoint(config.goldsky);
        }
        throw createError('SubgraphService', 'constructor', 'Invalid configuration: provide either endpoint or complete goldsky config');
    }
    buildGoldskyEndpoint(goldsky) {
        const { projectId, subgraphName, version } = goldsky;
        if (projectId?.trim() == null ||
            projectId?.trim() === '' ||
            subgraphName?.trim() == null ||
            subgraphName?.trim() === '' ||
            version?.trim() == null ||
            version?.trim() === '') {
            throw createError('SubgraphService', 'constructor', 'Incomplete Goldsky config: projectId, subgraphName, and version required');
        }
        return `https://api.goldsky.com/api/public/${projectId}/subgraphs/${subgraphName}/${version}/gn`;
    }
    buildHeaders(apiKey) {
        const headers = { 'Content-Type': 'application/json' };
        if (apiKey != null && apiKey !== '') {
            return { ...headers, Authorization: `Bearer ${apiKey}` };
        }
        return headers;
    }
    normalizeQueryOptions(options = {}) {
        return {
            where: {},
            first: 10,
            skip: 0,
            orderBy: 'createdAt',
            orderDirection: 'desc',
            ...options
        };
    }
    async executeQuery(query, variables, operation) {
        try {
            const response = await fetch(this.endpoint, {
                method: 'POST',
                headers: this.headers,
                body: JSON.stringify({ query, variables })
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw createError('SubgraphService', operation, `HTTP ${response.status}: ${errorText}`);
            }
            const result = (await response.json());
            if (result.errors != null && result.errors.length > 0) {
                const errorMsg = result.errors.map((e) => e.message).join('; ');
                throw createError('SubgraphService', operation, `GraphQL errors: ${errorMsg}`);
            }
            return result.data;
        }
        catch (error) {
            if (error instanceof Error && error.name === 'SynapseError') {
                throw error;
            }
            throw createError('SubgraphService', operation, `Query execution failed: ${error.message}`, { cause: error });
        }
    }
    transformProviderData(data) {
        return {
            owner: data.address != null && data.address !== '' ? data.address : data.id,
            pdpUrl: data.pdpUrl,
            pieceRetrievalUrl: data.pieceRetrievalUrl,
            registeredAt: this.parseTimestamp(data.registeredAt),
            approvedAt: this.parseTimestamp(data.approvedAt)
        };
    }
    parseTimestamp(value) {
        if (value == null)
            return 0;
        const parsed = Number(value);
        return isNaN(parsed) ? 0 : parsed;
    }
    safeConvertHexToCid(hexCid) {
        try {
            const cleanHex = hexCid.startsWith('0x') ? hexCid.slice(2) : hexCid;
            const cidBytes = fromHex(cleanHex);
            const cid = CID.decode(cidBytes);
            const commp = asCommP(cid);
            if (commp == null) {
                throw new Error(`Failed to convert CID to CommP format: ${hexCid}`);
            }
            return commp;
        }
        catch (error) {
            console.warn(`SubgraphService: queryProviders: Failed to convert CID to CommP format: ${error instanceof Error ? error.message : 'Unknown error'}`);
            return null;
        }
    }
    isValidProviderData(data) {
        return (data?.id != null &&
            data.id.trim() !== '' &&
            data?.pdpUrl != null &&
            data.pdpUrl.trim() !== '' &&
            data?.pieceRetrievalUrl != null &&
            data.pieceRetrievalUrl.trim() !== '');
    }
    async getApprovedProvidersForCommP(commP) {
        const commPParsed = asCommP(commP);
        if (commPParsed == null) {
            throw createError('SubgraphService', 'getApprovedProvidersForCommP', 'Invalid CommP');
        }
        const hexCommP = toHex(commPParsed.bytes);
        const data = await this.executeQuery(QUERIES.GET_APPROVED_PROVIDERS_FOR_COMMP, { cid: hexCommP }, 'getApprovedProvidersForCommP');
        if (data?.roots == null || data.roots.length === 0) {
            console.log(`SubgraphService: No providers found for CommP: ${commPParsed.toString()}`);
            return [];
        }
        const uniqueProviderMap = data.roots.reduce((acc, root) => {
            const provider = root.proofSet.owner;
            const address = provider?.address?.toLowerCase();
            if (provider?.status !== 'Approved' || address == null || address === '' || acc.has(address)) {
                return acc;
            }
            if (!this.isValidProviderData(provider)) {
                console.warn('SubgraphService: Skipping incomplete provider data for approved provider:', provider);
                return acc;
            }
            acc.set(address, provider);
            return acc;
        }, new Map());
        return Array.from(uniqueProviderMap.values()).map((provider) => this.transformProviderData(provider));
    }
    async getProviderByAddress(address) {
        const data = await this.executeQuery(QUERIES.GET_PROVIDER_BY_ADDRESS, { providerId: address }, 'getProviderByAddress');
        if (data?.provider == null) {
            console.log(`SubgraphService: No provider found for address: ${address}`);
            return null;
        }
        return this.transformProviderData(data.provider);
    }
    async queryProviders(options = {}) {
        const data = await this.executeQuery(QUERIES.GET_PROVIDERS_FLEXIBLE, this.normalizeQueryOptions(options), 'queryProviders');
        if (data?.providers == null || data?.providers?.length === 0) {
            console.log('SubgraphService: No providers found for the given criteria');
            return [];
        }
        return data.providers
            .filter((provider) => this.isValidProviderData(provider))
            .map((provider) => this.transformProviderData(provider));
    }
    async queryProofSets(options = {}) {
        const data = await this.executeQuery(QUERIES.GET_PROOF_SETS_FLEXIBLE, this.normalizeQueryOptions(options), 'queryProofSets');
        if (data?.proofSets == null || data?.proofSets?.length === 0) {
            console.log('SubgraphService: No proof sets found for the given criteria');
            return [];
        }
        return data.proofSets.map((proofSet) => ({
            id: proofSet.id,
            setId: this.parseTimestamp(proofSet.setId),
            listener: proofSet.listener ?? '',
            clientAddr: proofSet.clientAddr ?? '',
            withCDN: proofSet.withCDN ?? false,
            isActive: proofSet.isActive,
            leafCount: this.parseTimestamp(proofSet.leafCount),
            challengeRange: this.parseTimestamp(proofSet.challengeRange),
            lastProvenEpoch: this.parseTimestamp(proofSet.lastProvenEpoch),
            nextChallengeEpoch: this.parseTimestamp(proofSet.nextChallengeEpoch),
            totalRoots: this.parseTimestamp(proofSet.totalRoots),
            totalDataSize: this.parseTimestamp(proofSet.totalDataSize),
            totalProofs: this.parseTimestamp(proofSet.totalProofs),
            totalProvedRoots: this.parseTimestamp(proofSet.totalProvedRoots),
            totalFaultedPeriods: this.parseTimestamp(proofSet.totalFaultedPeriods),
            totalFaultedRoots: this.parseTimestamp(proofSet.totalFaultedRoots),
            metadata: proofSet.metadata ?? '',
            createdAt: this.parseTimestamp(proofSet.createdAt),
            updatedAt: this.parseTimestamp(proofSet.updatedAt),
            owner: proofSet.owner != null
                ? this.transformProviderData(proofSet.owner)
                : {
                    owner: '',
                    pdpUrl: '',
                    pieceRetrievalUrl: '',
                    registeredAt: 0,
                    approvedAt: 0
                },
            rail: proofSet.rail != null
                ? {
                    id: proofSet.rail.id,
                    railId: this.parseTimestamp(proofSet.rail.railId),
                    token: proofSet.rail.token,
                    paymentRate: this.parseTimestamp(proofSet.rail.paymentRate),
                    lockupPeriod: this.parseTimestamp(proofSet.rail.lockupPeriod),
                    settledUpto: this.parseTimestamp(proofSet.rail.settledUpto),
                    endEpoch: this.parseTimestamp(proofSet.rail.endEpoch)
                }
                : undefined
        }));
    }
    async queryRoots(options = {}) {
        const data = await this.executeQuery(QUERIES.GET_ROOTS_FLEXIBLE, this.normalizeQueryOptions(options), 'queryRoots');
        if (data?.roots == null || data?.roots?.length === 0) {
            console.log('SubgraphService: No roots found for the given criteria');
            return [];
        }
        return data.roots.map((root) => ({
            id: root.id,
            setId: this.parseTimestamp(root.setId),
            rootId: this.parseTimestamp(root.rootId),
            rawSize: this.parseTimestamp(root.rawSize),
            leafCount: this.parseTimestamp(root.leafCount),
            cid: this.safeConvertHexToCid(root.cid),
            removed: root.removed,
            totalProofsSubmitted: this.parseTimestamp(root.totalProofsSubmitted),
            totalPeriodsFaulted: this.parseTimestamp(root.totalPeriodsFaulted),
            lastProvenEpoch: this.parseTimestamp(root.lastProvenEpoch),
            lastProvenAt: this.parseTimestamp(root.lastProvenAt),
            lastFaultedEpoch: this.parseTimestamp(root.lastFaultedEpoch),
            lastFaultedAt: this.parseTimestamp(root.lastFaultedAt),
            createdAt: this.parseTimestamp(root.createdAt),
            metadata: root.metadata ?? '',
            proofSet: {
                id: root.proofSet.id,
                setId: this.parseTimestamp(root.proofSet.setId),
                isActive: root.proofSet.isActive,
                owner: this.transformProviderData(root.proofSet.owner)
            }
        }));
    }
    async queryFaultRecords(options = {}) {
        const data = await this.executeQuery(QUERIES.GET_FAULT_RECORDS_FLEXIBLE, this.normalizeQueryOptions(options), 'queryFaultRecords');
        if (data?.faultRecords == null || data?.faultRecords?.length === 0) {
            console.log('SubgraphService: No fault records found for the given criteria');
            return [];
        }
        return data.faultRecords.map((fault) => ({
            id: fault.id,
            proofSetId: this.parseTimestamp(fault.proofSetId),
            rootIds: fault.rootIds.map((id) => this.parseTimestamp(id)),
            currentChallengeEpoch: this.parseTimestamp(fault.currentChallengeEpoch),
            nextChallengeEpoch: this.parseTimestamp(fault.nextChallengeEpoch),
            periodsFaulted: this.parseTimestamp(fault.periodsFaulted),
            deadline: this.parseTimestamp(fault.deadline),
            createdAt: this.parseTimestamp(fault.createdAt),
            proofSet: {
                id: fault.proofSet.id,
                setId: this.parseTimestamp(fault.proofSet.setId),
                owner: this.transformProviderData(fault.proofSet.owner)
            }
        }));
    }
}
//# sourceMappingURL=service.js.map