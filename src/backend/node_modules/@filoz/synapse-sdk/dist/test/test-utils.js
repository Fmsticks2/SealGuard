import { ethers } from 'ethers';
export function createMockSigner(address = '0x1234567890123456789012345678901234567890', provider) {
    const signer = {
        provider: provider ?? null,
        async getAddress() { return address; },
        async signTransaction() { return '0xsignedtransaction'; },
        async signMessage() { return '0xsignedmessage'; },
        async signTypedData() { return '0xsignedtypeddata'; },
        connect(newProvider) {
            return createMockSigner(address, newProvider);
        },
        async sendTransaction(transaction) {
            if (provider != null) {
                return provider.sendTransaction(transaction);
            }
            throw new Error('No provider for sendTransaction');
        }
    };
    return signer;
}
export function createMockProvider(chainId = 314159) {
    const network = new ethers.Network('test', chainId);
    const provider = {
        getNetwork: async () => network,
        getSigner: async function () {
            return createMockSigner('0x1234567890123456789012345678901234567890', this);
        },
        getBalance: async (address) => ethers.parseEther('100'),
        getTransactionCount: async (address, blockTag) => 0,
        getBlock: async (blockHashOrBlockTag) => {
            return {
                number: 1000000,
                timestamp: Math.floor(Date.now() / 1000),
                hash: '0x' + Math.random().toString(16).substring(2).padEnd(64, '0')
            };
        },
        call: async (transaction) => {
            const data = transaction.data;
            const to = transaction.to?.toLowerCase();
            if (data == null)
                return '0x';
            if (data?.startsWith('0x7bca0328') === true &&
                (to === '0x394feca6bcb84502d93c0c5c03c620ba8897e8f4' ||
                    to === '0xbfdc4454c2b573079c6c5ea1ddef6b8defc03dd5')) {
                const pricePerTiBPerMonth = ethers.parseUnits('2', 18);
                const tokenAddress = '0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0';
                const epochsPerMonth = 86400n;
                return ethers.AbiCoder.defaultAbiCoder().encode(['uint256', 'address', 'uint256'], [pricePerTiBPerMonth, tokenAddress, epochsPerMonth]);
            }
            if (data.includes('70a08231') === true) {
                return ethers.zeroPadValue(ethers.toBeHex(ethers.parseUnits('1000', 18)), 32);
            }
            if (data.includes('313ce567') === true) {
                return ethers.zeroPadValue(ethers.toBeHex(18), 32);
            }
            if (data.includes('dd62ed3e') === true) {
                return ethers.zeroPadValue(ethers.toBeHex(0), 32);
            }
            if (data.includes('095ea7b3') === true) {
                return ethers.zeroPadValue(ethers.toBeHex(1), 32);
            }
            if (data.includes('ad74b775') === true) {
                const funds = ethers.parseUnits('500', 18);
                const lockupCurrent = 0n;
                const lockupRate = 0n;
                const lockupLastSettledAt = 1000000;
                return ethers.AbiCoder.defaultAbiCoder().encode(['uint256', 'uint256', 'uint256', 'uint256'], [funds, lockupCurrent, lockupRate, lockupLastSettledAt]);
            }
            if (data.includes('5482bdf9') === true) {
                const pricePerTiBPerMonthNoCDN = ethers.parseUnits('2', 18);
                const pricePerTiBPerMonthWithCDN = ethers.parseUnits('3', 18);
                const tokenAddress = '0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0';
                const epochsPerMonth = 86400n;
                return ethers.AbiCoder.defaultAbiCoder().encode(['tuple(uint256,uint256,address,uint256)'], [[pricePerTiBPerMonthNoCDN, pricePerTiBPerMonthWithCDN, tokenAddress, epochsPerMonth]]);
            }
            if (data.includes('89c6a46f') === true) {
                return ethers.AbiCoder.defaultAbiCoder().encode(['uint256[]'], [[1n, 2n]]);
            }
            if (data.includes('7a8fa2f1') === true) {
                return ethers.AbiCoder.defaultAbiCoder().encode(['uint256[]'], [[3n, 4n]]);
            }
            if (data.includes('0e64d1e0') === true) {
                const rail = {
                    token: '0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0',
                    from: '0x1234567890123456789012345678901234567890',
                    to: '0x78bF4d833fC2ba1Abd42Bc772edbC788EC76A28F',
                    operator: '0xBfDC4454c2B573079C6c5eA1DDeF6B8defC03dd5',
                    arbiter: '0xBfDC4454c2B573079C6c5eA1DDeF6B8defC03dd5',
                    paymentRate: ethers.parseUnits('0.001', 18),
                    paymentRateNew: ethers.parseUnits('0.001', 18),
                    rateChangeEpoch: 0n,
                    lockupFixed: 0n,
                    lockupPeriod: 28800n,
                    settledUpTo: 1000000,
                    endEpoch: 0n,
                    commissionRateBps: 100n
                };
                return ethers.AbiCoder.defaultAbiCoder().encode(['address', 'address', 'address', 'address', 'address', 'uint256', 'uint256', 'uint256', 'uint256', 'uint256', 'uint256', 'uint256', 'uint256'], [rail.token, rail.from, rail.to, rail.operator, rail.arbiter, rail.paymentRate, rail.paymentRateNew, rail.rateChangeEpoch, rail.lockupFixed, rail.lockupPeriod, rail.settledUpTo, rail.endEpoch, rail.commissionRateBps]);
            }
            if (data.includes('e3d4c69e') === true) {
                const isApproved = false;
                const rateAllowance = 0n;
                const rateUsed = 0n;
                const lockupAllowance = 0n;
                const lockupUsed = 0n;
                return ethers.AbiCoder.defaultAbiCoder().encode(['bool', 'uint256', 'uint256', 'uint256', 'uint256'], [isApproved, rateAllowance, rateUsed, lockupAllowance, lockupUsed]);
            }
            return '0x';
        },
        getBlockNumber: async () => 1000000,
        getCode: async (address) => '0x1234',
        estimateGas: async (transaction) => 21000n,
        getFeeData: async () => new ethers.FeeData(ethers.parseUnits('1', 'gwei'), ethers.parseUnits('1', 'gwei'), ethers.parseUnits('1', 'gwei')),
        getLogs: async (filter) => [],
        resolveName: async (name) => null,
        lookupAddress: async (address) => null,
        broadcastTransaction: async (signedTx) => {
            throw new Error('Not implemented in mock');
        },
        getTransaction: async (hash) => {
            throw new Error('Not implemented in mock');
        },
        getTransactionReceipt: async (hash) => {
            return {
                hash,
                from: '0x1234567890123456789012345678901234567890',
                to: null,
                contractAddress: null,
                index: 0,
                root: '',
                gasUsed: 50000n,
                gasPrice: 1000000000n,
                cumulativeGasUsed: 50000n,
                effectiveGasPrice: 1000000000n,
                logsBloom: '',
                blockHash: '',
                blockNumber: 1000000,
                logs: [],
                status: 1
            };
        },
        waitForTransaction: async (hash, confirmations, timeout) => {
            throw new Error('Not implemented in mock');
        },
        sendTransaction: async (transaction) => {
            const hash = '0x' + Math.random().toString(16).substring(2).padEnd(64, '0');
            return {
                hash,
                from: transaction.from ?? '',
                to: transaction.to ?? null,
                data: transaction.data ?? '',
                value: transaction.value ?? 0n,
                chainId: 314159n,
                gasLimit: 100000n,
                gasPrice: 1000000000n,
                nonce: 0,
                wait: async () => ({
                    hash,
                    from: transaction.from ?? '',
                    to: transaction.to ?? null,
                    contractAddress: null,
                    index: 0,
                    root: '',
                    gasUsed: 50000n,
                    gasPrice: 1000000000n,
                    cumulativeGasUsed: 50000n,
                    effectiveGasPrice: 1000000000n,
                    logsBloom: '',
                    blockHash: '',
                    blockNumber: 1000000,
                    logs: [],
                    status: 1
                })
            };
        }
    };
    return provider;
}
//# sourceMappingURL=test-utils.js.map