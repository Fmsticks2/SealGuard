import { asCommP, createCommPStream } from './commp.js';
export async function downloadAndValidateCommP(response, expectedCommP) {
    const parsedCommP = asCommP(expectedCommP);
    if (parsedCommP == null) {
        throw new Error(`Invalid CommP: ${String(expectedCommP)}`);
    }
    if (!response.ok) {
        throw new Error(`Download failed: ${response.status} ${response.statusText}`);
    }
    if (response.body == null) {
        throw new Error('Response body is null');
    }
    const { stream: commpStream, getCommP } = createCommPStream();
    const chunks = [];
    const collectStream = new TransformStream({
        transform(chunk, controller) {
            chunks.push(chunk);
            controller.enqueue(chunk);
        }
    });
    const pipelineStream = response.body
        .pipeThrough(commpStream)
        .pipeThrough(collectStream);
    const reader = pipelineStream.getReader();
    try {
        while (true) {
            const { done } = await reader.read();
            if (done)
                break;
        }
    }
    finally {
        reader.releaseLock();
    }
    const calculatedCommP = getCommP();
    if (calculatedCommP == null) {
        throw new Error('Failed to calculate CommP from stream');
    }
    if (calculatedCommP.toString() !== parsedCommP.toString()) {
        throw new Error(`CommP verification failed. Expected: ${String(parsedCommP)}, Got: ${String(calculatedCommP)}`);
    }
    const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
    }
    return result;
}
export async function downloadAndValidateCommPFromUrl(url, expectedCommP) {
    const response = await fetch(url);
    return await downloadAndValidateCommP(response, expectedCommP);
}
//# sourceMappingURL=download.js.map