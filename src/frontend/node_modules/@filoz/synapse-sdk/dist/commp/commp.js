import { CID } from 'multiformats/cid';
import * as Digest from 'multiformats/hashes/digest';
import { Fr32 } from '@web3-storage/data-segment';
import * as Hasher from '@web3-storage/data-segment/multihash';
export const FIL_COMMITMENT_UNSEALED = 0xf101;
export const SHA2_256_TRUNC254_PADDED = 0x1012;
export function toZeroPaddedSize(payloadSize) {
    return Fr32.toZeroPaddedSize(payloadSize);
}
export function toPieceSize(payloadSize) {
    return Fr32.toPieceSize(payloadSize);
}
function parseCommP(commpString) {
    try {
        const cid = CID.parse(commpString);
        if (cid.code !== FIL_COMMITMENT_UNSEALED) {
            return null;
        }
        if (cid.multihash.code !== SHA2_256_TRUNC254_PADDED) {
            return null;
        }
        return cid;
    }
    catch {
        return null;
    }
}
function isValidCommP(cid) {
    return cid.code === FIL_COMMITMENT_UNSEALED &&
        cid.multihash.code === SHA2_256_TRUNC254_PADDED;
}
export function asCommP(commpInput) {
    if (typeof commpInput === 'string') {
        return parseCommP(commpInput);
    }
    if (typeof commpInput === 'object' && CID.asCID(commpInput) !== null) {
        if (!isValidCommP(commpInput)) {
            return null;
        }
        return commpInput;
    }
    return null;
}
function commPv2ToCommPv1(digest) {
    const legacyDigest = Digest.create(SHA2_256_TRUNC254_PADDED, digest.bytes.subarray(digest.bytes.length - Hasher.Digest.ROOT_SIZE));
    return CID.create(1, FIL_COMMITMENT_UNSEALED, legacyDigest);
}
export function calculate(data) {
    const hasher = Hasher.create();
    const chunkSize = 2048;
    for (let i = 0; i < data.length; i += chunkSize) {
        hasher.write(data.subarray(i, i + chunkSize));
    }
    const digest = hasher.digest();
    return commPv2ToCommPv1(digest);
}
export function createCommPStream() {
    const hasher = Hasher.create();
    let finished = false;
    let commp = null;
    const stream = new TransformStream({
        transform(chunk, controller) {
            hasher.write(chunk);
            controller.enqueue(chunk);
        },
        flush() {
            const digest = hasher.digest();
            commp = commPv2ToCommPv1(digest);
            finished = true;
        }
    });
    return {
        stream,
        getCommP: () => {
            if (!finished) {
                return null;
            }
            return commp;
        }
    };
}
//# sourceMappingURL=commp.js.map