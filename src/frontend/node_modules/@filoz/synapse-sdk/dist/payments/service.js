import { ethers } from 'ethers';
import { createError, CONTRACT_ADDRESSES, CONTRACT_ABIS, TOKENS, TIMING_CONSTANTS } from '../utils/index.js';
export class PaymentsService {
    _provider;
    _signer;
    _network;
    _disableNonceManager;
    _usdfcContract = null;
    _paymentsContract = null;
    constructor(provider, signer, network, disableNonceManager) {
        this._provider = provider;
        this._signer = signer;
        this._network = network;
        this._disableNonceManager = disableNonceManager;
    }
    _getUsdfcContract() {
        if (this._usdfcContract == null) {
            const usdfcAddress = CONTRACT_ADDRESSES.USDFC[this._network];
            if (usdfcAddress == null) {
                throw new Error(`USDFC contract not deployed on ${this._network} network`);
            }
            this._usdfcContract = new ethers.Contract(usdfcAddress, CONTRACT_ABIS.ERC20, this._signer);
        }
        return this._usdfcContract;
    }
    _getPaymentsContract() {
        if (this._paymentsContract == null) {
            const paymentsAddress = CONTRACT_ADDRESSES.PAYMENTS[this._network];
            if (paymentsAddress == null || paymentsAddress === '') {
                throw new Error(`Payments contract not deployed on ${this._network} network. Currently only Calibration testnet is supported.`);
            }
            this._paymentsContract = new ethers.Contract(paymentsAddress, CONTRACT_ABIS.PAYMENTS, this._signer);
        }
        return this._paymentsContract;
    }
    async balance(token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'payments contract balance check', `Token "${token}" is not supported. Currently only USDFC token is supported for payments contract balance queries.`);
        }
        const accountInfo = await this.accountInfo(token);
        return accountInfo.availableFunds;
    }
    async accountInfo(token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'account info', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcAddress = CONTRACT_ADDRESSES.USDFC[this._network];
        const paymentsContract = this._getPaymentsContract();
        let accountData;
        try {
            accountData = await paymentsContract.accounts(usdfcAddress, signerAddress);
        }
        catch (contractCallError) {
            throw createError('PaymentsService', 'account info', 'Failed to read account information from payments contract. This could indicate the contract is not properly deployed, the ABI is incorrect, or there are network connectivity issues.', contractCallError);
        }
        const [funds, lockupCurrent, lockupRate, lockupLastSettledAt] = accountData;
        const currentEpoch = await this.getCurrentEpoch();
        const epochsSinceSettlement = currentEpoch - BigInt(lockupLastSettledAt);
        const actualLockup = BigInt(lockupCurrent) + (BigInt(lockupRate) * epochsSinceSettlement);
        const availableFunds = BigInt(funds) - actualLockup;
        return {
            funds: BigInt(funds),
            lockupCurrent: BigInt(lockupCurrent),
            lockupRate: BigInt(lockupRate),
            lockupLastSettledAt: BigInt(lockupLastSettledAt),
            availableFunds: availableFunds > 0n ? availableFunds : 0n
        };
    }
    async getCurrentEpoch() {
        const block = await this._provider.getBlock('latest');
        if (block == null) {
            throw createError('PaymentsService', 'getCurrentEpoch', 'Failed to get latest block');
        }
        return BigInt(block.number);
    }
    async walletBalance(token) {
        if (token == null || token === TOKENS.FIL) {
            try {
                const address = await this._signer.getAddress();
                const balance = await this._provider.getBalance(address);
                return balance;
            }
            catch (error) {
                throw createError('PaymentsService', 'wallet FIL balance check', 'Unable to retrieve FIL balance from wallet. This could be due to network connectivity issues, RPC endpoint problems, or wallet connection issues.', error);
            }
        }
        if (token === TOKENS.USDFC) {
            try {
                const address = await this._signer.getAddress();
                const usdfcContract = this._getUsdfcContract();
                const balance = await usdfcContract.balanceOf(address);
                return balance;
            }
            catch (error) {
                throw createError('PaymentsService', 'wallet USDFC balance check', 'Unexpected error while checking USDFC token balance in wallet.', error);
            }
        }
        throw createError('PaymentsService', 'wallet balance check', `Token "${token}" is not supported. Currently only USDFC token is supported for balance queries.`);
    }
    decimals(token = TOKENS.USDFC) {
        return 18;
    }
    async allowance(token, spender) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'allowance', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcContract = this._getUsdfcContract();
        try {
            const currentAllowance = await usdfcContract.allowance(signerAddress, spender);
            return currentAllowance;
        }
        catch (error) {
            throw createError('PaymentsService', 'allowance check', 'Failed to check token allowance. This could indicate network connectivity issues or an invalid spender address.', error);
        }
    }
    async approve(token, spender, amount) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'approve', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const approveAmount = typeof amount === 'bigint' ? amount : BigInt(amount);
        if (approveAmount < 0n) {
            throw createError('PaymentsService', 'approve', 'Approval amount cannot be negative');
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcContract = this._getUsdfcContract();
        const txOptions = {};
        if (this._disableNonceManager) {
            const approvalNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = approvalNonce;
        }
        try {
            const approveTx = await usdfcContract.approve(spender, approveAmount, txOptions);
            return approveTx;
        }
        catch (error) {
            throw createError('PaymentsService', 'approve', `Failed to approve ${spender} to spend ${approveAmount.toString()} ${token}`, error);
        }
    }
    async approveService(service, rateAllowance, lockupAllowance, token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'approveService', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const rateAllowanceBigint = typeof rateAllowance === 'bigint' ? rateAllowance : BigInt(rateAllowance);
        const lockupAllowanceBigint = typeof lockupAllowance === 'bigint' ? lockupAllowance : BigInt(lockupAllowance);
        if (rateAllowanceBigint < 0n || lockupAllowanceBigint < 0n) {
            throw createError('PaymentsService', 'approveService', 'Allowance values cannot be negative');
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcAddress = CONTRACT_ADDRESSES.USDFC[this._network];
        const paymentsContract = this._getPaymentsContract();
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        try {
            const approveTx = await paymentsContract.setOperatorApproval(usdfcAddress, service, true, rateAllowanceBigint, lockupAllowanceBigint, txOptions);
            return approveTx;
        }
        catch (error) {
            throw createError('PaymentsService', 'approveService', `Failed to approve service ${service} as operator for ${token}`, error);
        }
    }
    async revokeService(service, token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'revokeService', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcAddress = CONTRACT_ADDRESSES.USDFC[this._network];
        const paymentsContract = this._getPaymentsContract();
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        try {
            const revokeTx = await paymentsContract.setOperatorApproval(usdfcAddress, service, false, 0n, 0n, txOptions);
            return revokeTx;
        }
        catch (error) {
            throw createError('PaymentsService', 'revokeService', `Failed to revoke service ${service} as operator for ${token}`, error);
        }
    }
    async serviceApproval(service, token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'serviceApproval', `Token "${token}" is not supported. Currently only USDFC token is supported.`);
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcAddress = CONTRACT_ADDRESSES.USDFC[this._network];
        const paymentsContract = this._getPaymentsContract();
        try {
            const approval = await paymentsContract.operatorApprovals(usdfcAddress, signerAddress, service);
            return {
                isApproved: approval[0],
                rateAllowance: approval[1],
                lockupAllowance: approval[2],
                rateUsed: approval[3],
                lockupUsed: approval[4]
            };
        }
        catch (error) {
            throw createError('PaymentsService', 'serviceApproval', `Failed to check service approval status for ${service}`, error);
        }
    }
    async deposit(amount, token = TOKENS.USDFC, callbacks) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'deposit', `Unsupported token: ${token}`);
        }
        const depositAmountBigint = typeof amount === 'bigint' ? amount : BigInt(amount);
        if (depositAmountBigint <= 0n) {
            throw createError('PaymentsService', 'deposit', 'Invalid amount');
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcAddress = CONTRACT_ADDRESSES.USDFC[this._network];
        const usdfcContract = this._getUsdfcContract();
        const paymentsContract = this._getPaymentsContract();
        const usdfcBalance = await usdfcContract.balanceOf(signerAddress);
        if (usdfcBalance < depositAmountBigint) {
            throw createError('PaymentsService', 'deposit', `Insufficient USDFC: have ${BigInt(usdfcBalance).toString()}, need ${depositAmountBigint.toString()}`);
        }
        const paymentsAddress = CONTRACT_ADDRESSES.PAYMENTS[this._network];
        if (paymentsAddress == null) {
            throw createError('PaymentsService', 'deposit', `Payments contract not deployed on ${this._network}`);
        }
        const currentAllowance = await this.allowance(token, paymentsAddress);
        callbacks?.onAllowanceCheck?.(currentAllowance, depositAmountBigint);
        if (currentAllowance < depositAmountBigint) {
            const approveTx = await this.approve(token, paymentsAddress, depositAmountBigint);
            callbacks?.onApprovalTransaction?.(approveTx);
            const approvalReceipt = await approveTx.wait(TIMING_CONSTANTS.TRANSACTION_CONFIRMATIONS);
            if (approvalReceipt != null) {
                callbacks?.onApprovalConfirmed?.(approvalReceipt);
            }
        }
        callbacks?.onDepositStarting?.();
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        const depositTx = await paymentsContract.deposit(usdfcAddress, signerAddress, depositAmountBigint, txOptions);
        return depositTx;
    }
    async withdraw(amount, token = TOKENS.USDFC) {
        if (token !== TOKENS.USDFC) {
            throw createError('PaymentsService', 'withdraw', `Unsupported token: ${token}`);
        }
        const withdrawAmountBigint = typeof amount === 'bigint' ? amount : BigInt(amount);
        if (withdrawAmountBigint <= 0n) {
            throw createError('PaymentsService', 'withdraw', 'Invalid amount');
        }
        const signerAddress = await this._signer.getAddress();
        const usdfcAddress = CONTRACT_ADDRESSES.USDFC[this._network];
        const paymentsContract = this._getPaymentsContract();
        const accountInfo = await this.accountInfo(token);
        if (accountInfo.availableFunds < withdrawAmountBigint) {
            throw createError('PaymentsService', 'withdraw', `Insufficient available balance: have ${accountInfo.availableFunds.toString()}, need ${withdrawAmountBigint.toString()}`);
        }
        const txOptions = {};
        if (this._disableNonceManager) {
            const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending');
            txOptions.nonce = currentNonce;
        }
        const withdrawTx = await paymentsContract.withdraw(usdfcAddress, withdrawAmountBigint, txOptions);
        return withdrawTx;
    }
}
//# sourceMappingURL=service.js.map