import { fetchPiecesFromProviders } from './utils.js';
import { createError } from '../utils/index.js';
export class ChainRetriever {
    pandoraService;
    childRetriever;
    constructor(pandoraService, childRetriever) {
        this.pandoraService = pandoraService;
        this.childRetriever = childRetriever;
    }
    async findProviders(client, providerAddress) {
        if (providerAddress != null) {
            const providerId = await this.pandoraService.getProviderIdByAddress(providerAddress);
            if (providerId === 0) {
                throw createError('ChainRetriever', 'findProviders', `Provider ${providerAddress} not found or not approved`);
            }
            const provider = await this.pandoraService.getApprovedProvider(providerId);
            return [provider];
        }
        const proofSets = await this.pandoraService.getClientProofSetsWithDetails(client);
        const validProofSets = proofSets.filter(ps => ps.isLive &&
            ps.currentRootCount > 0);
        if (validProofSets.length === 0) {
            throw createError('ChainRetriever', 'findProviders', `No active proof sets with data found for client ${client}`);
        }
        const uniqueProviders = [...new Set(validProofSets.map(ps => ps.payee))];
        const providerInfos = await Promise.all(uniqueProviders.map(async (addr) => {
            const id = await this.pandoraService.getProviderIdByAddress(addr);
            return await this.pandoraService.getApprovedProvider(id);
        }));
        return providerInfos;
    }
    async fetchPiece(commp, client, options) {
        const tryChildOrThrow = async (reason) => {
            if (this.childRetriever !== undefined) {
                return await this.childRetriever.fetchPiece(commp, client, options);
            }
            throw createError('ChainRetriever', 'fetchPiece', `Failed to retrieve piece ${commp.toString()}: ${reason}`);
        };
        let providersToTry = [];
        try {
            providersToTry = await this.findProviders(client, options?.providerAddress);
        }
        catch (error) {
            return await tryChildOrThrow('Provider discovery failed and no additional retriever method was configured');
        }
        if (providersToTry.length === 0) {
            return await tryChildOrThrow('No providers found and no additional retriever method was configured');
        }
        try {
            return await fetchPiecesFromProviders(providersToTry, commp, 'ChainRetriever', options?.signal);
        }
        catch (fetchError) {
            return await tryChildOrThrow('All provider retrieval attempts failed and no additional retriever method was configured');
        }
    }
}
//# sourceMappingURL=chain.js.map