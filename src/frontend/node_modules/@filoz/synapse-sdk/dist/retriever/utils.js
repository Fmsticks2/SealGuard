import { constructPieceUrl, constructFindPieceUrl } from '../utils/piece.js';
import { createError } from '../utils/errors.js';
export async function fetchPiecesFromProviders(providers, commp, retrieverName, signal) {
    const failures = [];
    const abortControllers = [];
    const providerAttempts = providers.map(async (provider, index) => {
        const controller = new AbortController();
        abortControllers[index] = controller;
        if (signal != null) {
            signal.addEventListener('abort', () => {
                controller.abort(signal.reason);
            }, { once: true });
            if (signal.aborted) {
                controller.abort(signal.reason);
            }
        }
        try {
            const findUrl = constructFindPieceUrl(provider.pdpUrl, commp);
            const findResponse = await fetch(findUrl, {
                signal: controller.signal
            });
            if (!findResponse.ok) {
                failures.push({
                    provider: provider.owner,
                    error: `findPiece returned ${findResponse.status}`
                });
                throw new Error('Provider does not have piece');
            }
            const downloadUrl = constructPieceUrl(provider.pieceRetrievalUrl, commp);
            const response = await fetch(downloadUrl, {
                signal: controller.signal
            });
            if (response.ok) {
                return { response, index };
            }
            failures.push({
                provider: provider.owner,
                error: `download returned ${response.status}`
            });
            throw new Error(`Download failed with status ${response.status}`);
        }
        catch (error) {
            const errorMsg = error.message ?? 'Unknown error';
            if (!failures.some((f) => f.provider === provider.owner)) {
                failures.push({ provider: provider.owner, error: errorMsg });
            }
            console.warn(`Failed to fetch from provider ${provider.owner}:`, errorMsg);
            throw error;
        }
    });
    try {
        const { response, index: winnerIndex } = await Promise.any(providerAttempts);
        abortControllers.forEach((ctrl, i) => {
            if (i !== winnerIndex) {
                ctrl.abort();
            }
        });
        return response;
    }
    catch (error) {
        if (error instanceof AggregateError) {
            const failureDetails = failures.map((f) => `${f.provider}: ${f.error}`).join('; ');
            throw createError(retrieverName, 'fetchPiecesFromProviders', `All providers failed to serve piece ${commp.toString()}. Details: ${failureDetails}`);
        }
        throw error;
    }
}
//# sourceMappingURL=utils.js.map