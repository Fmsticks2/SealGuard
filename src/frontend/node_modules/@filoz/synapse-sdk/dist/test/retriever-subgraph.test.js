import { assert } from 'chai';
import { SubgraphRetriever } from '../retriever/subgraph.js';
import { SubgraphService } from '../subgraph/index.js';
import { asCommP } from '../commp/index.js';
const mockCommP = asCommP('baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq');
const mockProvider = {
    owner: '0x1234567890123456789012345678901234567890',
    pdpUrl: 'https://provider.example.com/pdp',
    pieceRetrievalUrl: 'https://provider.example.com/retrieve',
    registeredAt: 1000,
    approvedAt: 2000
};
const mockChildRetriever = {
    fetchPiece: async (commP, client, options) => {
        return new Response('data from child', { status: 200 });
    }
};
const createMockSubgraphService = (providersToReturn) => {
    const mockService = {
        getApprovedProvidersForCommP: async (commP) => {
            if (providersToReturn instanceof Error) {
                throw providersToReturn;
            }
            return providersToReturn ?? [];
        },
        getProviderByAddress: async (address) => {
            const providers = providersToReturn instanceof Error ? [] : providersToReturn ?? [];
            return providers.find((p) => p.owner === address) ?? null;
        }
    };
    return mockService;
};
describe('SubgraphRetriever', () => {
    describe('constructor', () => {
        it('should initialize with a SubgraphService (direct endpoint config for service)', () => {
            const config = { endpoint: 'https://test.com/graphql' };
            const service = new SubgraphService(config);
            const retriever = new SubgraphRetriever(service);
            assert.isNotNull(retriever);
        });
        it('should initialize with a SubgraphService (Goldsky config for service)', () => {
            const config = {
                goldsky: {
                    projectId: 'test-project',
                    subgraphName: 'test-subgraph',
                    version: 'v1'
                }
            };
            const service = new SubgraphService(config);
            const retriever = new SubgraphRetriever(service);
            assert.isNotNull(retriever);
        });
        it('SubgraphService should throw an error for incomplete Goldsky configuration', () => {
            assert.throws(() => {
                const config = {
                    goldsky: { projectId: 'test', subgraphName: '', version: '' }
                };
                new SubgraphService(config);
            }, /Incomplete Goldsky config: projectId, subgraphName, and version required/);
        });
        it('SubgraphService should throw an error for empty configuration', () => {
            assert.throws(() => {
                const config = {};
                new SubgraphService(config);
            }, /Invalid configuration: provide either endpoint or complete goldsky config/);
        });
    });
    describe('fetchPiece', () => {
        let originalFetch;
        beforeEach(() => {
            originalFetch = global.fetch;
        });
        afterEach(() => {
            global.fetch = originalFetch;
        });
        it('should fetch a piece from a provider found via SubgraphService', async () => {
            const mockService = createMockSubgraphService([mockProvider]);
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes(mockProvider.pdpUrl)) {
                    return new Response(null, { status: 200 });
                }
                if (url.includes(mockProvider.pieceRetrievalUrl)) {
                    return new Response('piece data', { status: 200 });
                }
                throw new Error(`Unexpected fetch call to ${url}`);
            };
            const retriever = new SubgraphRetriever(mockService);
            const response = await retriever.fetchPiece(mockCommP, 'client1');
            assert.equal(response.status, 200);
            assert.equal(await response.text(), 'piece data');
        });
        it('should fall back to child retriever when SubgraphService returns no providers', async () => {
            const mockService = createMockSubgraphService([]);
            const retriever = new SubgraphRetriever(mockService, mockChildRetriever);
            const response = await retriever.fetchPiece(mockCommP, 'client1');
            assert.equal(response.status, 200);
            assert.equal(await response.text(), 'data from child');
        });
        it('should fall back to child retriever when fetching from subgraph providers (found by service) fails', async () => {
            const mockService = createMockSubgraphService([mockProvider]);
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes(mockProvider.pdpUrl) || url.includes(mockProvider.pieceRetrievalUrl)) {
                    return new Response('provider error', { status: 500 });
                }
                throw new Error(`Unexpected fetch call to ${url}`);
            };
            const retriever = new SubgraphRetriever(mockService, mockChildRetriever);
            const response = await retriever.fetchPiece(mockCommP, 'client1');
            assert.equal(response.status, 200);
            assert.equal(await response.text(), 'data from child');
        });
        it('should filter by providerAddress when provided (providers from service)', async () => {
            const otherProvider = {
                ...mockProvider,
                owner: '0xother',
                pieceRetrievalUrl: 'https://otherprovider.example.com/retrieve'
            };
            const mockService = createMockSubgraphService([mockProvider, otherProvider]);
            let fetchCalledForMockProvider = false;
            let fetchCalledForOtherProvider = false;
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes(mockProvider.pieceRetrievalUrl)) {
                    fetchCalledForMockProvider = true;
                    return new Response('piece data', { status: 200 });
                }
                if (url.includes(otherProvider.pieceRetrievalUrl)) {
                    fetchCalledForOtherProvider = true;
                    return new Response('other piece data', { status: 200 });
                }
                if (url.includes('/pdp')) {
                    return new Response(null, { status: 200 });
                }
                throw new Error(`Unexpected fetch call to ${url}`);
            };
            const retriever = new SubgraphRetriever(mockService);
            await retriever.fetchPiece(mockCommP, 'client1', { providerAddress: mockProvider.owner });
            assert.isTrue(fetchCalledForMockProvider, 'Should have fetched from the specified provider');
            assert.isFalse(fetchCalledForOtherProvider, 'Should NOT have fetched from the other provider');
        });
        it('should throw an error if all attempts fail (service provides provider, but fetch fails) and no child', async () => {
            const mockService = createMockSubgraphService([mockProvider]);
            global.fetch = async (input, init) => {
                return new Response('error', { status: 500 });
            };
            const retriever = new SubgraphRetriever(mockService);
            try {
                await retriever.fetchPiece(mockCommP, 'client1');
                assert.fail('Should have thrown an error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to retrieve piece');
            }
        });
        it('should throw an error if service returns no providers and no child retriever', async () => {
            const mockService = createMockSubgraphService([]);
            const retriever = new SubgraphRetriever(mockService);
            try {
                await retriever.fetchPiece(mockCommP, 'client1');
                assert.fail('Should have thrown an error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to retrieve piece');
                assert.include(error.message, 'No providers found and no additional retriever method was configured');
            }
        });
        it('should fall back if SubgraphService effectively returns empty (e.g. due to internal GraphQL error)', async () => {
            const mockService = createMockSubgraphService([]);
            const retriever = new SubgraphRetriever(mockService, mockChildRetriever);
            const response = await retriever.fetchPiece(mockCommP, 'client1');
            assert.equal(response.status, 200);
            assert.equal(await response.text(), 'data from child');
        });
    });
});
//# sourceMappingURL=retriever-subgraph.test.js.map