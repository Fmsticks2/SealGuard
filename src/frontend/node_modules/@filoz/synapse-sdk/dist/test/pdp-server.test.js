import { assert } from 'chai';
import { ethers } from 'ethers';
import { PDPServer, PDPAuthHelper } from '../pdp/index.js';
import { asCommP, calculate as calculateCommP } from '../commp/index.js';
class MockPDPServer {
    server = null;
    handlers = new Map();
    addHandler(method, path, handler) {
        this.handlers.set(`${method}:${path}`, handler);
    }
    async start(port) {
        return await new Promise((resolve) => {
            const baseUrl = `http://localhost:${port}`;
            resolve(baseUrl);
        });
    }
    async stop() {
        return await Promise.resolve();
    }
}
describe('PDPServer', () => {
    let pdpServer;
    let authHelper;
    let mockServer;
    let serverUrl;
    const TEST_PRIVATE_KEY = '0x1234567890123456789012345678901234567890123456789012345678901234';
    const TEST_CONTRACT_ADDRESS = '0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f';
    const TEST_CHAIN_ID = 31337;
    beforeEach(async () => {
        const signer = new ethers.Wallet(TEST_PRIVATE_KEY);
        authHelper = new PDPAuthHelper(TEST_CONTRACT_ADDRESS, signer, BigInt(TEST_CHAIN_ID));
        mockServer = new MockPDPServer();
        serverUrl = await mockServer.start(0);
        pdpServer = new PDPServer(authHelper, serverUrl + '/api', serverUrl + '/retrieval');
    });
    afterEach(async () => {
        await mockServer.stop();
    });
    describe('constructor', () => {
        it('should create PDPServer with valid API endpoint', () => {
            const tool = new PDPServer(authHelper, 'https://example.com/foo', 'https://example.com/bar');
            assert.strictEqual(tool.getApiEndpoint(), 'https://example.com/foo');
        });
        it('should remove trailing slash from API endpoint', () => {
            const tool = new PDPServer(authHelper, 'https://example.com/foo/', 'https://example.com/bar');
            assert.strictEqual(tool.getApiEndpoint(), 'https://example.com/foo');
        });
        it('should throw error for empty API endpoint', () => {
            assert.throws(() => {
                new PDPServer(authHelper, '', 'https://example.com');
            }, 'PDP API endpoint is required');
        });
        it('should throw error for empty retrieval endpoint', () => {
            assert.throws(() => {
                new PDPServer(authHelper, 'https://example.com/pdp', '');
            }, 'PDP retrieval endpoint is required');
        });
    });
    describe('createProofSet', () => {
        it('should handle successful proof set creation', async () => {
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const originalFetch = global.fetch;
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
                assert.include(url, '/api/pdp/proof-sets');
                assert.strictEqual(init?.method, 'POST');
                const body = JSON.parse(init?.body);
                assert.isDefined(body.recordKeeper);
                assert.isDefined(body.extraData);
                return {
                    status: 201,
                    headers: {
                        get: (header) => {
                            if (header === 'Location') {
                                return `/pdp/proof-sets/created/${mockTxHash}`;
                            }
                            return null;
                        }
                    }
                };
            };
            try {
                const result = await pdpServer.createProofSet(0, '0x70997970C51812dc3A010C7d01b50e0d17dc79C8', false, TEST_CONTRACT_ADDRESS);
                assert.strictEqual(result.txHash, mockTxHash);
                assert.include(result.statusUrl, mockTxHash);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
    });
    describe('getRootAdditionStatus', () => {
        it('should handle successful status check', async () => {
            const mockTxHash = '0x7890abcdef1234567890abcdef1234567890abcdef1234567890abcdef123456';
            const mockResponse = {
                txHash: mockTxHash,
                txStatus: 'confirmed',
                proofSetId: 1,
                rootCount: 2,
                addMessageOk: true,
                confirmedRootIds: [101, 102]
            };
            const originalFetch = global.fetch;
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
                assert.include(url, `/api/pdp/proof-sets/1/roots/added/${mockTxHash}`);
                assert.strictEqual(init?.method, 'GET');
                return {
                    status: 200,
                    json: async () => mockResponse
                };
            };
            try {
                const result = await pdpServer.getRootAdditionStatus(1, mockTxHash);
                assert.deepStrictEqual(result, mockResponse);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle pending status', async () => {
            const mockTxHash = '0x7890abcdef1234567890abcdef1234567890abcdef1234567890abcdef123456';
            const mockResponse = {
                txHash: mockTxHash,
                txStatus: 'pending',
                proofSetId: 1,
                rootCount: 2,
                addMessageOk: null,
                confirmedRootIds: undefined
            };
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 200,
                    json: async () => mockResponse
                };
            };
            try {
                const result = await pdpServer.getRootAdditionStatus(1, mockTxHash);
                assert.strictEqual(result.txStatus, 'pending');
                assert.isNull(result.addMessageOk);
                assert.isUndefined(result.confirmedRootIds);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle not found status', async () => {
            const mockTxHash = '0x7890abcdef1234567890abcdef1234567890abcdef1234567890abcdef123456';
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 404
                };
            };
            try {
                await pdpServer.getRootAdditionStatus(1, mockTxHash);
                assert.fail('Should have thrown error for not found status');
            }
            catch (error) {
                assert.include(error.message, `Root addition not found for transaction: ${mockTxHash}`);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle server errors', async () => {
            const mockTxHash = '0x7890abcdef1234567890abcdef1234567890abcdef1234567890abcdef123456';
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 500,
                    statusText: 'Internal Server Error',
                    text: async () => 'Database error'
                };
            };
            try {
                await pdpServer.getRootAdditionStatus(1, mockTxHash);
                assert.fail('Should have thrown error for server error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to get root addition status');
                assert.include(error.message, '500');
                assert.include(error.message, 'Database error');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
    });
    describe('addRoots', () => {
        it('should validate input parameters', async () => {
            try {
                await pdpServer.addRoots(1, 0, 0, []);
                assert.fail('Should have thrown error for empty root entries');
            }
            catch (error) {
                assert.include(error.message, 'At least one root must be provided');
            }
            const invalidRawSize = {
                cid: 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy',
                rawSize: -1
            };
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 400,
                    statusText: 'Bad Request',
                    text: async () => 'Invalid raw size'
                };
            };
            try {
                await pdpServer.addRoots(1, 0, 0, [invalidRawSize]);
                assert.fail('Should have thrown error for invalid raw size');
            }
            catch (error) {
                assert.include(error.message, 'Failed to add roots to proof set');
            }
            finally {
                global.fetch = originalFetch;
            }
            const invalidCommP = {
                cid: 'invalid-commp-string',
                rawSize: 1024
            };
            try {
                await pdpServer.addRoots(1, 0, 0, [invalidCommP]);
                assert.fail('Should have thrown error for invalid CommP');
            }
            catch (error) {
                assert.include(error.message, 'Invalid CommP');
            }
        });
        it('should handle successful root addition', async () => {
            const validRootData = [
                {
                    cid: 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy',
                    rawSize: 1024 * 1024
                }
            ];
            const originalFetch = global.fetch;
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
                assert.include(url, '/api/pdp/proof-sets/1/roots');
                assert.strictEqual(init?.method, 'POST');
                const body = JSON.parse(init?.body);
                assert.isDefined(body.roots);
                assert.isDefined(body.extraData);
                assert.strictEqual(body.roots.length, 1);
                assert.strictEqual(body.roots[0].rootCid, validRootData[0].cid);
                assert.strictEqual(body.roots[0].subroots.length, 1);
                assert.strictEqual(body.roots[0].subroots[0].subrootCid, validRootData[0].cid);
                return {
                    status: 201,
                    text: async () => 'Roots added successfully',
                    headers: {
                        get: (name) => null
                    }
                };
            };
            try {
                const result = await pdpServer.addRoots(1, 0, 0, validRootData);
                assert.isDefined(result);
                assert.isDefined(result.message);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle server errors appropriately', async () => {
            const validRootData = [
                {
                    cid: 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy',
                    rawSize: 1024 * 1024
                }
            ];
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 400,
                    statusText: 'Bad Request',
                    text: async () => 'Invalid root CID'
                };
            };
            try {
                await pdpServer.addRoots(1, 0, 0, validRootData);
                assert.fail('Should have thrown error for server error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to add roots to proof set: 400 Bad Request - Invalid root CID');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle multiple roots', async () => {
            const commP1 = asCommP('baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy');
            const commP2 = asCommP('baga6ea4seaqkt24j5gbf2ye2wual5gn7a5yl2tqb52v2sk4nvur4bdy7lg76cdy');
            assert.isNotNull(commP1);
            assert.isNotNull(commP2);
            if (commP1 == null || commP2 == null) {
                throw new Error('Failed to parse test CommPs');
            }
            const multipleRootData = [
                {
                    cid: commP1,
                    rawSize: 1024 * 1024
                },
                {
                    cid: 'baga6ea4seaqkt24j5gbf2ye2wual5gn7a5yl2tqb52v2sk4nvur4bdy7lg76cdy',
                    rawSize: 2048 * 1024
                }
            ];
            const originalFetch = global.fetch;
            global.fetch = async (input, init) => {
                const body = JSON.parse(init?.body);
                assert.strictEqual(body.roots.length, 2);
                assert.strictEqual(body.roots[0].subroots.length, 1);
                assert.strictEqual(body.roots[1].subroots.length, 1);
                assert.strictEqual(body.roots[0].rootCid, body.roots[0].subroots[0].subrootCid);
                assert.strictEqual(body.roots[1].rootCid, body.roots[1].subroots[0].subrootCid);
                return {
                    status: 201,
                    text: async () => 'Multiple roots added successfully',
                    headers: {
                        get: (name) => null
                    }
                };
            };
            try {
                const result = await pdpServer.addRoots(1, 0, 0, multipleRootData);
                assert.isDefined(result);
                assert.isDefined(result.message);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle addRoots response with Location header', async () => {
            const validRootData = [
                {
                    cid: 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy',
                    rawSize: 1024 * 1024
                }
            ];
            const mockTxHash = '0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890';
            const originalFetch = global.fetch;
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
                assert.include(url, '/api/pdp/proof-sets/1/roots');
                assert.strictEqual(init?.method, 'POST');
                return {
                    status: 201,
                    text: async () => 'Roots added successfully',
                    headers: {
                        get: (name) => {
                            if (name === 'Location') {
                                return `/pdp/proof-sets/1/roots/added/${mockTxHash}`;
                            }
                            return null;
                        }
                    }
                };
            };
            try {
                const result = await pdpServer.addRoots(1, 0, 0, validRootData);
                assert.isDefined(result);
                assert.isDefined(result.message);
                assert.strictEqual(result.txHash, mockTxHash);
                assert.include(result.statusUrl ?? '', mockTxHash);
                assert.include(result.statusUrl ?? '', '/pdp/proof-sets/1/roots/added/');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle addRoots response with Location header missing 0x prefix', async () => {
            const validRootData = [
                {
                    cid: 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy',
                    rawSize: 1024 * 1024
                }
            ];
            const mockTxHashWithout0x = 'abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890';
            const mockTxHashWith0x = '0x' + mockTxHashWithout0x;
            const originalFetch = global.fetch;
            global.fetch = async (input, init) => {
                return {
                    status: 201,
                    text: async () => 'Roots added successfully',
                    headers: {
                        get: (name) => {
                            if (name === 'Location') {
                                return `/pdp/proof-sets/1/roots/added/${mockTxHashWithout0x}`;
                            }
                            return null;
                        }
                    }
                };
            };
            try {
                const result = await pdpServer.addRoots(1, 0, 0, validRootData);
                assert.isDefined(result);
                assert.strictEqual(result.txHash, mockTxHashWith0x);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle malformed Location header gracefully', async () => {
            const validRootData = [
                {
                    cid: 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy',
                    rawSize: 1024 * 1024
                }
            ];
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 201,
                    text: async () => 'Roots added successfully',
                    headers: {
                        get: (name) => {
                            if (name === 'Location') {
                                return '/some/unexpected/path';
                            }
                            return null;
                        }
                    }
                };
            };
            try {
                const result = await pdpServer.addRoots(1, 0, 0, validRootData);
                assert.isDefined(result);
                assert.isDefined(result.message);
                assert.isUndefined(result.txHash);
                assert.isUndefined(result.statusUrl);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
    });
    describe('getProofSetCreationStatus', () => {
        it('should handle successful status check', async () => {
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const mockResponse = {
                createMessageHash: mockTxHash,
                proofSetCreated: true,
                service: 'test-service',
                txStatus: 'confirmed',
                ok: true,
                proofSetId: 123
            };
            const originalFetch = global.fetch;
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
                assert.include(url, `/api/pdp/proof-sets/created/${mockTxHash}`);
                assert.strictEqual(init?.method, 'GET');
                return {
                    status: 200,
                    json: async () => mockResponse
                };
            };
            try {
                const result = await pdpServer.getProofSetCreationStatus(mockTxHash);
                assert.deepStrictEqual(result, mockResponse);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle not found status', async () => {
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 404
                };
            };
            try {
                await pdpServer.getProofSetCreationStatus(mockTxHash);
                assert.fail('Should have thrown error for not found status');
            }
            catch (error) {
                assert.include(error.message, `Proof set creation not found for transaction hash: ${mockTxHash}`);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
    });
    describe('findPiece', () => {
        it('should find a piece successfully', async () => {
            const mockCommP = 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy';
            const mockSize = 1048576;
            const mockResponse = {
                piece_cid: mockCommP
            };
            const originalFetch = global.fetch;
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
                assert.include(url, '/api/pdp/piece?');
                assert.include(url, 'name=sha2-256-trunc254-padded');
                assert.include(url, 'size=1048576');
                assert.strictEqual(init?.method, 'GET');
                return {
                    status: 200,
                    ok: true,
                    json: async () => mockResponse
                };
            };
            try {
                const result = await pdpServer.findPiece(mockCommP, mockSize);
                assert.strictEqual(result.piece_cid, mockCommP);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle piece not found', async () => {
            const mockCommP = 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy';
            const mockSize = 1048576;
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 404,
                    ok: false,
                    text: async () => 'Requested resource not found'
                };
            };
            try {
                await pdpServer.findPiece(mockCommP, mockSize);
                assert.fail('Should have thrown error for not found');
            }
            catch (error) {
                assert.include(error.message, 'Piece not found');
                assert.include(error.message, mockCommP);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should validate CommP input', async () => {
            const invalidCommP = 'invalid-commp-string';
            const mockSize = 1048576;
            try {
                await pdpServer.findPiece(invalidCommP, mockSize);
                assert.fail('Should have thrown error for invalid CommP');
            }
            catch (error) {
                assert.include(error.message, 'Invalid CommP');
            }
        });
        it('should handle server errors', async () => {
            const mockCommP = 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy';
            const mockSize = 1048576;
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 500,
                    ok: false,
                    statusText: 'Internal Server Error',
                    text: async () => 'Database error'
                };
            };
            try {
                await pdpServer.findPiece(mockCommP, mockSize);
                assert.fail('Should have thrown error for server error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to find piece');
                assert.include(error.message, '500');
                assert.include(error.message, 'Database error');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
    });
    describe('getters', () => {
        it('should return API endpoint', () => {
            assert.strictEqual(pdpServer.getApiEndpoint(), serverUrl + '/api');
        });
        it('should return PDPAuthHelper instance', () => {
            assert.strictEqual(pdpServer.getAuthHelper(), authHelper);
        });
    });
    describe('uploadPiece', () => {
        it('should successfully upload data', async () => {
            const testData = new Uint8Array([1, 2, 3, 4, 5]);
            const mockUuid = '12345678-90ab-cdef-1234-567890abcdef';
            const originalFetch = global.fetch;
            global.fetch = async (url, options) => {
                const urlStr = url.toString();
                if (urlStr.includes('/pdp/piece') === true && options?.method === 'POST') {
                    const body = JSON.parse(options.body);
                    assert.exists(body.check);
                    assert.equal(body.check.name, 'sha2-256-trunc254-padded');
                    assert.exists(body.check.hash);
                    assert.equal(body.check.size, 5);
                    return {
                        ok: false,
                        status: 201,
                        headers: {
                            get: (name) => {
                                if (name === 'Location') {
                                    return `/api/pdp/piece/upload/${mockUuid}`;
                                }
                                return null;
                            }
                        },
                        text: async () => 'Created'
                    };
                }
                else if (urlStr.includes(`/api/pdp/piece/upload/${String(mockUuid)}`) === true) {
                    return {
                        ok: true,
                        status: 204
                    };
                }
                throw new Error(`Unexpected request: ${String(urlStr)}`);
            };
            try {
                const result = await pdpServer.uploadPiece(testData);
                assert.exists(result.commP);
                assert.equal(result.size, 5);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle ArrayBuffer input', async () => {
            const buffer = new ArrayBuffer(5);
            const view = new Uint8Array(buffer);
            view.set([1, 2, 3, 4, 5]);
            const mockUuid = 'fedcba09-8765-4321-fedc-ba0987654321';
            const originalFetch = global.fetch;
            global.fetch = async (url, options) => {
                const urlStr = url.toString();
                if (urlStr.includes('/pdp/piece') === true && options?.method === 'POST') {
                    const body = JSON.parse(options.body);
                    assert.exists(body.check);
                    assert.equal(body.check.name, 'sha2-256-trunc254-padded');
                    assert.exists(body.check.hash);
                    assert.equal(body.check.size, 5);
                    return {
                        ok: false,
                        status: 201,
                        headers: {
                            get: (name) => {
                                if (name === 'Location') {
                                    return `/api/pdp/piece/upload/${mockUuid}`;
                                }
                                return null;
                            }
                        },
                        text: async () => 'Created'
                    };
                }
                else if (urlStr.includes(`/api/pdp/piece/upload/${String(mockUuid)}`) === true) {
                    return {
                        ok: true,
                        status: 204
                    };
                }
                throw new Error(`Unexpected request: ${String(urlStr)}`);
            };
            try {
                const result = await pdpServer.uploadPiece(buffer);
                assert.exists(result.commP);
                assert.equal(result.size, 5);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle existing piece (200 response)', async () => {
            const testData = new Uint8Array([1, 2, 3, 4, 5]);
            const mockPieceCid = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            const originalFetch = global.fetch;
            global.fetch = async (url, options) => {
                const urlStr = url.toString();
                if (urlStr.includes('/pdp/piece') === true && options?.method === 'POST') {
                    const body = JSON.parse(options.body);
                    assert.exists(body.check);
                    assert.equal(body.check.name, 'sha2-256-trunc254-padded');
                    assert.exists(body.check.hash);
                    assert.equal(body.check.size, 5);
                    return {
                        ok: true,
                        status: 200,
                        json: async () => ({ pieceCID: mockPieceCid })
                    };
                }
                throw new Error(`Unexpected request: ${String(urlStr)}`);
            };
            try {
                const result = await pdpServer.uploadPiece(testData);
                assert.exists(result.commP);
                assert.equal(result.size, 5);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should throw on create upload session error', async () => {
            const testData = new Uint8Array([1, 2, 3, 4, 5]);
            const originalFetch = global.fetch;
            global.fetch = async (url, options) => {
                const urlStr = url.toString();
                if (urlStr.includes('/pdp/piece') === true && options?.method === 'POST') {
                    const body = JSON.parse(options.body);
                    assert.exists(body.check);
                    return {
                        ok: false,
                        status: 500,
                        statusText: 'Internal Server Error',
                        text: async () => 'Database error'
                    };
                }
                throw new Error(`Unexpected request: ${String(urlStr)}`);
            };
            try {
                await pdpServer.uploadPiece(testData);
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to create upload session');
                assert.include(error.message, '500');
                assert.include(error.message, 'Database error');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
    });
    describe('downloadPiece', () => {
        it('should successfully download and verify piece', async () => {
            const testData = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);
            const testCommP = calculateCommP(testData).toString();
            const originalFetch = global.fetch;
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                assert.isTrue(url.endsWith(`/piece/${testCommP}`));
                return new Response(testData, {
                    status: 200,
                    headers: { 'Content-Type': 'application/octet-stream' }
                });
            };
            try {
                const result = await pdpServer.downloadPiece(testCommP);
                assert.deepEqual(result, testData);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should throw on download failure', async () => {
            const mockCommP = 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy';
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    ok: false,
                    status: 404,
                    statusText: 'Not Found'
                };
            };
            try {
                await pdpServer.downloadPiece(mockCommP);
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Download failed');
                assert.include(error.message, '404');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should reject invalid CommP', async () => {
            try {
                await pdpServer.downloadPiece('invalid-commp-string');
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Invalid CommP');
            }
        });
        it('should throw on CommP verification failure', async () => {
            const testData = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);
            const testCommP = calculateCommP(testData).toString();
            const wrongData = new Uint8Array([9, 9, 9, 9]);
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return new Response(wrongData, {
                    status: 200,
                    headers: { 'Content-Type': 'application/octet-stream' }
                });
            };
            try {
                await pdpServer.downloadPiece(testCommP);
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'CommP verification failed');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle null response body', async () => {
            const mockCommP = 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy';
            const originalFetch = global.fetch;
            global.fetch = async () => {
                const response = new Response(null, { status: 200 });
                Object.defineProperty(response, 'body', { value: null });
                return response;
            };
            try {
                await pdpServer.downloadPiece(mockCommP);
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Response body is null');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should correctly stream and verify chunked data', async () => {
            const testData = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);
            const testCommP = calculateCommP(testData).toString();
            const originalFetch = global.fetch;
            global.fetch = async () => {
                const chunk1 = testData.slice(0, 4);
                const chunk2 = testData.slice(4);
                const stream = new ReadableStream({
                    async start(controller) {
                        controller.enqueue(chunk1);
                        await new Promise(resolve => setTimeout(resolve, 10));
                        controller.enqueue(chunk2);
                        controller.close();
                    }
                });
                return new Response(stream, {
                    status: 200,
                    headers: { 'Content-Type': 'application/octet-stream' }
                });
            };
            try {
                const result = await pdpServer.downloadPiece(testCommP);
                assert.deepEqual(result, testData);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
    });
    describe('ping', () => {
        it('should successfully ping a healthy provider', async () => {
            const originalFetch = global.fetch;
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
                assert.include(url, '/api/pdp/ping');
                assert.strictEqual(init?.method, 'GET');
                assert.deepEqual(init?.headers, {});
                return {
                    status: 200,
                    statusText: 'OK'
                };
            };
            try {
                await pdpServer.ping();
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should throw error when provider returns non-200 status', async () => {
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 500,
                    statusText: 'Internal Server Error',
                    text: async () => 'Server is down'
                };
            };
            try {
                await pdpServer.ping();
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Provider ping failed');
                assert.include(error.message, '500');
                assert.include(error.message, 'Internal Server Error');
                assert.include(error.message, 'Server is down');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should throw error when provider returns 404', async () => {
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 404,
                    statusText: 'Not Found',
                    text: async () => 'Ping endpoint not found'
                };
            };
            try {
                await pdpServer.ping();
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Provider ping failed');
                assert.include(error.message, '404');
                assert.include(error.message, 'Not Found');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle fetch failure', async () => {
            const originalFetch = global.fetch;
            global.fetch = async () => {
                throw new Error('Network connection failed');
            };
            try {
                await pdpServer.ping();
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Network connection failed');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle error when response.text() fails', async () => {
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 503,
                    statusText: 'Service Unavailable',
                    text: async () => {
                        throw new Error('Failed to read response body');
                    }
                };
            };
            try {
                await pdpServer.ping();
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Provider ping failed');
                assert.include(error.message, '503');
                assert.include(error.message, 'Service Unavailable');
                assert.include(error.message, 'Unknown error');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should use correct URL endpoint', async () => {
            let capturedUrl = '';
            const originalFetch = global.fetch;
            global.fetch = async (input) => {
                capturedUrl = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
                return {
                    status: 200,
                    statusText: 'OK'
                };
            };
            try {
                await pdpServer.ping();
                assert.strictEqual(capturedUrl, `${serverUrl}/api/pdp/ping`);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
    });
    describe('getProofSet', () => {
        it('should successfully fetch proof set data', async () => {
            const mockProofSetData = {
                id: 292,
                roots: [
                    {
                        rootId: 101,
                        rootCid: 'baga6ea4seaqh5lmkfwaovjuigyp4hzclc6hqnhoqcm3re3ipumhp3kfka7wdvjq',
                        subrootCid: 'baga6ea4seaqh5lmkfwaovjuigyp4hzclc6hqnhoqcm3re3ipumhp3kfka7wdvjq',
                        subrootOffset: 0
                    },
                    {
                        rootId: 102,
                        rootCid: 'baga6ea4seaqkt24j5gbf2ye2wual5gn7a5yl2tqb52v2sk4nvur4bdy7lg76cdy',
                        subrootCid: 'baga6ea4seaqkt24j5gbf2ye2wual5gn7a5yl2tqb52v2sk4nvur4bdy7lg76cdy',
                        subrootOffset: 0
                    }
                ],
                nextChallengeEpoch: 1500
            };
            const originalFetch = global.fetch;
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
                assert.include(url, '/pdp/proof-sets/292');
                assert.strictEqual(init?.method, 'GET');
                assert.strictEqual(init?.headers?.Accept, 'application/json');
                return {
                    status: 200,
                    ok: true,
                    json: async () => mockProofSetData
                };
            };
            try {
                const result = await pdpServer.getProofSet(292);
                assert.equal(result.id, mockProofSetData.id);
                assert.equal(result.nextChallengeEpoch, mockProofSetData.nextChallengeEpoch);
                assert.equal(result.roots.length, mockProofSetData.roots.length);
                assert.equal(result.roots[0].rootId, mockProofSetData.roots[0].rootId);
                assert.equal(result.roots[0].rootCid.toString(), mockProofSetData.roots[0].rootCid);
                assert.equal(result.roots[0].subrootCid.toString(), mockProofSetData.roots[0].subrootCid);
                assert.equal(result.roots[0].subrootOffset, mockProofSetData.roots[0].subrootOffset);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle proof set not found', async () => {
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 404,
                    ok: false
                };
            };
            try {
                await pdpServer.getProofSet(999);
                assert.fail('Should have thrown error for not found proof set');
            }
            catch (error) {
                assert.include(error.message, 'Proof set not found: 999');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle server errors', async () => {
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 500,
                    ok: false,
                    statusText: 'Internal Server Error',
                    text: async () => 'Database error'
                };
            };
            try {
                await pdpServer.getProofSet(292);
                assert.fail('Should have thrown error for server error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to fetch proof set');
                assert.include(error.message, '500');
                assert.include(error.message, 'Database error');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should validate response data', async () => {
            const invalidProofSetData = {
                id: '292',
                roots: 'not-array',
                nextChallengeEpoch: 'soon'
            };
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 200,
                    ok: true,
                    json: async () => invalidProofSetData
                };
            };
            try {
                await pdpServer.getProofSet(292);
                assert.fail('Should have thrown error for invalid response data');
            }
            catch (error) {
                assert.include(error.message, 'Invalid proof set data response format');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle proof set with no roots', async () => {
            const emptyProofSetData = {
                id: 292,
                roots: [],
                nextChallengeEpoch: 1500
            };
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 200,
                    ok: true,
                    json: async () => emptyProofSetData
                };
            };
            try {
                const result = await pdpServer.getProofSet(292);
                assert.deepStrictEqual(result, emptyProofSetData);
                assert.isArray(result.roots);
                assert.equal(result.roots.length, 0);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should reject response with invalid CIDs', async () => {
            const invalidCidProofSetData = {
                id: 292,
                roots: [
                    {
                        rootId: 101,
                        rootCid: 'invalid-cid-format',
                        subrootCid: 'baga6ea4seaqh5lmkfwaovjuigyp4hzclc6hqnhoqcm3re3ipumhp3kfka7wdvjq',
                        subrootOffset: 0
                    }
                ],
                nextChallengeEpoch: 1500
            };
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return {
                    status: 200,
                    ok: true,
                    json: async () => invalidCidProofSetData
                };
            };
            try {
                await pdpServer.getProofSet(292);
                assert.fail('Should have thrown error for invalid CID in response');
            }
            catch (error) {
                assert.include(error.message, 'Invalid proof set data response format');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
    });
});
//# sourceMappingURL=pdp-server.test.js.map