import { assert } from 'chai';
import { ethers } from 'ethers';
import { StorageService } from '../storage/service.js';
const mockEthProvider = {
    getTransaction: async (hash) => null,
    getNetwork: async () => ({ chainId: BigInt(314159), name: 'test' })
};
const mockSynapse = {
    getSigner: () => new ethers.Wallet(ethers.hexlify(ethers.randomBytes(32))),
    getProvider: () => mockEthProvider,
    getPandoraAddress: () => '0x1234567890123456789012345678901234567890',
    getChainId: () => BigInt(314159),
    payments: {
        serviceApproval: async () => ({
            service: '0x1234567890123456789012345678901234567890',
            rateAllowance: BigInt(1000000),
            lockupAllowance: BigInt(10000000),
            rateUsed: BigInt(0),
            lockupUsed: BigInt(0)
        })
    },
    download: async (commp, options) => {
        return new Uint8Array(65).fill(42);
    },
    getProviderInfo: async (providerAddress) => {
        throw new Error('getProviderInfo not mocked');
    }
};
const mockProvider = {
    owner: '0xabcdef1234567890123456789012345678901234',
    pdpUrl: 'https://pdp.example.com',
    pieceRetrievalUrl: 'https://retrieve.example.com',
    registeredAt: 1234567890,
    approvedAt: 1234567891
};
describe('StorageService', () => {
    describe('create() factory method', () => {
        it('should select a random provider when no providerId specified', async () => {
            const mockProviders = [
                {
                    owner: '0x1111111111111111111111111111111111111111',
                    pdpUrl: 'https://pdp1.example.com',
                    pieceRetrievalUrl: 'https://retrieve1.example.com',
                    registeredAt: 1234567890,
                    approvedAt: 1234567891
                },
                {
                    owner: '0x2222222222222222222222222222222222222222',
                    pdpUrl: 'https://pdp2.example.com',
                    pieceRetrievalUrl: 'https://retrieve2.example.com',
                    registeredAt: 1234567892,
                    approvedAt: 1234567893
                }
            ];
            const proofSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProviders[0].owner,
                    pdpVerifierProofSetId: 100,
                    nextRootId: 0,
                    currentRootCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 1
                },
                {
                    railId: 2,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProviders[1].owner,
                    pdpVerifierProofSetId: 101,
                    nextRootId: 0,
                    currentRootCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 2
                }
            ];
            const mockPandoraService = {
                getAllApprovedProviders: async () => mockProviders,
                getClientProofSetsWithDetails: async () => proofSets,
                getNextClientDataSetId: async () => 3,
                getProviderIdByAddress: async (address) => {
                    const idx = mockProviders.findIndex(p => p.owner.toLowerCase() === address.toLowerCase());
                    return idx >= 0 ? idx + 1 : 0;
                },
                getApprovedProvider: async (id) => mockProviders[id - 1] ?? null
            };
            const originalFetch = global.fetch;
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes('/ping')) {
                    return { status: 200, statusText: 'OK' };
                }
                throw new Error(`Unexpected URL: ${url}`);
            };
            try {
                const service = await StorageService.create(mockSynapse, mockPandoraService, {});
                assert.isTrue(service.storageProvider === mockProviders[0].owner ||
                    service.storageProvider === mockProviders[1].owner);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should use specific provider when providerId specified', async () => {
            const mockProvider = {
                owner: '0x3333333333333333333333333333333333333333',
                pdpUrl: 'https://pdp3.example.com',
                pieceRetrievalUrl: 'https://retrieve3.example.com',
                registeredAt: 1234567894,
                approvedAt: 1234567895
            };
            const proofSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0x3333333333333333333333333333333333333333',
                    pdpVerifierProofSetId: 100,
                    nextRootId: 0,
                    currentRootCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 1
                }
            ];
            const mockPandoraService = {
                getApprovedProvider: async (id) => {
                    assert.equal(id, 3);
                    return mockProvider;
                },
                getClientProofSetsWithDetails: async () => proofSets,
                getNextClientDataSetId: async () => 2
            };
            const service = await StorageService.create(mockSynapse, mockPandoraService, { providerId: 3 });
            assert.equal(service.storageProvider, mockProvider.owner);
        });
        it('should throw when no approved providers available', async () => {
            const mockPandoraService = {
                getAllApprovedProviders: async () => [],
                getClientProofSetsWithDetails: async () => []
            };
            try {
                await StorageService.create(mockSynapse, mockPandoraService, {});
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'No approved storage providers available');
            }
        });
        it('should throw when specified provider not found', async () => {
            const mockPandoraService = {
                getApprovedProvider: async () => ({
                    owner: '0x0000000000000000000000000000000000000000',
                    pdpUrl: '',
                    pieceRetrievalUrl: '',
                    registeredAt: 0,
                    approvedAt: 0
                }),
                getClientProofSetsWithDetails: async () => []
            };
            try {
                await StorageService.create(mockSynapse, mockPandoraService, { providerId: 999 });
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Provider ID 999 not found or not approved');
            }
        });
        it('should select existing proof set when available', async () => {
            const mockProvider = {
                owner: '0x3333333333333333333333333333333333333333',
                pdpUrl: 'https://pdp3.example.com',
                pieceRetrievalUrl: 'https://retrieve3.example.com',
                registeredAt: 1234567894,
                approvedAt: 1234567895
            };
            const mockProofSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0x3333333333333333333333333333333333333333',
                    pdpVerifierProofSetId: 100,
                    nextRootId: 5,
                    currentRootCount: 5,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 1
                }
            ];
            const mockPandoraService = {
                getApprovedProvider: async () => mockProvider,
                getClientProofSetsWithDetails: async () => mockProofSets,
                getNextClientDataSetId: async () => 2
            };
            const service = await StorageService.create(mockSynapse, mockPandoraService, { providerId: 3 });
            assert.equal(service.proofSetId, '100');
        });
        it.skip('should create new proof set when none exist', async () => {
        });
        it('should prefer proof sets with existing roots', async () => {
            const mockProvider = {
                owner: '0x3333333333333333333333333333333333333333',
                pdpUrl: 'https://pdp3.example.com',
                pieceRetrievalUrl: 'https://retrieve3.example.com',
                registeredAt: 1234567894,
                approvedAt: 1234567895
            };
            const mockProofSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0x3333333333333333333333333333333333333333',
                    pdpVerifierProofSetId: 100,
                    nextRootId: 0,
                    currentRootCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 1
                },
                {
                    railId: 2,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0x3333333333333333333333333333333333333333',
                    pdpVerifierProofSetId: 101,
                    nextRootId: 5,
                    currentRootCount: 5,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 2
                }
            ];
            const mockPandoraService = {
                getApprovedProvider: async () => mockProvider,
                getClientProofSetsWithDetails: async () => mockProofSets,
                getNextClientDataSetId: async () => 3
            };
            const service = await StorageService.create(mockSynapse, mockPandoraService, { providerId: 3 });
            assert.equal(service.proofSetId, '101');
        });
        it('should handle provider selection callbacks', async () => {
            const mockProvider = {
                owner: '0x3333333333333333333333333333333333333333',
                pdpUrl: 'https://pdp3.example.com',
                pieceRetrievalUrl: 'https://retrieve3.example.com',
                registeredAt: 1234567894,
                approvedAt: 1234567895
            };
            let providerCallbackFired = false;
            let proofSetCallbackFired = false;
            const proofSets = [{
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProvider.owner,
                    pdpVerifierProofSetId: 100,
                    nextRootId: 0,
                    currentRootCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 1
                }];
            const mockPandoraService = {
                getApprovedProvider: async () => mockProvider,
                getClientProofSetsWithDetails: async () => proofSets,
                getNextClientDataSetId: async () => 2
            };
            await StorageService.create(mockSynapse, mockPandoraService, {
                providerId: 3,
                callbacks: {
                    onProviderSelected: (provider) => {
                        assert.equal(provider.owner, mockProvider.owner);
                        providerCallbackFired = true;
                    },
                    onProofSetResolved: (info) => {
                        assert.isTrue(info.isExisting);
                        assert.equal(info.proofSetId, 100);
                        proofSetCallbackFired = true;
                    }
                }
            });
            assert.isTrue(providerCallbackFired, 'onProviderSelected should have been called');
            assert.isTrue(proofSetCallbackFired, 'onProofSetResolved should have been called');
        });
        it('should select by explicit proofSetId', async () => {
            const mockProvider = {
                owner: '0x3333333333333333333333333333333333333333',
                pdpUrl: 'https://pdp3.example.com',
                pieceRetrievalUrl: 'https://retrieve3.example.com',
                registeredAt: 1234567894,
                approvedAt: 1234567895
            };
            const mockProofSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProvider.owner,
                    pdpVerifierProofSetId: 456,
                    nextRootId: 10,
                    currentRootCount: 10,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 1
                }
            ];
            const mockPandoraService = {
                getClientProofSetsWithDetails: async () => mockProofSets,
                getProviderIdByAddress: async (addr) => {
                    assert.equal(addr, mockProvider.owner);
                    return 3;
                },
                getApprovedProvider: async (id) => {
                    assert.equal(id, 3);
                    return mockProvider;
                }
            };
            const service = await StorageService.create(mockSynapse, mockPandoraService, { proofSetId: 456 });
            assert.equal(service.proofSetId, '456');
            assert.equal(service.storageProvider, mockProvider.owner);
        });
        it('should select by providerAddress', async () => {
            const mockProvider = {
                owner: '0x4444444444444444444444444444444444444444',
                pdpUrl: 'https://pdp4.example.com',
                pieceRetrievalUrl: 'https://retrieve4.example.com',
                registeredAt: 1234567896,
                approvedAt: 1234567897
            };
            const mockProofSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProvider.owner,
                    pdpVerifierProofSetId: 789,
                    nextRootId: 0,
                    currentRootCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 1
                }
            ];
            const mockPandoraService = {
                getProviderIdByAddress: async (addr) => {
                    assert.equal(addr.toLowerCase(), mockProvider.owner.toLowerCase());
                    return 4;
                },
                getApprovedProvider: async (id) => {
                    assert.equal(id, 4);
                    return mockProvider;
                },
                getClientProofSetsWithDetails: async () => mockProofSets
            };
            const service = await StorageService.create(mockSynapse, mockPandoraService, {
                providerAddress: mockProvider.owner
            });
            assert.equal(service.storageProvider, mockProvider.owner);
            assert.equal(service.proofSetId, '789');
        });
        it('should throw when proofSetId not found', async () => {
            const mockPandoraService = {
                getClientProofSetsWithDetails: async () => []
            };
            try {
                await StorageService.create(mockSynapse, mockPandoraService, { proofSetId: 999 });
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Proof set 999 not found');
            }
        });
        it('should throw when proofSetId conflicts with providerId', async () => {
            const mockProvider1 = {
                owner: '0x5555555555555555555555555555555555555555',
                pdpUrl: 'https://pdp5.example.com',
                pieceRetrievalUrl: 'https://retrieve5.example.com',
                registeredAt: 1234567898,
                approvedAt: 1234567899
            };
            const mockProofSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProvider1.owner,
                    pdpVerifierProofSetId: 111,
                    nextRootId: 0,
                    currentRootCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 1
                }
            ];
            const mockPandoraService = {
                getClientProofSetsWithDetails: async () => mockProofSets,
                getProviderIdByAddress: async () => 5
            };
            try {
                await StorageService.create(mockSynapse, mockPandoraService, {
                    proofSetId: 111,
                    providerId: 3
                });
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'belongs to provider ID 5');
                assert.include(error.message, 'but provider ID 3 was requested');
            }
        });
        it('should throw when providerAddress not approved', async () => {
            const mockPandoraService = {
                getProviderIdByAddress: async () => 0,
                getClientProofSetsWithDetails: async () => []
            };
            try {
                await StorageService.create(mockSynapse, mockPandoraService, {
                    providerAddress: '0x6666666666666666666666666666666666666666'
                });
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'is not currently approved');
            }
        });
        it('should filter by CDN setting in smart selection', async () => {
            const mockProviders = [
                {
                    owner: '0x7777777777777777777777777777777777777777',
                    pdpUrl: 'https://pdp7.example.com',
                    pieceRetrievalUrl: 'https://retrieve7.example.com',
                    registeredAt: 1234567900,
                    approvedAt: 1234567901
                }
            ];
            const mockProofSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProviders[0].owner,
                    pdpVerifierProofSetId: 200,
                    nextRootId: 5,
                    currentRootCount: 5,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 1
                },
                {
                    railId: 2,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProviders[0].owner,
                    pdpVerifierProofSetId: 201,
                    nextRootId: 3,
                    currentRootCount: 3,
                    isLive: true,
                    isManaged: true,
                    withCDN: true,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 2
                }
            ];
            const mockPandoraService = {
                getClientProofSetsWithDetails: async () => mockProofSets,
                getProviderIdByAddress: async () => 7,
                getApprovedProvider: async () => mockProviders[0],
                getAllApprovedProviders: async () => mockProviders
            };
            const originalFetch = global.fetch;
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes('/ping')) {
                    return { status: 200, statusText: 'OK' };
                }
                throw new Error(`Unexpected URL: ${url}`);
            };
            try {
                const serviceNoCDN = await StorageService.create(mockSynapse, mockPandoraService, { withCDN: false });
                assert.equal(serviceNoCDN.proofSetId, '200', 'Should select non-CDN proof set');
                const serviceWithCDN = await StorageService.create(mockSynapse, mockPandoraService, { withCDN: true });
                assert.equal(serviceWithCDN.proofSetId, '201', 'Should select CDN proof set');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it.skip('should handle proof sets not managed by current Pandora', async () => {
            const mockProofSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0x8888888888888888888888888888888888888888',
                    pdpVerifierProofSetId: 300,
                    nextRootId: 0,
                    currentRootCount: 0,
                    isLive: true,
                    isManaged: false,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 1
                }
            ];
            const mockPandoraService = {
                getClientProofSetsWithDetails: async () => mockProofSets,
                getAllApprovedProviders: async () => [{
                        owner: '0x9999999999999999999999999999999999999999',
                        pdpUrl: 'https://pdp9.example.com',
                        pieceRetrievalUrl: 'https://retrieve9.example.com',
                        registeredAt: 1234567902,
                        approvedAt: 1234567903
                    }],
                getNextClientDataSetId: async () => 1
            };
            const service = await StorageService.create(mockSynapse, mockPandoraService, {});
            assert.exists(service.storageProvider);
            assert.notEqual(service.storageProvider, mockProofSets[0].payee);
        });
        it('should throw when proof set belongs to non-approved provider', async () => {
            const mockProofSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
                    pdpVerifierProofSetId: 400,
                    nextRootId: 0,
                    currentRootCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 1
                }
            ];
            const mockPandoraService = {
                getClientProofSetsWithDetails: async () => mockProofSets,
                getProviderIdByAddress: async () => 0
            };
            try {
                await StorageService.create(mockSynapse, mockPandoraService, { proofSetId: 400 });
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'is not currently approved');
            }
        });
        it.skip('should create new proof set when none exist for provider', async () => {
            const mockProvider = {
                owner: '0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',
                pdpUrl: 'https://pdp-b.example.com',
                pieceRetrievalUrl: 'https://retrieve-b.example.com',
                registeredAt: 1234567904,
                approvedAt: 1234567905
            };
            const mockPandoraService = {
                getApprovedProvider: async () => mockProvider,
                getClientProofSetsWithDetails: async () => [],
                getProviderIdByAddress: async () => 11,
                getNextClientDataSetId: async () => 1
            };
            const service = await StorageService.create(mockSynapse, mockPandoraService, {
                providerId: 11
            });
            assert.equal(service.storageProvider, mockProvider.owner);
        });
        it.skip('should validate parallel fetching in resolveByProviderId', async () => {
            let getApprovedProviderCalled = false;
            let getClientProofSetsCalled = false;
            const callOrder = [];
            const mockProvider = {
                owner: '0xcccccccccccccccccccccccccccccccccccccccc',
                pdpUrl: 'https://pdp-c.example.com',
                pieceRetrievalUrl: 'https://retrieve-c.example.com',
                registeredAt: 1234567906,
                approvedAt: 1234567907
            };
            const mockPandoraService = {
                getApprovedProvider: async () => {
                    callOrder.push('getApprovedProvider-start');
                    getApprovedProviderCalled = true;
                    await new Promise(resolve => setTimeout(resolve, 10));
                    callOrder.push('getApprovedProvider-end');
                    return mockProvider;
                },
                getClientProofSetsWithDetails: async () => {
                    callOrder.push('getClientProofSetsWithDetails-start');
                    getClientProofSetsCalled = true;
                    await new Promise(resolve => setTimeout(resolve, 10));
                    callOrder.push('getClientProofSetsWithDetails-end');
                    return [];
                },
                getNextClientDataSetId: async () => 1
            };
            await StorageService.create(mockSynapse, mockPandoraService, { providerId: 12 });
            assert.isTrue(getApprovedProviderCalled);
            assert.isTrue(getClientProofSetsCalled);
            const providerStartIndex = callOrder.indexOf('getApprovedProvider-start');
            const proofSetsStartIndex = callOrder.indexOf('getClientProofSetsWithDetails-start');
            const providerEndIndex = callOrder.indexOf('getApprovedProvider-end');
            assert.isBelow(providerStartIndex, providerEndIndex);
            assert.isBelow(proofSetsStartIndex, providerEndIndex);
        });
        it('should use progressive loading in smart selection', async () => {
            let getClientProofSetsCalled = false;
            let getAllApprovedProvidersCalled = false;
            const mockProvider = {
                owner: '0xdddddddddddddddddddddddddddddddddddddddd',
                pdpUrl: 'https://pdp-d.example.com',
                pieceRetrievalUrl: 'https://retrieve-d.example.com',
                registeredAt: 1234567908,
                approvedAt: 1234567909
            };
            const mockProofSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: mockProvider.owner,
                    pdpVerifierProofSetId: 500,
                    nextRootId: 2,
                    currentRootCount: 2,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 1
                }
            ];
            const mockPandoraService = {
                getClientProofSetsWithDetails: async () => {
                    getClientProofSetsCalled = true;
                    return mockProofSets;
                },
                getProviderIdByAddress: async () => 13,
                getApprovedProvider: async () => mockProvider,
                getAllApprovedProviders: async () => {
                    getAllApprovedProvidersCalled = true;
                    throw new Error('Should not fetch all providers when proof sets exist');
                }
            };
            const originalFetch = global.fetch;
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes('/ping')) {
                    return { status: 200, statusText: 'OK' };
                }
                throw new Error(`Unexpected URL: ${url}`);
            };
            try {
                const service = await StorageService.create(mockSynapse, mockPandoraService, {});
                assert.isTrue(getClientProofSetsCalled, 'Should fetch client proof sets');
                assert.isFalse(getAllApprovedProvidersCalled, 'Should NOT fetch all providers');
                assert.equal(service.proofSetId, '500');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it.skip('should fetch all providers only when no proof sets exist', async () => {
            let getAllApprovedProvidersCalled = false;
            const mockProviders = [
                {
                    owner: '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee',
                    pdpUrl: 'https://pdp-e.example.com',
                    pieceRetrievalUrl: 'https://retrieve-e.example.com',
                    registeredAt: 1234567910,
                    approvedAt: 1234567911
                }
            ];
            const mockPandoraService = {
                getClientProofSetsWithDetails: async () => [],
                getAllApprovedProviders: async () => {
                    getAllApprovedProvidersCalled = true;
                    return mockProviders;
                },
                getNextClientDataSetId: async () => 1
            };
            await StorageService.create(mockSynapse, mockPandoraService, {});
            assert.isTrue(getAllApprovedProvidersCalled, 'Should fetch all providers when no proof sets');
        });
        it('should handle proof set not live', async () => {
            const mockProofSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0xffffffffffffffffffffffffffffffffffffffffffff',
                    pdpVerifierProofSetId: 600,
                    nextRootId: 0,
                    currentRootCount: 0,
                    isLive: false,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 1
                }
            ];
            const mockPandoraService = {
                getClientProofSetsWithDetails: async () => mockProofSets
            };
            try {
                await StorageService.create(mockSynapse, mockPandoraService, { proofSetId: 600 });
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'Proof set 600 not found');
            }
        });
        it('should handle conflict between proofSetId and providerAddress', async () => {
            const mockProofSets = [
                {
                    railId: 1,
                    payer: '0x1234567890123456789012345678901234567890',
                    payee: '0x1111222233334444555566667777888899990000',
                    pdpVerifierProofSetId: 700,
                    nextRootId: 0,
                    currentRootCount: 0,
                    isLive: true,
                    isManaged: true,
                    withCDN: false,
                    commissionBps: 0,
                    metadata: '',
                    rootMetadata: [],
                    clientDataSetId: 1
                }
            ];
            const mockPandoraService = {
                getClientProofSetsWithDetails: async () => mockProofSets
            };
            try {
                await StorageService.create(mockSynapse, mockPandoraService, {
                    proofSetId: 700,
                    providerAddress: '0x9999888877776666555544443333222211110000'
                });
                assert.fail('Should have thrown error');
            }
            catch (error) {
                assert.include(error.message, 'belongs to provider');
                assert.include(error.message, 'but provider');
                assert.include(error.message, 'was requested');
            }
        });
        it.skip('should retry transaction fetch for up to 30 seconds', async () => {
        });
        it.skip('should fail after 30 seconds if transaction never appears', async () => {
        });
    });
    describe('preflightUpload', () => {
        it('should calculate costs without CDN', async () => {
            const mockPandoraService = {
                checkAllowanceForStorage: async () => ({
                    rateAllowanceNeeded: BigInt(100),
                    lockupAllowanceNeeded: BigInt(2880000),
                    currentRateAllowance: BigInt(1000000),
                    currentLockupAllowance: BigInt(10000000),
                    currentRateUsed: BigInt(0),
                    currentLockupUsed: BigInt(0),
                    sufficient: true,
                    message: undefined,
                    costs: {
                        perEpoch: BigInt(100),
                        perDay: BigInt(28800),
                        perMonth: BigInt(864000)
                    }
                })
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const preflight = await service.preflightUpload(1024 * 1024);
            assert.equal(preflight.estimatedCost.perEpoch, BigInt(100));
            assert.equal(preflight.estimatedCost.perDay, BigInt(28800));
            assert.equal(preflight.estimatedCost.perMonth, BigInt(864000));
            assert.isTrue(preflight.allowanceCheck.sufficient);
            assert.isUndefined(preflight.allowanceCheck.message);
            assert.equal(preflight.selectedProvider.owner, mockProvider.owner);
            assert.equal(preflight.selectedProofSetId, 123);
        });
        it('should calculate costs with CDN', async () => {
            const mockPandoraService = {
                checkAllowanceForStorage: async () => ({
                    rateAllowanceNeeded: BigInt(200),
                    lockupAllowanceNeeded: BigInt(5760000),
                    currentRateAllowance: BigInt(1000000),
                    currentLockupAllowance: BigInt(10000000),
                    currentRateUsed: BigInt(0),
                    currentLockupUsed: BigInt(0),
                    sufficient: true,
                    message: undefined,
                    costs: {
                        perEpoch: BigInt(200),
                        perDay: BigInt(57600),
                        perMonth: BigInt(1728000)
                    }
                })
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: true });
            const preflight = await service.preflightUpload(1024 * 1024);
            assert.equal(preflight.estimatedCost.perEpoch, BigInt(200));
            assert.equal(preflight.estimatedCost.perDay, BigInt(57600));
            assert.equal(preflight.estimatedCost.perMonth, BigInt(1728000));
            assert.isTrue(preflight.allowanceCheck.sufficient);
        });
        it('should handle insufficient allowances', async () => {
            const mockPandoraService = {
                checkAllowanceForStorage: async () => ({
                    rateAllowanceNeeded: BigInt(2000000),
                    lockupAllowanceNeeded: BigInt(20000000),
                    currentRateAllowance: BigInt(1000000),
                    currentLockupAllowance: BigInt(10000000),
                    currentRateUsed: BigInt(0),
                    currentLockupUsed: BigInt(0),
                    sufficient: false,
                    message: 'Rate allowance insufficient: current 1000000, need 2000000. Lockup allowance insufficient: current 10000000, need 20000000',
                    costs: {
                        perEpoch: BigInt(100),
                        perDay: BigInt(28800),
                        perMonth: BigInt(864000)
                    }
                })
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const preflight = await service.preflightUpload(100 * 1024 * 1024);
            assert.isFalse(preflight.allowanceCheck.sufficient);
            assert.include(preflight.allowanceCheck.message, 'Rate allowance insufficient');
            assert.include(preflight.allowanceCheck.message, 'Lockup allowance insufficient');
        });
        it('should enforce minimum size limit in preflightUpload', async () => {
            const mockPandoraService = {};
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            try {
                await service.preflightUpload(64);
                assert.fail('Should have thrown size limit error');
            }
            catch (error) {
                assert.include(error.message, 'below minimum allowed size');
                assert.include(error.message, '64 bytes');
                assert.include(error.message, '65 bytes');
            }
        });
        it('should enforce maximum size limit in preflightUpload', async () => {
            const mockPandoraService = {};
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            try {
                await service.preflightUpload(210 * 1024 * 1024);
                assert.fail('Should have thrown size limit error');
            }
            catch (error) {
                assert.include(error.message, 'exceeds maximum allowed size');
                assert.include(error.message, '220200960');
                assert.include(error.message, '209715200');
            }
        });
    });
    describe('download', () => {
        it('should download and verify a piece', async () => {
            const testData = new Uint8Array(65).fill(42);
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            const mockSynapseWithDownload = {
                ...mockSynapse,
                download: async (commp, options) => {
                    assert.equal(commp, testCommP);
                    assert.equal(options?.providerAddress, mockProvider.owner);
                    assert.equal(options?.withCDN, false);
                    return testData;
                }
            };
            const mockPandoraService = {};
            const service = new StorageService(mockSynapseWithDownload, mockPandoraService, mockProvider, 123, { withCDN: false });
            const downloaded = await service.download(testCommP);
            assert.deepEqual(downloaded, testData);
        });
        it('should handle download errors', async () => {
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            const mockSynapseWithError = {
                ...mockSynapse,
                download: async () => {
                    throw new Error('Network error');
                }
            };
            const mockPandoraService = {};
            const service = new StorageService(mockSynapseWithError, mockPandoraService, mockProvider, 123, { withCDN: false });
            try {
                await service.download(testCommP);
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.equal(error.message, 'Network error');
            }
        });
        it('should accept empty download options', async () => {
            const testData = new Uint8Array(65).fill(42);
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            const mockSynapseWithOptions = {
                ...mockSynapse,
                download: async (commp, options) => {
                    assert.equal(commp, testCommP);
                    assert.equal(options?.providerAddress, mockProvider.owner);
                    assert.equal(options?.withCDN, false);
                    return testData;
                }
            };
            const mockPandoraService = {};
            const service = new StorageService(mockSynapseWithOptions, mockPandoraService, mockProvider, 123, { withCDN: false });
            const downloaded1 = await service.download(testCommP);
            assert.deepEqual(downloaded1, testData);
            const downloaded2 = await service.download(testCommP, {});
            assert.deepEqual(downloaded2, testData);
        });
    });
    describe('upload', () => {
        it('should enforce 65 byte minimum size limit', async () => {
            const mockPandoraService = {};
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const undersizedData = new Uint8Array(64);
            try {
                await service.upload(undersizedData);
                assert.fail('Should have thrown size limit error');
            }
            catch (error) {
                assert.include(error.message, 'below minimum allowed size');
                assert.include(error.message, '64 bytes');
                assert.include(error.message, '65 bytes');
            }
        });
        it('should enforce 200 MiB size limit', async () => {
            const mockPandoraService = {};
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const oversizedData = new Uint8Array(210 * 1024 * 1024);
            try {
                await service.upload(oversizedData);
                assert.fail('Should have thrown size limit error');
            }
            catch (error) {
                assert.include(error.message, 'exceeds maximum allowed size');
                assert.include(error.message, '220200960');
                assert.include(error.message, '209715200');
            }
        });
        it('should accept data at exactly 65 bytes', async () => {
            const mockPandoraService = {
                getAddRootsInfo: async () => ({
                    nextRootId: 0,
                    clientDataSetId: 1,
                    currentRootCount: 0
                })
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const minSizeData = new Uint8Array(65);
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async (data) => {
                assert.equal(data.length, 65);
                return { commP: testCommP, size: data.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            serviceAny._pdpServer.addRoots = async () => {
                return { message: 'success' };
            };
            const result = await service.upload(minSizeData);
            assert.equal(result.commp.toString(), testCommP);
            assert.equal(result.size, 65);
        });
        it('should accept data up to 200 MiB', async () => {
            const mockPandoraService = {
                getAddRootsInfo: async () => ({
                    nextRootId: 0,
                    clientDataSetId: 1,
                    currentRootCount: 0
                })
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const maxSizeData = new Uint8Array(200 * 1024 * 1024);
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async (data) => {
                assert.equal(data.length, 200 * 1024 * 1024);
                return { commP: testCommP, size: data.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            serviceAny._pdpServer.addRoots = async () => {
                return { message: 'success' };
            };
            const result = await service.upload(maxSizeData);
            assert.equal(result.commp.toString(), testCommP);
            assert.equal(result.size, 200 * 1024 * 1024);
            assert.equal(result.rootId, 0);
        });
        it('should handle upload callbacks correctly', async () => {
            const mockPandoraService = {
                getAddRootsInfo: async () => ({
                    nextRootId: 0,
                    clientDataSetId: 1,
                    currentRootCount: 0
                })
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const testData = new Uint8Array(65).fill(42);
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            let uploadCompleteCallbackFired = false;
            let rootAddedCallbackFired = false;
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { commP: testCommP, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            serviceAny._pdpServer.addRoots = async () => {
                return { message: 'success' };
            };
            const result = await service.upload(testData, {
                onUploadComplete: (commp) => {
                    assert.equal(commp.toString(), testCommP);
                    uploadCompleteCallbackFired = true;
                },
                onRootAdded: () => {
                    rootAddedCallbackFired = true;
                }
            });
            assert.isTrue(uploadCompleteCallbackFired, 'onUploadComplete should have been called');
            assert.isTrue(rootAddedCallbackFired, 'onRootAdded should have been called');
            assert.equal(result.commp.toString(), testCommP);
        });
        it('should handle new server with transaction tracking', async () => {
            const mockPandoraService = {
                getAddRootsInfo: async () => ({
                    nextRootId: 0,
                    clientDataSetId: 1,
                    currentRootCount: 0
                })
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const testData = new Uint8Array(65).fill(42);
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            let uploadCompleteCallbackFired = false;
            let rootAddedCallbackFired = false;
            let rootConfirmedCallbackFired = false;
            let rootAddedTransaction = null;
            let confirmedRootIds = [];
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { commP: testCommP, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            serviceAny._pdpServer.addRoots = async () => {
                return {
                    message: 'success',
                    txHash: mockTxHash,
                    statusUrl: `https://pdp.example.com/pdp/proof-sets/123/roots/added/${mockTxHash}`
                };
            };
            const mockTransaction = {
                hash: mockTxHash,
                wait: async () => ({ status: 1 })
            };
            const originalGetTransaction = mockEthProvider.getTransaction;
            mockEthProvider.getTransaction = async (hash) => {
                assert.equal(hash, mockTxHash);
                return mockTransaction;
            };
            serviceAny._pdpServer.getRootAdditionStatus = async (proofSetId, txHash) => {
                assert.equal(proofSetId, 123);
                assert.equal(txHash, mockTxHash);
                return {
                    txHash: mockTxHash,
                    txStatus: 'confirmed',
                    proofSetId: 123,
                    rootCount: 1,
                    addMessageOk: true,
                    confirmedRootIds: [42]
                };
            };
            try {
                const result = await service.upload(testData, {
                    onUploadComplete: (commp) => {
                        assert.equal(commp.toString(), testCommP);
                        uploadCompleteCallbackFired = true;
                    },
                    onRootAdded: (transaction) => {
                        rootAddedCallbackFired = true;
                        rootAddedTransaction = transaction;
                    },
                    onRootConfirmed: (rootIds) => {
                        rootConfirmedCallbackFired = true;
                        confirmedRootIds = rootIds;
                    }
                });
                assert.isTrue(uploadCompleteCallbackFired, 'onUploadComplete should have been called');
                assert.isTrue(rootAddedCallbackFired, 'onRootAdded should have been called');
                assert.isTrue(rootConfirmedCallbackFired, 'onRootConfirmed should have been called');
                assert.exists(rootAddedTransaction, 'Transaction should be passed to onRootAdded');
                assert.equal(rootAddedTransaction.hash, mockTxHash);
                assert.deepEqual(confirmedRootIds, [42]);
                assert.equal(result.rootId, 42);
            }
            finally {
                mockEthProvider.getTransaction = originalGetTransaction;
            }
        });
        it.skip('should fail if new server transaction is not found on-chain', async function () {
            const mockPandoraService = {
                getAddRootsInfo: async () => ({
                    nextRootId: 0,
                    clientDataSetId: 1,
                    currentRootCount: 0
                })
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const testData = new Uint8Array(65).fill(42);
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { commP: testCommP, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            serviceAny._pdpServer.addRoots = async () => {
                return {
                    message: 'success',
                    txHash: mockTxHash,
                    statusUrl: `https://pdp.example.com/pdp/proof-sets/123/roots/added/${mockTxHash}`
                };
            };
            const originalGetTransaction = mockEthProvider.getTransaction;
            mockEthProvider.getTransaction = async () => null;
            try {
                await service.upload(testData);
                assert.fail('Should have thrown error for transaction not found');
            }
            catch (error) {
                assert.include(error.message, 'StorageService addRoots failed:');
                assert.include(error.message, 'Server returned transaction hash');
                assert.include(error.message, 'but transaction was not found on-chain');
            }
            finally {
                mockEthProvider.getTransaction = originalGetTransaction;
            }
        });
        it.skip('should fail if new server verification fails', async function () {
            const mockPandoraService = {
                getAddRootsInfo: async () => ({
                    nextRootId: 0,
                    clientDataSetId: 1,
                    currentRootCount: 0
                })
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const testData = new Uint8Array(65).fill(42);
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { commP: testCommP, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            serviceAny._pdpServer.addRoots = async () => {
                return {
                    message: 'success',
                    txHash: mockTxHash,
                    statusUrl: `https://pdp.example.com/pdp/proof-sets/123/roots/added/${mockTxHash}`
                };
            };
            const mockTransaction = {
                hash: mockTxHash,
                wait: async () => ({ status: 1 })
            };
            const originalGetTransaction = mockEthProvider.getTransaction;
            mockEthProvider.getTransaction = async () => mockTransaction;
            serviceAny._pdpServer.getRootAdditionStatus = async () => {
                throw new Error('Root addition status not found');
            };
            try {
                await service.upload(testData);
                assert.fail('Should have thrown error for verification failure');
            }
            catch (error) {
                assert.include(error.message, 'StorageService addRoots failed:');
                assert.include(error.message, 'Failed to verify root addition');
                assert.include(error.message, 'The transaction was confirmed on-chain but the server failed to acknowledge it');
            }
            finally {
                mockEthProvider.getTransaction = originalGetTransaction;
            }
        });
        it('should handle transaction failure on-chain', async () => {
            const mockPandoraService = {
                getAddRootsInfo: async () => ({
                    nextRootId: 0,
                    clientDataSetId: 1,
                    currentRootCount: 0
                })
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const testData = new Uint8Array(65).fill(42);
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            const mockTxHash = '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { commP: testCommP, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            serviceAny._pdpServer.addRoots = async () => {
                return {
                    message: 'success',
                    txHash: mockTxHash,
                    statusUrl: `https://pdp.example.com/pdp/proof-sets/123/roots/added/${mockTxHash}`
                };
            };
            const mockTransaction = {
                hash: mockTxHash,
                wait: async () => ({ status: 0 })
            };
            const originalGetTransaction = mockEthProvider.getTransaction;
            mockEthProvider.getTransaction = async () => mockTransaction;
            try {
                await service.upload(testData);
                assert.fail('Should have thrown error for failed transaction');
            }
            catch (error) {
                assert.include(error.message, 'StorageService addRoots failed:');
                assert.include(error.message, 'Failed to add root to proof set');
            }
            finally {
                mockEthProvider.getTransaction = originalGetTransaction;
            }
        });
        it('should work with old servers that do not provide transaction tracking', async () => {
            const mockPandoraService = {
                getAddRootsInfo: async () => ({
                    nextRootId: 0,
                    clientDataSetId: 1,
                    currentRootCount: 0
                })
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const testData = new Uint8Array(65).fill(42);
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            let rootAddedCallbackFired = false;
            let rootAddedTransaction;
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { commP: testCommP, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            serviceAny._pdpServer.addRoots = async () => {
                return { message: 'success' };
            };
            const result = await service.upload(testData, {
                onRootAdded: (transaction) => {
                    rootAddedCallbackFired = true;
                    rootAddedTransaction = transaction;
                }
            });
            assert.isTrue(rootAddedCallbackFired, 'onRootAdded should have been called');
            assert.isUndefined(rootAddedTransaction, 'Transaction should be undefined for old servers');
            assert.equal(result.rootId, 0);
        });
        it('should handle ArrayBuffer input', async () => {
            const mockPandoraService = {
                getAddRootsInfo: async () => ({
                    nextRootId: 0,
                    clientDataSetId: 1,
                    currentRootCount: 0
                })
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const buffer = new ArrayBuffer(1024);
            const view = new Uint8Array(buffer);
            for (let i = 0; i < view.length; i++) {
                view[i] = i % 256;
            }
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async (data) => {
                assert.instanceOf(data, Uint8Array);
                assert.equal(data.length, 1024);
                return { commP: testCommP, size: data.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            serviceAny._pdpServer.addRoots = async () => {
                return { message: 'success' };
            };
            const result = await service.upload(buffer);
            assert.equal(result.commp.toString(), testCommP);
            assert.equal(result.size, 1024);
        });
        it.skip('should handle piece parking timeout', async () => {
            const mockPandoraService = {};
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const testData = new Uint8Array(65).fill(42);
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { commP: testCommP, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                throw new Error('Piece not found');
            };
            const originalTimeout = service.constructor.PIECE_PARKING_TIMEOUT_MS;
            Object.defineProperty(service.constructor, 'PIECE_PARKING_TIMEOUT_MS', {
                value: 100,
                configurable: true
            });
            try {
                await service.upload(testData);
                assert.fail('Should have thrown timeout error');
            }
            catch (error) {
                assert.include(error.message, 'Timeout waiting for piece to be parked');
            }
            finally {
                Object.defineProperty(service.constructor, 'PIECE_PARKING_TIMEOUT_MS', {
                    value: originalTimeout,
                    configurable: true
                });
            }
        });
        it('should handle upload piece failure', async () => {
            const mockPandoraService = {};
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const testData = new Uint8Array(65).fill(42);
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                throw new Error('Network error during upload');
            };
            try {
                await service.upload(testData);
                assert.fail('Should have thrown upload error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to upload piece to storage provider');
            }
        });
        it('should handle add roots failure', async () => {
            const mockPandoraService = {
                getAddRootsInfo: async () => ({
                    nextRootId: 0,
                    clientDataSetId: 1,
                    currentRootCount: 0
                })
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const testData = new Uint8Array(65).fill(42);
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { commP: testCommP, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            serviceAny._pdpServer.addRoots = async () => {
                throw new Error('Signature validation failed');
            };
            try {
                await service.upload(testData);
                assert.fail('Should have thrown add roots error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to add root to proof set');
            }
        });
        it('should handle getAddRootsInfo failure', async () => {
            const mockPandoraService = {
                getAddRootsInfo: async () => {
                    throw new Error('Proof set not managed by this Pandora');
                }
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const testData = new Uint8Array(65).fill(42);
            const testCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
            const serviceAny = service;
            serviceAny._pdpServer.uploadPiece = async () => {
                return { commP: testCommP, size: testData.length };
            };
            serviceAny._pdpServer.findPiece = async () => {
                return { uuid: 'test-uuid' };
            };
            try {
                await service.upload(testData);
                assert.fail('Should have thrown getAddRootsInfo error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to add root to proof set');
            }
        });
    });
    describe('Provider Ping Validation', () => {
        describe('selectRandomProvider with ping validation', () => {
            it('should select first provider that responds to ping', async () => {
                const testProviders = [
                    {
                        owner: '0x1111111111111111111111111111111111111111',
                        pdpUrl: 'https://pdp1.example.com',
                        pieceRetrievalUrl: 'https://retrieve1.example.com',
                        registeredAt: 1234567890,
                        approvedAt: 1234567891
                    },
                    {
                        owner: '0x2222222222222222222222222222222222222222',
                        pdpUrl: 'https://pdp2.example.com',
                        pieceRetrievalUrl: 'https://retrieve2.example.com',
                        registeredAt: 1234567892,
                        approvedAt: 1234567893
                    }
                ];
                let pingCallCount = 0;
                const originalFetch = global.fetch;
                global.fetch = async (input) => {
                    const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                    if (url.includes('/ping')) {
                        pingCallCount++;
                        if (url.includes('pdp1.example.com')) {
                            return { status: 500, statusText: 'Internal Server Error', text: async () => 'Down' };
                        }
                        else if (url.includes('pdp2.example.com')) {
                            return { status: 200, statusText: 'OK' };
                        }
                    }
                    throw new Error(`Unexpected URL: ${url}`);
                };
                try {
                    const result = await StorageService.selectRandomProvider(testProviders, mockSynapse.getSigner(), [], true);
                    assert.equal(result.owner, testProviders[1].owner);
                    assert.isAtLeast(pingCallCount, 1, 'Should have called ping at least once');
                }
                finally {
                    global.fetch = originalFetch;
                }
            });
            it('should exclude providers from selection', async () => {
                const testProviders = [
                    {
                        owner: '0x1111111111111111111111111111111111111111',
                        pdpUrl: 'https://pdp1.example.com',
                        pieceRetrievalUrl: 'https://retrieve1.example.com',
                        registeredAt: 1234567890,
                        approvedAt: 1234567891
                    },
                    {
                        owner: '0x2222222222222222222222222222222222222222',
                        pdpUrl: 'https://pdp2.example.com',
                        pieceRetrievalUrl: 'https://retrieve2.example.com',
                        registeredAt: 1234567892,
                        approvedAt: 1234567893
                    }
                ];
                const originalFetch = global.fetch;
                global.fetch = async (input) => {
                    const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                    if (url.includes('/ping')) {
                        assert.isTrue(url.includes('pdp2.example.com'), 'Should only ping non-excluded provider');
                        return { status: 200, statusText: 'OK' };
                    }
                    throw new Error(`Unexpected URL: ${url}`);
                };
                try {
                    const result = await StorageService.selectRandomProvider(testProviders, mockSynapse.getSigner(), [testProviders[0].owner], true);
                    assert.equal(result.owner, testProviders[1].owner);
                }
                finally {
                    global.fetch = originalFetch;
                }
            });
            it('should throw error when all providers fail ping', async () => {
                const testProviders = [
                    {
                        owner: '0x1111111111111111111111111111111111111111',
                        pdpUrl: 'https://pdp1.example.com',
                        pieceRetrievalUrl: 'https://retrieve1.example.com',
                        registeredAt: 1234567890,
                        approvedAt: 1234567891
                    },
                    {
                        owner: '0x2222222222222222222222222222222222222222',
                        pdpUrl: 'https://pdp2.example.com',
                        pieceRetrievalUrl: 'https://retrieve2.example.com',
                        registeredAt: 1234567892,
                        approvedAt: 1234567893
                    }
                ];
                const originalFetch = global.fetch;
                global.fetch = async () => {
                    return {
                        status: 500,
                        statusText: 'Internal Server Error',
                        text: async () => 'All servers down'
                    };
                };
                try {
                    await StorageService.selectRandomProvider(testProviders, mockSynapse.getSigner());
                    assert.fail('Should have thrown error');
                }
                catch (error) {
                    assert.include(error.message, 'All 2 available storage providers failed ping validation');
                }
                finally {
                    global.fetch = originalFetch;
                }
            });
        });
        describe('smartSelectProvider with ping validation', () => {
            it('should fail when existing providers fail ping validation', async () => {
                const testProviders = [
                    {
                        owner: '0x1111111111111111111111111111111111111111',
                        pdpUrl: 'https://pdp1.example.com',
                        pieceRetrievalUrl: 'https://retrieve1.example.com',
                        registeredAt: 1234567890,
                        approvedAt: 1234567891
                    },
                    {
                        owner: '0x2222222222222222222222222222222222222222',
                        pdpUrl: 'https://pdp2.example.com',
                        pieceRetrievalUrl: 'https://retrieve2.example.com',
                        registeredAt: 1234567892,
                        approvedAt: 1234567893
                    }
                ];
                const proofSets = [
                    {
                        railId: 1,
                        payer: '0x1234567890123456789012345678901234567890',
                        payee: testProviders[0].owner,
                        pdpVerifierProofSetId: 100,
                        nextRootId: 0,
                        currentRootCount: 0,
                        isLive: true,
                        isManaged: true,
                        withCDN: false,
                        commissionBps: 0,
                        metadata: '',
                        rootMetadata: [],
                        clientDataSetId: 1
                    }
                ];
                const mockPandoraService = {
                    getClientProofSetsWithDetails: async () => proofSets,
                    getAllApprovedProviders: async () => testProviders,
                    getProviderIdByAddress: async (address) => {
                        const idx = testProviders.findIndex(p => p.owner.toLowerCase() === address.toLowerCase());
                        return idx >= 0 ? idx + 1 : 0;
                    },
                    getApprovedProvider: async (id) => testProviders[id - 1] ?? null
                };
                let pingCallCount = 0;
                const originalFetch = global.fetch;
                global.fetch = async (input) => {
                    const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                    if (url.includes('/ping')) {
                        pingCallCount++;
                        return { status: 500, statusText: 'Internal Server Error', text: async () => 'Down' };
                    }
                    throw new Error(`Unexpected URL: ${url}`);
                };
                try {
                    await StorageService.smartSelectProvider(mockPandoraService, '0x1234567890123456789012345678901234567890', false, mockSynapse.getSigner());
                    assert.fail('Should have thrown error');
                }
                catch (error) {
                    assert.include(error.message, 'All 1 available storage providers failed ping validation');
                    assert.isAtLeast(pingCallCount, 1, 'Should have pinged at least one provider');
                }
                finally {
                    global.fetch = originalFetch;
                }
            });
            it('should select new provider when no existing providers are available', async () => {
                const testProviders = [
                    {
                        owner: '0x1111111111111111111111111111111111111111',
                        pdpUrl: 'https://pdp1.example.com',
                        pieceRetrievalUrl: 'https://retrieve1.example.com',
                        registeredAt: 1234567890,
                        approvedAt: 1234567891
                    },
                    {
                        owner: '0x2222222222222222222222222222222222222222',
                        pdpUrl: 'https://pdp2.example.com',
                        pieceRetrievalUrl: 'https://retrieve2.example.com',
                        registeredAt: 1234567892,
                        approvedAt: 1234567893
                    }
                ];
                const mockPandoraService = {
                    getClientProofSetsWithDetails: async () => [],
                    getAllApprovedProviders: async () => testProviders,
                    getProviderIdByAddress: async () => 0,
                    getApprovedProvider: async () => null
                };
                let pingCallCount = 0;
                const originalFetch = global.fetch;
                global.fetch = async (input) => {
                    const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                    if (url.includes('/ping')) {
                        pingCallCount++;
                        if (url.includes('pdp1.example.com')) {
                            return { status: 200, statusText: 'OK' };
                        }
                        return { status: 500, statusText: 'Internal Server Error' };
                    }
                    throw new Error(`Unexpected URL: ${url}`);
                };
                try {
                    const result = await StorageService.smartSelectProvider(mockPandoraService, '0x1234567890123456789012345678901234567890', false, mockSynapse.getSigner());
                    assert.isTrue(testProviders.some(p => p.owner === result.provider.owner), 'Should have selected one of the available providers');
                    assert.equal(result.proofSetId, -1);
                    assert.isFalse(result.isExisting);
                    assert.isAtLeast(pingCallCount, 1, 'Should have pinged at least one provider');
                }
                finally {
                    global.fetch = originalFetch;
                }
            });
            it('should use existing provider if ping succeeds', async () => {
                const testProvider = {
                    owner: '0x1111111111111111111111111111111111111111',
                    pdpUrl: 'https://pdp1.example.com',
                    pieceRetrievalUrl: 'https://retrieve1.example.com',
                    registeredAt: 1234567890,
                    approvedAt: 1234567891
                };
                const proofSets = [
                    {
                        railId: 1,
                        payer: '0x1234567890123456789012345678901234567890',
                        payee: testProvider.owner,
                        pdpVerifierProofSetId: 100,
                        nextRootId: 0,
                        currentRootCount: 5,
                        isLive: true,
                        isManaged: true,
                        withCDN: false,
                        commissionBps: 0,
                        metadata: '',
                        rootMetadata: [],
                        clientDataSetId: 1
                    }
                ];
                const mockPandoraService = {
                    getClientProofSetsWithDetails: async () => proofSets,
                    getProviderIdByAddress: async () => 1,
                    getApprovedProvider: async () => testProvider,
                    getAllApprovedProviders: async () => []
                };
                const originalFetch = global.fetch;
                global.fetch = async (input) => {
                    const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                    if (url.includes('/ping')) {
                        return { status: 200, statusText: 'OK' };
                    }
                    throw new Error(`Unexpected URL: ${url}`);
                };
                try {
                    const result = await StorageService.smartSelectProvider(mockPandoraService, '0x1234567890123456789012345678901234567890', false, mockSynapse.getSigner());
                    assert.equal(result.provider.owner, testProvider.owner);
                    assert.equal(result.proofSetId, 100);
                    assert.isTrue(result.isExisting);
                }
                finally {
                    global.fetch = originalFetch;
                }
            });
        });
        describe('selectProviderWithPing', () => {
            it('should deduplicate providers from multiple proof sets', async () => {
                const testProvider = {
                    owner: '0x1111111111111111111111111111111111111111',
                    pdpUrl: 'https://pdp1.example.com',
                    pieceRetrievalUrl: 'https://retrieve1.example.com',
                    registeredAt: 1234567890,
                    approvedAt: 1234567891
                };
                const proofSets = [
                    {
                        railId: 1,
                        payer: '0x1234567890123456789012345678901234567890',
                        payee: testProvider.owner,
                        pdpVerifierProofSetId: 100,
                        nextRootId: 0,
                        currentRootCount: 5,
                        isLive: true,
                        isManaged: true,
                        withCDN: false,
                        commissionBps: 0,
                        metadata: '',
                        rootMetadata: [],
                        clientDataSetId: 1
                    },
                    {
                        railId: 2,
                        payer: '0x1234567890123456789012345678901234567890',
                        payee: testProvider.owner,
                        pdpVerifierProofSetId: 101,
                        nextRootId: 0,
                        currentRootCount: 3,
                        isLive: true,
                        isManaged: true,
                        withCDN: false,
                        commissionBps: 0,
                        metadata: '',
                        rootMetadata: [],
                        clientDataSetId: 2
                    },
                    {
                        railId: 3,
                        payer: '0x1234567890123456789012345678901234567890',
                        payee: testProvider.owner,
                        pdpVerifierProofSetId: 102,
                        nextRootId: 0,
                        currentRootCount: 1,
                        isLive: true,
                        isManaged: true,
                        withCDN: false,
                        commissionBps: 0,
                        metadata: '',
                        rootMetadata: [],
                        clientDataSetId: 3
                    }
                ];
                const mockPandoraService = {
                    getClientProofSetsWithDetails: async () => proofSets,
                    getProviderIdByAddress: async () => 1,
                    getApprovedProvider: async () => testProvider,
                    getAllApprovedProviders: async () => []
                };
                let pingCount = 0;
                const originalFetch = global.fetch;
                global.fetch = async (input) => {
                    const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                    if (url.includes('/ping')) {
                        pingCount++;
                        return { status: 500, statusText: 'Internal Server Error' };
                    }
                    throw new Error(`Unexpected URL: ${url}`);
                };
                try {
                    await StorageService.smartSelectProvider(mockPandoraService, '0x1234567890123456789012345678901234567890', false, mockSynapse.getSigner());
                    assert.fail('Should have thrown error');
                }
                catch (error) {
                    assert.equal(pingCount, 1, 'Should only ping each unique provider once');
                    assert.include(error.message, 'All 1 available storage providers failed ping validation');
                }
                finally {
                    global.fetch = originalFetch;
                }
            });
        });
    });
    describe('getProviderInfo', () => {
        it('should return provider info through Synapse', async () => {
            const mockPandoraService = {};
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const originalGetProviderInfo = mockSynapse.getProviderInfo;
            const expectedProviderInfo = {
                owner: mockProvider.owner,
                pdpUrl: 'https://updated-pdp.example.com',
                pieceRetrievalUrl: 'https://updated-retrieve.example.com',
                registeredAt: 1234567900,
                approvedAt: 1234567901
            };
            mockSynapse.getProviderInfo = async (address) => {
                assert.equal(address, mockProvider.owner);
                return expectedProviderInfo;
            };
            try {
                const providerInfo = await service.getProviderInfo();
                assert.deepEqual(providerInfo, expectedProviderInfo);
            }
            finally {
                mockSynapse.getProviderInfo = originalGetProviderInfo;
            }
        });
        it('should handle errors from Synapse getProviderInfo', async () => {
            const mockPandoraService = {};
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const originalGetProviderInfo = mockSynapse.getProviderInfo;
            mockSynapse.getProviderInfo = async () => {
                throw new Error('Provider not found');
            };
            try {
                await service.getProviderInfo();
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'Provider not found');
            }
            finally {
                mockSynapse.getProviderInfo = originalGetProviderInfo;
            }
        });
    });
    describe('getProofSetRoots', () => {
        it('should successfully fetch proof set roots', async () => {
            const mockPandoraService = {};
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const mockProofSetData = {
                id: 292,
                roots: [
                    {
                        rootId: 101,
                        rootCid: 'baga6ea4seaqh5lmkfwaovjuigyp4hzclc6hqnhoqcm3re3ipumhp3kfka7wdvjq',
                        subrootCid: 'baga6ea4seaqh5lmkfwaovjuigyp4hzclc6hqnhoqcm3re3ipumhp3kfka7wdvjq',
                        subrootOffset: 0
                    },
                    {
                        rootId: 102,
                        rootCid: 'baga6ea4seaqkt24j5gbf2ye2wual5gn7a5yl2tqb52v2sk4nvur4bdy7lg76cdy',
                        subrootCid: 'baga6ea4seaqkt24j5gbf2ye2wual5gn7a5yl2tqb52v2sk4nvur4bdy7lg76cdy',
                        subrootOffset: 0
                    }
                ],
                nextChallengeEpoch: 1500
            };
            const serviceAny = service;
            serviceAny._pdpServer.getProofSet = async (proofSetId) => {
                assert.equal(proofSetId, 123);
                return mockProofSetData;
            };
            const result = await service.getProofSetRoots();
            assert.isArray(result);
            assert.equal(result.length, 2);
            assert.equal(result[0].toString(), mockProofSetData.roots[0].rootCid);
            assert.equal(result[1].toString(), mockProofSetData.roots[1].rootCid);
        });
        it('should handle empty proof set roots', async () => {
            const mockPandoraService = {};
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const mockProofSetData = {
                id: 292,
                roots: [],
                nextChallengeEpoch: 1500
            };
            const serviceAny = service;
            serviceAny._pdpServer.getProofSet = async () => {
                return mockProofSetData;
            };
            const result = await service.getProofSetRoots();
            assert.isArray(result);
            assert.equal(result.length, 0);
        });
        it('should handle invalid CID in response', async () => {
            const mockPandoraService = {};
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const mockProofSetData = {
                id: 292,
                roots: [
                    {
                        rootId: 101,
                        rootCid: 'invalid-cid-format',
                        subrootCid: 'baga6ea4seaqh5lmkfwaovjuigyp4hzclc6hqnhoqcm3re3ipumhp3kfka7wdvjq',
                        subrootOffset: 0
                    }
                ],
                nextChallengeEpoch: 1500
            };
            const serviceAny = service;
            serviceAny._pdpServer.getProofSet = async () => {
                return mockProofSetData;
            };
            const result = await service.getProofSetRoots();
            assert.isArray(result);
            assert.equal(result.length, 1);
            assert.equal(result[0].toString(), 'invalid-cid-format');
        });
        it('should handle PDP server errors', async () => {
            const mockPandoraService = {};
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const serviceAny = service;
            serviceAny._pdpServer.getProofSet = async () => {
                throw new Error('Proof set not found: 999');
            };
            try {
                await service.getProofSetRoots();
                assert.fail('Should have thrown error for server error');
            }
            catch (error) {
                assert.include(error.message, 'Proof set not found: 999');
            }
        });
    });
    describe('pieceStatus()', () => {
        const mockCommP = 'baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq';
        it('should return exists=false when piece not found on provider', async () => {
            const mockPandoraService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => { throw new Error('Piece not found'); };
            serviceAny._pdpServer.getProofSet = async () => ({
                id: 123,
                roots: [],
                nextChallengeEpoch: 5000
            });
            const mockSynapseAny = mockSynapse;
            mockSynapseAny.payments.getCurrentEpoch = async () => BigInt(4000);
            mockSynapseAny.getNetwork = () => 'calibration';
            const status = await service.pieceStatus(mockCommP);
            assert.isFalse(status.exists);
            assert.isNull(status.retrievalUrl);
            assert.isNull(status.proofSetLastProven);
            assert.isNull(status.proofSetNextProofDue);
            assert.isUndefined(status.rootId);
        });
        it('should return piece status with proof timing when piece exists', async () => {
            const mockPandoraService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => ({ uuid: 'test-uuid' });
            serviceAny._pdpServer.getProofSet = async () => ({
                id: 123,
                roots: [{
                        rootId: 1,
                        rootCid: { toString: () => mockCommP }
                    }],
                nextChallengeEpoch: 5000
            });
            const mockSynapseAny = mockSynapse;
            mockSynapseAny.payments.getCurrentEpoch = async () => BigInt(4000);
            mockSynapseAny.getNetwork = () => 'calibration';
            mockSynapseAny.getProviderInfo = async () => mockProvider;
            const status = await service.pieceStatus(mockCommP);
            assert.isTrue(status.exists);
            assert.equal(status.retrievalUrl, 'https://retrieve.example.com/piece/' + mockCommP);
            assert.equal(status.rootId, 1);
            assert.isNotNull(status.proofSetLastProven);
            assert.isNotNull(status.proofSetNextProofDue);
            assert.isFalse(status.inChallengeWindow);
            assert.isFalse(status.isProofOverdue);
        });
        it('should detect when in challenge window', async () => {
            const mockPandoraService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => ({ uuid: 'test-uuid' });
            serviceAny._pdpServer.getProofSet = async () => ({
                id: 123,
                roots: [{
                        rootId: 1,
                        rootCid: { toString: () => mockCommP }
                    }],
                nextChallengeEpoch: 5000
            });
            const mockSynapseAny = mockSynapse;
            mockSynapseAny.payments.getCurrentEpoch = async () => BigInt(5030);
            mockSynapseAny.getNetwork = () => 'calibration';
            mockSynapseAny.getProviderInfo = async () => mockProvider;
            const status = await service.pieceStatus(mockCommP);
            assert.isTrue(status.exists);
            assert.isTrue(status.inChallengeWindow);
            assert.isFalse(status.isProofOverdue);
        });
        it('should detect when proof is overdue', async () => {
            const mockPandoraService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => ({ uuid: 'test-uuid' });
            serviceAny._pdpServer.getProofSet = async () => ({
                id: 123,
                roots: [{
                        rootId: 1,
                        rootCid: { toString: () => mockCommP }
                    }],
                nextChallengeEpoch: 5000
            });
            const mockSynapseAny = mockSynapse;
            mockSynapseAny.payments.getCurrentEpoch = async () => BigInt(5100);
            mockSynapseAny.getNetwork = () => 'calibration';
            mockSynapseAny.getProviderInfo = async () => mockProvider;
            const status = await service.pieceStatus(mockCommP);
            assert.isTrue(status.exists);
            assert.isFalse(status.inChallengeWindow);
            assert.isTrue(status.isProofOverdue);
        });
        it('should handle proof set with nextChallengeEpoch=0', async () => {
            const mockPandoraService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => ({ uuid: 'test-uuid' });
            serviceAny._pdpServer.getProofSet = async () => ({
                id: 123,
                roots: [{
                        rootId: 1,
                        rootCid: { toString: () => mockCommP }
                    }],
                nextChallengeEpoch: 0
            });
            const mockSynapseAny = mockSynapse;
            mockSynapseAny.payments.getCurrentEpoch = async () => BigInt(5000);
            mockSynapseAny.getNetwork = () => 'calibration';
            mockSynapseAny.getProviderInfo = async () => mockProvider;
            const status = await service.pieceStatus(mockCommP);
            assert.isTrue(status.exists);
            assert.isNull(status.proofSetLastProven);
            assert.isNull(status.proofSetNextProofDue);
            assert.isFalse(status.inChallengeWindow);
            assert.isFalse(status.isProofOverdue);
        });
        it('should handle trailing slash in retrieval URL', async () => {
            const mockProviderWithSlash = {
                ...mockProvider,
                pieceRetrievalUrl: 'https://retrieve.example.com/'
            };
            const mockPandoraService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProviderWithSlash, 123, { withCDN: false });
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => ({ uuid: 'test-uuid' });
            serviceAny._pdpServer.getProofSet = async () => ({
                id: 123,
                roots: [],
                nextChallengeEpoch: 5000
            });
            const mockSynapseAny = mockSynapse;
            mockSynapseAny.payments.getCurrentEpoch = async () => BigInt(4000);
            mockSynapseAny.getNetwork = () => 'calibration';
            mockSynapseAny.getProviderInfo = async (address) => {
                if (address === mockProviderWithSlash.owner) {
                    return mockProviderWithSlash;
                }
                throw new Error('Provider not found');
            };
            const status = await service.pieceStatus(mockCommP);
            assert.isTrue(status.exists);
            assert.equal(status.retrievalUrl, 'https://retrieve.example.com/piece/' + mockCommP);
            const urlWithoutProtocol = (status.retrievalUrl ?? '').substring(8);
            assert.notInclude(urlWithoutProtocol, '//');
        });
        it('should handle invalid CommP', async () => {
            const mockPandoraService = {};
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            try {
                await service.pieceStatus('invalid-commp');
                assert.fail('Should have thrown error for invalid CommP');
            }
            catch (error) {
                assert.include(error.message, 'Invalid CommP provided');
            }
        });
        it('should calculate hours until challenge window', async () => {
            const mockPandoraService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => ({ uuid: 'test-uuid' });
            serviceAny._pdpServer.getProofSet = async () => ({
                id: 123,
                roots: [{
                        rootId: 1,
                        rootCid: { toString: () => mockCommP }
                    }],
                nextChallengeEpoch: 5000
            });
            const mockSynapseAny = mockSynapse;
            mockSynapseAny.payments.getCurrentEpoch = async () => BigInt(4880);
            mockSynapseAny.getNetwork = () => 'calibration';
            mockSynapseAny.getProviderInfo = async () => mockProvider;
            const status = await service.pieceStatus(mockCommP);
            assert.isTrue(status.exists);
            assert.isFalse(status.inChallengeWindow);
            assert.isFalse(status.isProofOverdue);
            assert.approximately(status.hoursUntilChallengeWindow ?? 0, 1, 0.1);
        });
        it('should handle proof set data fetch failure gracefully', async () => {
            const mockPandoraService = {
                getMaxProvingPeriod: async () => 2880,
                getChallengeWindow: async () => 60
            };
            const service = new StorageService(mockSynapse, mockPandoraService, mockProvider, 123, { withCDN: false });
            const serviceAny = service;
            serviceAny._pdpServer.findPiece = async () => ({ uuid: 'test-uuid' });
            serviceAny._pdpServer.getProofSet = async () => { throw new Error('Network error'); };
            const mockSynapseAny = mockSynapse;
            mockSynapseAny.payments.getCurrentEpoch = async () => BigInt(4000);
            mockSynapseAny.getNetwork = () => 'calibration';
            mockSynapseAny.getProviderInfo = async () => mockProvider;
            const status = await service.pieceStatus(mockCommP);
            assert.isTrue(status.exists);
            assert.isNotNull(status.retrievalUrl);
            assert.isNull(status.proofSetLastProven);
            assert.isNull(status.proofSetNextProofDue);
            assert.isUndefined(status.rootId);
        });
    });
});
//# sourceMappingURL=storage.test.js.map