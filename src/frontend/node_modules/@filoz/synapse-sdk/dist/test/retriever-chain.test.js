import { assert } from 'chai';
import { ChainRetriever } from '../retriever/chain.js';
import { asCommP } from '../commp/index.js';
const mockCommP = asCommP('baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw76ooefnyqw4ynr3d2y6x2mpq');
const mockProvider1 = {
    owner: '0x1234567890123456789012345678901234567890',
    pdpUrl: 'https://provider1.example.com',
    pieceRetrievalUrl: 'https://provider1.example.com/retrieve',
    registeredAt: 1000,
    approvedAt: 2000
};
const mockProvider2 = {
    owner: '0x2345678901234567890123456789012345678901',
    pdpUrl: 'https://provider2.example.com',
    pieceRetrievalUrl: 'https://provider2.example.com/retrieve',
    registeredAt: 1000,
    approvedAt: 2000
};
const mockChildRetriever = {
    fetchPiece: async (commP, client, options) => {
        return new Response('data from child', { status: 200 });
    }
};
const mockProofSet = {
    railId: 1,
    payer: '0xClient',
    payee: mockProvider1.owner,
    commissionBps: 100,
    metadata: '',
    rootMetadata: [],
    clientDataSetId: 1,
    withCDN: false,
    pdpVerifierProofSetId: 123,
    nextRootId: 1,
    currentRootCount: 5,
    isLive: true,
    isManaged: true
};
describe('ChainRetriever', () => {
    describe('fetchPiece with specific provider', () => {
        it('should fetch from specific provider when providerAddress is given', async () => {
            const mockPandora = {
                getProviderIdByAddress: async (addr) => addr === mockProvider1.owner ? 1 : 0,
                getApprovedProvider: async (id) => {
                    if (id === 1)
                        return mockProvider1;
                    throw new Error('Provider not found');
                }
            };
            const originalFetch = global.fetch;
            let findPieceCalled = false;
            let downloadCalled = false;
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : (input instanceof URL ? input.toString() : input.url);
                if (url.includes('/pdp/piece?')) {
                    findPieceCalled = true;
                    return new Response('', { status: 200 });
                }
                if (url.includes('/piece/')) {
                    downloadCalled = true;
                    return new Response('test data', { status: 200 });
                }
                throw new Error('Unexpected URL');
            };
            try {
                const retriever = new ChainRetriever(mockPandora);
                const response = await retriever.fetchPiece(mockCommP, '0xClient', { providerAddress: mockProvider1.owner });
                assert.isTrue(findPieceCalled, 'Should call findPiece');
                assert.isTrue(downloadCalled, 'Should call download');
                assert.equal(response.status, 200);
                assert.equal(await response.text(), 'test data');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should fall back to child retriever when specific provider is not approved', async () => {
            const mockPandora = {
                getProviderIdByAddress: async () => 0
            };
            const retriever = new ChainRetriever(mockPandora, mockChildRetriever);
            const response = await retriever.fetchPiece(mockCommP, '0xClient', {
                providerAddress: '0xNotApproved'
            });
            assert.equal(response.status, 200);
            assert.equal(await response.text(), 'data from child');
        });
        it('should throw when specific provider is not approved and no child retriever', async () => {
            const mockPandora = {
                getProviderIdByAddress: async () => 0
            };
            const retriever = new ChainRetriever(mockPandora);
            try {
                await retriever.fetchPiece(mockCommP, '0xClient', { providerAddress: '0xNotApproved' });
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'Provider discovery failed and no additional retriever method was configured');
            }
        });
    });
    describe('fetchPiece with multiple providers', () => {
        it('should wait for successful provider even if others fail first', async () => {
            const proofSets = [{
                    isLive: true,
                    currentRootCount: 1,
                    payee: '0xProvider1'
                }, {
                    isLive: true,
                    currentRootCount: 1,
                    payee: '0xProvider2'
                }];
            const providers = [{
                    owner: '0xProvider1',
                    pdpUrl: 'https://pdp1.example.com',
                    pieceRetrievalUrl: 'https://retrieve1.example.com',
                    registeredAt: 0,
                    approvedAt: 0
                }, {
                    owner: '0xProvider2',
                    pdpUrl: 'https://pdp2.example.com',
                    pieceRetrievalUrl: 'https://retrieve2.example.com',
                    registeredAt: 0,
                    approvedAt: 0
                }];
            const mockPandora = {
                getClientProofSetsWithDetails: async () => proofSets,
                getProviderIdByAddress: async (addr) => {
                    if (addr === '0xProvider1')
                        return 1;
                    if (addr === '0xProvider2')
                        return 2;
                    return 0;
                },
                getApprovedProvider: async (id) => {
                    if (id === 1)
                        return providers[0];
                    if (id === 2)
                        return providers[1];
                    throw new Error('Provider not found');
                }
            };
            const retriever = new ChainRetriever(mockPandora);
            const originalFetch = global.fetch;
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes('pdp1.example.com')) {
                    return new Response(null, { status: 404 });
                }
                if (url.includes('pdp2.example.com')) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                    return new Response(null, { status: 200 });
                }
                if (url.includes('retrieve2.example.com')) {
                    return new Response('success from provider 2', { status: 200 });
                }
                throw new Error(`Unexpected URL: ${url}`);
            };
            try {
                const response = await retriever.fetchPiece(mockCommP, '0xClient');
                assert.equal(response.status, 200);
                assert.equal(await response.text(), 'success from provider 2');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should race multiple providers and return first success', async () => {
            const mockPandora = {
                getClientProofSetsWithDetails: async () => [
                    mockProofSet,
                    { ...mockProofSet, payee: mockProvider2.owner }
                ],
                getProviderIdByAddress: async (addr) => {
                    if (addr === mockProvider1.owner)
                        return 1;
                    if (addr === mockProvider2.owner)
                        return 2;
                    return 0;
                },
                getApprovedProvider: async (id) => {
                    if (id === 1)
                        return mockProvider1;
                    if (id === 2)
                        return mockProvider2;
                    throw new Error('Provider not found');
                }
            };
            const originalFetch = global.fetch;
            const fetchCalls = [];
            global.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : (input instanceof URL ? input.toString() : input.url);
                fetchCalls.push(url);
                if (url.includes('provider1')) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                    if (url.includes('/pdp/piece?')) {
                        return new Response('', { status: 200 });
                    }
                    if (url.includes('/piece/')) {
                        return new Response('data from provider1', { status: 200 });
                    }
                }
                if (url.includes('provider2')) {
                    if (url.includes('/pdp/piece?')) {
                        return new Response('', { status: 200 });
                    }
                    if (url.includes('/piece/')) {
                        return new Response('data from provider2', { status: 200 });
                    }
                }
                throw new Error('Unexpected URL');
            };
            try {
                const retriever = new ChainRetriever(mockPandora);
                const response = await retriever.fetchPiece(mockCommP, '0xClient');
                assert.equal(response.status, 200);
                const data = await response.text();
                assert.equal(data, 'data from provider2');
                assert.isTrue(fetchCalls.some(url => url.includes('provider1')));
                assert.isTrue(fetchCalls.some(url => url.includes('provider2')));
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should fall back to child retriever when all providers fail', async () => {
            const mockPandora = {
                getClientProofSetsWithDetails: async () => [mockProofSet],
                getProviderIdByAddress: async () => 1,
                getApprovedProvider: async () => mockProvider1
            };
            const originalFetch = global.fetch;
            global.fetch = async () => new Response('error', { status: 500 });
            try {
                const retriever = new ChainRetriever(mockPandora, mockChildRetriever);
                const response = await retriever.fetchPiece(mockCommP, '0xClient');
                assert.equal(response.status, 200);
                assert.equal(await response.text(), 'data from child');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should throw when all providers fail and no child retriever', async () => {
            const mockPandora = {
                getClientProofSetsWithDetails: async () => [mockProofSet],
                getProviderIdByAddress: async () => 1,
                getApprovedProvider: async () => mockProvider1
            };
            const originalFetch = global.fetch;
            global.fetch = async () => new Response('error', { status: 500 });
            try {
                const retriever = new ChainRetriever(mockPandora);
                await retriever.fetchPiece(mockCommP, '0xClient');
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'All provider retrieval attempts failed and no additional retriever method was configured');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should fall back to child retriever when no active proof sets found', async () => {
            const mockPandora = {
                getClientProofSetsWithDetails: async () => []
            };
            const retriever = new ChainRetriever(mockPandora, mockChildRetriever);
            const response = await retriever.fetchPiece(mockCommP, '0xClient');
            assert.equal(response.status, 200);
            assert.equal(await response.text(), 'data from child');
        });
        it('should throw when no active proof sets found and no child retriever', async () => {
            const mockPandora = {
                getClientProofSetsWithDetails: async () => []
            };
            const retriever = new ChainRetriever(mockPandora);
            try {
                await retriever.fetchPiece(mockCommP, '0xClient');
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'Provider discovery failed and no additional retriever method was configured');
            }
        });
    });
    describe('abort signal handling', () => {
        it('should propagate abort signal to fetch requests', async () => {
            const mockPandora = {
                getProviderIdByAddress: async () => 1,
                getApprovedProvider: async () => mockProvider1
            };
            const controller = new AbortController();
            const originalFetch = global.fetch;
            let signalReceived = false;
            global.fetch = async (input, init) => {
                if ((init?.signal) != null) {
                    signalReceived = true;
                    controller.abort();
                    throw new Error('AbortError');
                }
                throw new Error('No signal provided');
            };
            try {
                const retriever = new ChainRetriever(mockPandora);
                await retriever.fetchPiece(mockCommP, '0xClient', {
                    providerAddress: mockProvider1.owner,
                    signal: controller.signal
                });
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.isTrue(signalReceived, 'Signal should be propagated to fetch');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
    });
});
//# sourceMappingURL=retriever-chain.test.js.map