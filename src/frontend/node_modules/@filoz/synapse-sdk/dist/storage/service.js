import { PDPServer } from '../pdp/server.js';
import { PDPAuthHelper } from '../pdp/auth.js';
import { createError, epochToDate, calculateLastProofDate, timeUntilEpoch } from '../utils/index.js';
import { SIZE_CONSTANTS, TIMING_CONSTANTS } from '../utils/constants.js';
import { asCommP } from '../commp/index.js';
export class StorageService {
    _synapse;
    _provider;
    _pdpServer;
    _pandoraService;
    _pandoraAddress;
    _withCDN;
    _proofSetId;
    _signer;
    proofSetId;
    storageProvider;
    static validateRawSize(sizeBytes, context) {
        if (sizeBytes < SIZE_CONSTANTS.MIN_UPLOAD_SIZE) {
            throw createError('StorageService', context, `Data size (${sizeBytes} bytes) is below minimum allowed size (${SIZE_CONSTANTS.MIN_UPLOAD_SIZE} bytes).`);
        }
        if (sizeBytes > SIZE_CONSTANTS.MAX_UPLOAD_SIZE) {
            throw createError('StorageService', context, `Data size (${sizeBytes} bytes) exceeds maximum allowed size (${SIZE_CONSTANTS.MAX_UPLOAD_SIZE} bytes)`);
        }
    }
    constructor(synapse, pandoraService, provider, proofSetId, options) {
        this._synapse = synapse;
        this._provider = provider;
        this._proofSetId = proofSetId;
        this._withCDN = options.withCDN ?? false;
        this._signer = synapse.getSigner();
        this._pandoraService = pandoraService;
        this.proofSetId = proofSetId.toString();
        this.storageProvider = provider.owner;
        this._pandoraAddress = synapse.getPandoraAddress();
        const authHelper = new PDPAuthHelper(this._pandoraAddress, this._signer, synapse.getChainId());
        this._pdpServer = new PDPServer(authHelper, provider.pdpUrl, provider.pieceRetrievalUrl);
    }
    static async create(synapse, pandoraService, options) {
        const signer = synapse.getSigner();
        const signerAddress = await signer.getAddress();
        const resolution = await StorageService.resolveProviderAndProofSet(synapse, pandoraService, signerAddress, options);
        try {
            options.callbacks?.onProviderSelected?.(resolution.provider);
        }
        catch (error) {
            console.error('Error in onProviderSelected callback:', error);
        }
        let finalProofSetId;
        if (resolution.proofSetId === -1) {
            finalProofSetId = await StorageService.createProofSet(synapse, pandoraService, resolution.provider, options.withCDN ?? false, options.callbacks);
        }
        else {
            finalProofSetId = resolution.proofSetId;
            try {
                options.callbacks?.onProofSetResolved?.({
                    isExisting: true,
                    proofSetId: finalProofSetId,
                    provider: resolution.provider
                });
            }
            catch (error) {
                console.error('Error in onProofSetResolved callback:', error);
            }
        }
        return new StorageService(synapse, pandoraService, resolution.provider, finalProofSetId, options);
    }
    static async createProofSet(synapse, pandoraService, provider, withCDN, callbacks) {
        const signer = synapse.getSigner();
        const signerAddress = await signer.getAddress();
        const nextDatasetId = await pandoraService.getNextClientDataSetId(signerAddress);
        const pandoraAddress = synapse.getPandoraAddress();
        const authHelper = new PDPAuthHelper(pandoraAddress, signer, synapse.getChainId());
        const pdpServer = new PDPServer(authHelper, provider.pdpUrl, provider.pieceRetrievalUrl);
        const createResult = await pdpServer.createProofSet(nextDatasetId, provider.owner, withCDN, pandoraAddress);
        const { txHash, statusUrl } = createResult;
        const ethersProvider = synapse.getProvider();
        let transaction = null;
        const txRetryStartTime = Date.now();
        const txPropagationTimeout = TIMING_CONSTANTS.TRANSACTION_PROPAGATION_TIMEOUT_MS;
        const txPropagationPollInterval = TIMING_CONSTANTS.TRANSACTION_PROPAGATION_POLL_INTERVAL_MS;
        while (Date.now() - txRetryStartTime < txPropagationTimeout) {
            try {
                transaction = await ethersProvider.getTransaction(txHash);
                if (transaction !== null) {
                    break;
                }
            }
            catch (error) {
                console.warn(`Failed to fetch transaction ${txHash}, retrying...`, error);
            }
            await new Promise(resolve => setTimeout(resolve, txPropagationPollInterval));
        }
        if (transaction === null) {
            throw createError('StorageService', 'create', `Transaction ${txHash} not found after ${txPropagationTimeout / 1000} seconds. The transaction may not have propagated to the RPC node.`);
        }
        try {
            callbacks?.onProofSetCreationStarted?.(transaction, statusUrl);
        }
        catch (error) {
            console.error('Error in onProofSetCreationStarted callback:', error);
        }
        let finalStatus;
        try {
            finalStatus = await pandoraService.waitForProofSetCreationWithStatus(transaction, pdpServer, TIMING_CONSTANTS.PROOF_SET_CREATION_TIMEOUT_MS, TIMING_CONSTANTS.PROOF_SET_CREATION_POLL_INTERVAL_MS, async (status, elapsedMs) => {
                if (callbacks?.onProofSetCreationProgress != null) {
                    try {
                        let receipt;
                        if (status.chainStatus.transactionMined && status.chainStatus.blockNumber != null) {
                            try {
                                const txReceipt = await transaction.wait(TIMING_CONSTANTS.TRANSACTION_CONFIRMATIONS);
                                receipt = txReceipt ?? undefined;
                            }
                            catch (error) {
                                console.error('Failed to fetch transaction receipt:', error);
                            }
                        }
                        callbacks.onProofSetCreationProgress({
                            transactionMined: status.chainStatus.transactionMined,
                            transactionSuccess: status.chainStatus.transactionSuccess,
                            proofSetLive: status.chainStatus.proofSetLive,
                            serverConfirmed: status.serverStatus?.ok === true,
                            proofSetId: status.summary.proofSetId ?? undefined,
                            elapsedMs,
                            receipt
                        });
                    }
                    catch (error) {
                        console.error('Error in onProofSetCreationProgress callback:', error);
                    }
                }
            });
        }
        catch (error) {
            throw createError('StorageService', 'waitForProofSetCreation', error instanceof Error ? error.message : 'Proof set creation failed');
        }
        if (!finalStatus.summary.isComplete || finalStatus.summary.proofSetId == null) {
            throw createError('StorageService', 'waitForProofSetCreation', `Proof set creation failed: ${finalStatus.summary.error ?? 'Transaction may have failed'}`);
        }
        const proofSetId = finalStatus.summary.proofSetId;
        try {
            callbacks?.onProofSetResolved?.({
                isExisting: false,
                proofSetId,
                provider
            });
        }
        catch (error) {
            console.error('Error in onProofSetResolved callback:', error);
        }
        return proofSetId;
    }
    static async resolveProviderAndProofSet(synapse, pandoraService, signerAddress, options) {
        if (options.proofSetId != null) {
            return await StorageService.resolveByProofSetId(options.proofSetId, pandoraService, signerAddress, options);
        }
        if (options.providerId != null) {
            return await StorageService.resolveByProviderId(options.providerId, pandoraService, signerAddress, options.withCDN ?? false);
        }
        if (options.providerAddress != null) {
            return await StorageService.resolveByProviderAddress(options.providerAddress, pandoraService, signerAddress, options.withCDN ?? false);
        }
        return await StorageService.smartSelectProvider(pandoraService, signerAddress, options.withCDN ?? false, synapse.getSigner());
    }
    static async resolveByProofSetId(proofSetId, pandoraService, signerAddress, options) {
        const proofSets = await pandoraService.getClientProofSetsWithDetails(signerAddress);
        const proofSet = proofSets.find(ps => ps.pdpVerifierProofSetId === proofSetId);
        if (proofSet == null || !proofSet.isLive || !proofSet.isManaged) {
            throw createError('StorageService', 'resolveByProofSetId', `Proof set ${proofSetId} not found, not owned by ${signerAddress}, ` +
                'or not managed by the current Pandora contract');
        }
        if (options.providerId != null || options.providerAddress != null) {
            await StorageService.validateProofSetConsistency(proofSet, options, pandoraService);
        }
        const providerId = await pandoraService.getProviderIdByAddress(proofSet.payee);
        if (providerId === 0) {
            throw createError('StorageService', 'resolveByProofSetId', `Provider ${proofSet.payee} for proof set ${proofSetId} is not currently approved`);
        }
        const provider = await pandoraService.getApprovedProvider(providerId);
        return {
            provider,
            proofSetId,
            isExisting: true
        };
    }
    static async validateProofSetConsistency(proofSet, options, pandoraService) {
        if (options.providerId != null) {
            const providerId = await pandoraService.getProviderIdByAddress(proofSet.payee);
            if (providerId !== options.providerId) {
                throw createError('StorageService', 'validateProofSetConsistency', `Proof set ${proofSet.pdpVerifierProofSetId} belongs to provider ID ${providerId}, ` +
                    `but provider ID ${options.providerId} was requested`);
            }
        }
        if (options.providerAddress != null) {
            if (proofSet.payee.toLowerCase() !== options.providerAddress.toLowerCase()) {
                throw createError('StorageService', 'validateProofSetConsistency', `Proof set ${proofSet.pdpVerifierProofSetId} belongs to provider ${proofSet.payee}, ` +
                    `but provider ${options.providerAddress} was requested`);
            }
        }
    }
    static async resolveByProviderId(providerId, pandoraService, signerAddress, withCDN) {
        const [provider, proofSets] = await Promise.all([
            pandoraService.getApprovedProvider(providerId),
            pandoraService.getClientProofSetsWithDetails(signerAddress)
        ]);
        if (provider.owner === '0x0000000000000000000000000000000000000000') {
            throw createError('StorageService', 'resolveByProviderId', `Provider ID ${providerId} not found or not approved`);
        }
        const providerProofSets = proofSets.filter(ps => ps.payee.toLowerCase() === provider.owner.toLowerCase() &&
            ps.isLive &&
            ps.isManaged &&
            ps.withCDN === withCDN);
        if (providerProofSets.length > 0) {
            const sorted = providerProofSets.sort((a, b) => {
                if (a.currentRootCount > 0 && b.currentRootCount === 0)
                    return -1;
                if (b.currentRootCount > 0 && a.currentRootCount === 0)
                    return 1;
                return a.pdpVerifierProofSetId - b.pdpVerifierProofSetId;
            });
            return {
                provider,
                proofSetId: sorted[0].pdpVerifierProofSetId,
                isExisting: true
            };
        }
        return {
            provider,
            proofSetId: -1,
            isExisting: false
        };
    }
    static async resolveByProviderAddress(providerAddress, pandoraService, signerAddress, withCDN) {
        const providerId = await pandoraService.getProviderIdByAddress(providerAddress);
        if (providerId === 0) {
            throw createError('StorageService', 'resolveByProviderAddress', `Provider ${providerAddress} is not currently approved`);
        }
        return await StorageService.resolveByProviderId(providerId, pandoraService, signerAddress, withCDN);
    }
    static async smartSelectProvider(pandoraService, signerAddress, withCDN, signer) {
        const proofSets = await pandoraService.getClientProofSetsWithDetails(signerAddress);
        const managedProofSets = proofSets.filter(ps => ps.isLive && ps.isManaged && ps.withCDN === withCDN);
        if (managedProofSets.length > 0) {
            const sorted = managedProofSets.sort((a, b) => {
                if (a.currentRootCount > 0 && b.currentRootCount === 0)
                    return -1;
                if (b.currentRootCount > 0 && a.currentRootCount === 0)
                    return 1;
                return a.pdpVerifierProofSetId - b.pdpVerifierProofSetId;
            });
            async function* generateProviders() {
                const seenProviders = new Set();
                for (const proofSet of sorted) {
                    const providerAddress = proofSet.payee.toLowerCase();
                    if (seenProviders.has(providerAddress)) {
                        continue;
                    }
                    seenProviders.add(providerAddress);
                    const providerId = await pandoraService.getProviderIdByAddress(proofSet.payee);
                    if (providerId === 0) {
                        console.warn(`Provider ${proofSet.payee} for proof set ${proofSet.pdpVerifierProofSetId} is not currently approved, skipping`);
                        continue;
                    }
                    const provider = await pandoraService.getApprovedProvider(providerId);
                    yield provider;
                }
            }
            const selectedProvider = await StorageService.selectProviderWithPing(generateProviders());
            const matchingProofSet = sorted.find(ps => ps.payee.toLowerCase() === selectedProvider.owner.toLowerCase());
            if (matchingProofSet == null) {
                throw createError('StorageService', 'smartSelectProvider', 'Selected provider not found in proof sets');
            }
            return {
                provider: selectedProvider,
                proofSetId: matchingProofSet.pdpVerifierProofSetId,
                isExisting: true
            };
        }
        const allProviders = await pandoraService.getAllApprovedProviders();
        if (allProviders.length === 0) {
            throw createError('StorageService', 'smartSelectProvider', 'No approved storage providers available');
        }
        const provider = await StorageService.selectRandomProvider(allProviders, signer);
        return {
            provider,
            proofSetId: -1,
            isExisting: false
        };
    }
    static async selectRandomProvider(providers, signer) {
        if (providers.length === 0) {
            throw createError('StorageService', 'selectRandomProvider', 'No providers available');
        }
        async function* generateRandomProviders() {
            const remaining = [...providers];
            while (remaining.length > 0) {
                let randomIndex;
                if (typeof globalThis.crypto !== 'undefined' && globalThis.crypto.getRandomValues != null) {
                    const randomBytes = new Uint8Array(1);
                    globalThis.crypto.getRandomValues(randomBytes);
                    randomIndex = randomBytes[0] % remaining.length;
                }
                else {
                    const timestamp = Date.now();
                    const random = Math.random();
                    const addressBytes = await signer.getAddress();
                    const addressSum = addressBytes.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
                    const combined = (timestamp * random * addressSum) % remaining.length;
                    randomIndex = Math.floor(Math.abs(combined));
                }
                const selected = remaining.splice(randomIndex, 1)[0];
                yield selected;
            }
        }
        return await StorageService.selectProviderWithPing(generateRandomProviders());
    }
    static async selectProviderWithPing(providers) {
        let providerCount = 0;
        for await (const provider of providers) {
            providerCount++;
            try {
                const providerPdpServer = new PDPServer(null, provider.pdpUrl, provider.pieceRetrievalUrl);
                await providerPdpServer.ping();
                return provider;
            }
            catch (error) {
                console.warn(`Provider ${provider.owner} failed ping test:`, error instanceof Error ? error.message : String(error));
            }
        }
        if (providerCount === 0) {
            throw createError('StorageService', 'selectProviderWithPing', 'No reachable storage providers available after ping validation');
        }
        throw createError('StorageService', 'selectProviderWithPing', `All ${providerCount} available storage providers failed ping validation`);
    }
    async preflightUpload(size) {
        StorageService.validateRawSize(size, 'preflightUpload');
        const allowanceCheck = await this._pandoraService.checkAllowanceForStorage(size, this._withCDN, this._synapse.payments);
        return {
            estimatedCost: {
                perEpoch: allowanceCheck.costs.perEpoch,
                perDay: allowanceCheck.costs.perDay,
                perMonth: allowanceCheck.costs.perMonth
            },
            allowanceCheck: {
                sufficient: allowanceCheck.sufficient,
                message: allowanceCheck.message
            },
            selectedProvider: this._provider,
            selectedProofSetId: this._proofSetId
        };
    }
    async upload(data, callbacks) {
        const dataBytes = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
        const sizeBytes = dataBytes.length;
        StorageService.validateRawSize(sizeBytes, 'upload');
        let uploadResult;
        try {
            uploadResult = await this._pdpServer.uploadPiece(dataBytes);
        }
        catch (error) {
            throw createError('StorageService', 'uploadPiece', 'Failed to upload piece to storage provider', error);
        }
        const maxWaitTime = TIMING_CONSTANTS.PIECE_PARKING_TIMEOUT_MS;
        const pollInterval = TIMING_CONSTANTS.PIECE_PARKING_POLL_INTERVAL_MS;
        const startTime = Date.now();
        let pieceReady = false;
        while (Date.now() - startTime < maxWaitTime) {
            try {
                await this._pdpServer.findPiece(uploadResult.commP, uploadResult.size);
                pieceReady = true;
                break;
            }
            catch {
                if (Date.now() - startTime + pollInterval < maxWaitTime) {
                    await new Promise(resolve => setTimeout(resolve, pollInterval));
                }
            }
        }
        if (!pieceReady) {
            throw createError('StorageService', 'findPiece', 'Timeout waiting for piece to be parked on storage provider');
        }
        if (callbacks?.onUploadComplete != null) {
            callbacks.onUploadComplete(uploadResult.commP);
        }
        try {
            const addRootsInfo = await this._pandoraService.getAddRootsInfo(this._proofSetId);
            const rootDataArray = [{
                    cid: uploadResult.commP,
                    rawSize: uploadResult.size
                }];
            const addRootsResult = await this._pdpServer.addRoots(this._proofSetId, addRootsInfo.clientDataSetId, addRootsInfo.nextRootId, rootDataArray);
            let finalRootId = addRootsInfo.nextRootId;
            if (addRootsResult.txHash != null) {
                let transaction = null;
                const txRetryStartTime = Date.now();
                const txPropagationTimeout = TIMING_CONSTANTS.TRANSACTION_PROPAGATION_TIMEOUT_MS;
                const txPropagationPollInterval = TIMING_CONSTANTS.TRANSACTION_PROPAGATION_POLL_INTERVAL_MS;
                while (Date.now() - txRetryStartTime < txPropagationTimeout) {
                    try {
                        transaction = await this._synapse.getProvider().getTransaction(addRootsResult.txHash);
                        if (transaction !== null)
                            break;
                    }
                    catch {
                    }
                    await new Promise(resolve => setTimeout(resolve, txPropagationPollInterval));
                }
                if (transaction == null) {
                    throw createError('StorageService', 'addRoots', `Server returned transaction hash ${addRootsResult.txHash} but transaction was not found on-chain after ${txPropagationTimeout / 1000} seconds`);
                }
                callbacks?.onRootAdded?.(transaction);
                let receipt;
                try {
                    receipt = await transaction.wait(TIMING_CONSTANTS.TRANSACTION_CONFIRMATIONS);
                }
                catch (error) {
                    throw createError('StorageService', 'addRoots', 'Failed to wait for transaction confirmation', error);
                }
                if (receipt?.status !== 1) {
                    throw createError('StorageService', 'addRoots', 'Root addition transaction failed on-chain');
                }
                const maxWaitTime = TIMING_CONSTANTS.ROOT_ADDITION_TIMEOUT_MS;
                const pollInterval = TIMING_CONSTANTS.ROOT_ADDITION_POLL_INTERVAL_MS;
                const startTime = Date.now();
                let lastError = null;
                let statusVerified = false;
                while (Date.now() - startTime < maxWaitTime) {
                    try {
                        const status = await this._pdpServer.getRootAdditionStatus(this._proofSetId, addRootsResult.txHash);
                        if (status.txStatus === 'pending') {
                            await new Promise(resolve => setTimeout(resolve, pollInterval));
                            continue;
                        }
                        if (status.addMessageOk === false) {
                            throw new Error('Root addition failed: Transaction was unsuccessful');
                        }
                        if (status.confirmedRootIds != null && status.confirmedRootIds.length > 0) {
                            finalRootId = status.confirmedRootIds[0];
                            callbacks?.onRootConfirmed?.(status.confirmedRootIds);
                            statusVerified = true;
                            break;
                        }
                        await new Promise(resolve => setTimeout(resolve, pollInterval));
                    }
                    catch (error) {
                        lastError = error;
                        if (error instanceof Error && error.message.includes('not found')) {
                            await new Promise(resolve => setTimeout(resolve, pollInterval));
                            continue;
                        }
                        throw createError('StorageService', 'addRoots', `Failed to verify root addition with server: ${error instanceof Error ? error.message : 'Unknown error'}`, error);
                    }
                }
                if (!statusVerified) {
                    const errorMessage = `Failed to verify root addition after ${maxWaitTime / 1000} seconds: ${lastError != null ? lastError.message : 'Server did not provide confirmation'}`;
                    throw createError('StorageService', 'addRoots', errorMessage + '. The transaction was confirmed on-chain but the server failed to acknowledge it.', lastError);
                }
            }
            else {
                callbacks?.onRootAdded?.();
            }
            return {
                commp: uploadResult.commP,
                size: uploadResult.size,
                rootId: finalRootId
            };
        }
        catch (error) {
            throw createError('StorageService', 'addRoots', 'Failed to add root to proof set', error);
        }
    }
    async providerDownload(commp, options) {
        return await this._synapse.download(commp, {
            providerAddress: this._provider.owner,
            withCDN: this._withCDN
        });
    }
    async download(commp, options) {
        return await this.providerDownload(commp, options);
    }
    async getProviderInfo() {
        return await this._synapse.getProviderInfo(this.storageProvider);
    }
    async getProofSetRoots() {
        const proofSetData = await this._pdpServer.getProofSet(this._proofSetId);
        return proofSetData.roots.map(root => root.rootCid);
    }
    async pieceStatus(commp) {
        const parsedCommP = asCommP(commp);
        if (parsedCommP == null) {
            throw createError('StorageService', 'pieceStatus', 'Invalid CommP provided');
        }
        const [pieceCheckResult, proofSetData, currentEpoch] = await Promise.all([
            this._pdpServer.findPiece(parsedCommP, 0).then(() => true).catch(() => false),
            this._pdpServer.getProofSet(this._proofSetId).catch((error) => {
                console.debug('Failed to get proof set data:', error);
                return null;
            }),
            this._synapse.payments.getCurrentEpoch()
        ]);
        const exists = pieceCheckResult;
        const network = this._synapse.getNetwork();
        let retrievalUrl = null;
        let rootId;
        let lastProven = null;
        let nextProofDue = null;
        let inChallengeWindow = false;
        let hoursUntilChallengeWindow = 0;
        let isProofOverdue = false;
        if (exists) {
            const [providerInfo, provingParams] = await Promise.all([
                this.getProviderInfo().catch(() => null),
                proofSetData != null
                    ? Promise.all([
                        this._pandoraService.getMaxProvingPeriod(),
                        this._pandoraService.getChallengeWindow()
                    ]).then(([maxProvingPeriod, challengeWindow]) => ({ maxProvingPeriod, challengeWindow }))
                        .catch(() => null)
                    : Promise.resolve(null)
            ]);
            if (providerInfo != null) {
                retrievalUrl = `${providerInfo.pieceRetrievalUrl.replace(/\/$/, '')}/piece/${parsedCommP.toString()}`;
            }
            if (proofSetData != null && provingParams != null) {
                const rootData = proofSetData.roots.find(root => root.rootCid.toString() === parsedCommP.toString());
                if (rootData != null) {
                    rootId = rootData.rootId;
                    if (proofSetData.nextChallengeEpoch > 0) {
                        const challengeWindowStart = proofSetData.nextChallengeEpoch;
                        const provingDeadline = challengeWindowStart + provingParams.challengeWindow;
                        nextProofDue = epochToDate(provingDeadline, network);
                        const lastProvenDate = calculateLastProofDate(proofSetData.nextChallengeEpoch, provingParams.maxProvingPeriod, network);
                        if (lastProvenDate != null) {
                            lastProven = lastProvenDate;
                        }
                        inChallengeWindow = currentEpoch >= challengeWindowStart && currentEpoch < provingDeadline;
                        isProofOverdue = currentEpoch >= provingDeadline;
                        if (currentEpoch < challengeWindowStart) {
                            const timeUntil = timeUntilEpoch(challengeWindowStart, Number(currentEpoch));
                            hoursUntilChallengeWindow = timeUntil.hours;
                        }
                    }
                    else {
                        console.debug('Proof set has nextChallengeEpoch=0, may have just been proven');
                    }
                }
            }
        }
        return {
            exists,
            proofSetLastProven: lastProven,
            proofSetNextProofDue: nextProofDue,
            retrievalUrl,
            rootId,
            inChallengeWindow,
            hoursUntilChallengeWindow,
            isProofOverdue
        };
    }
}
//# sourceMappingURL=service.js.map