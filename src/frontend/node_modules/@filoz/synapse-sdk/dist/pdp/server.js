import { ethers } from 'ethers';
import { asCommP, calculate as calculateCommP, downloadAndValidateCommP } from '../commp/index.js';
import { constructPieceUrl, constructFindPieceUrl } from '../utils/piece.js';
import { MULTIHASH_CODES } from '../utils/index.js';
import { toHex } from 'multiformats/bytes';
import { validateProofSetCreationStatusResponse, validateRootAdditionStatusResponse, validateFindPieceResponse, asProofSetData } from './validation.js';
export class PDPServer {
    _apiEndpoint;
    _retrievalEndpoint;
    _authHelper;
    _serviceName;
    constructor(authHelper, apiEndpoint, retrievalEndpoint, serviceName = 'public') {
        if (apiEndpoint.trim() === '') {
            throw new Error('PDP API endpoint is required');
        }
        if (retrievalEndpoint.trim() === '') {
            throw new Error('PDP retrieval endpoint is required');
        }
        this._apiEndpoint = apiEndpoint.replace(/\/$/, '');
        this._retrievalEndpoint = retrievalEndpoint.replace(/\/$/, '');
        this._authHelper = authHelper;
        this._serviceName = serviceName;
    }
    async createProofSet(clientDataSetId, payee, withCDN, recordKeeper) {
        const authData = await this.getAuthHelper().signCreateProofSet(clientDataSetId, payee, withCDN);
        const extraData = this._encodeProofSetCreateData({
            metadata: '',
            payer: await this.getAuthHelper().getSignerAddress(),
            withCDN,
            signature: authData.signature
        });
        const requestBody = {
            recordKeeper,
            extraData: `0x${extraData}`
        };
        const response = await fetch(`${this._apiEndpoint}/pdp/proof-sets`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });
        if (response.status !== 201) {
            const errorText = await response.text();
            throw new Error(`Failed to create proof set: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const location = response.headers.get('Location');
        if (location == null) {
            throw new Error('Server did not provide Location header in response');
        }
        const locationMatch = location.match(/\/pdp\/proof-sets\/created\/(.+)$/);
        if (locationMatch == null) {
            throw new Error(`Invalid Location header format: ${location}`);
        }
        const txHash = locationMatch[1];
        return {
            txHash,
            statusUrl: `${this._apiEndpoint}${location}`
        };
    }
    async addRoots(proofSetId, clientDataSetId, nextRootId, rootDataArray) {
        if (rootDataArray.length === 0) {
            throw new Error('At least one root must be provided');
        }
        for (const rootData of rootDataArray) {
            const commP = asCommP(rootData.cid);
            if (commP == null) {
                throw new Error(`Invalid CommP: ${String(rootData.cid)}`);
            }
        }
        const authData = await this.getAuthHelper().signAddRoots(clientDataSetId, nextRootId, rootDataArray);
        const extraData = this._encodeAddRootsExtraData({
            signature: authData.signature,
            metadata: ''
        });
        const requestBody = {
            roots: rootDataArray.map(rootData => {
                const cidString = typeof rootData.cid === 'string' ? rootData.cid : rootData.cid.toString();
                return {
                    rootCid: cidString,
                    subroots: [{
                            subrootCid: cidString
                        }]
                };
            }),
            extraData: `0x${extraData}`
        };
        const response = await fetch(`${this._apiEndpoint}/pdp/proof-sets/${proofSetId}/roots`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });
        if (response.status !== 201) {
            const errorText = await response.text();
            throw new Error(`Failed to add roots to proof set: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const location = response.headers.get('Location');
        let txHash;
        let statusUrl;
        if (location != null) {
            const locationMatch = location.match(/\/roots\/added\/([0-9a-fA-Fx]+)$/);
            if (locationMatch != null) {
                txHash = locationMatch[1];
                if (!txHash.startsWith('0x')) {
                    txHash = '0x' + txHash;
                }
                statusUrl = `${this._apiEndpoint}${location}`;
            }
        }
        const responseText = await response.text();
        return {
            message: responseText !== '' ? responseText : `Roots added to proof set ID ${proofSetId} successfully`,
            txHash,
            statusUrl
        };
    }
    async getProofSetCreationStatus(txHash) {
        const response = await fetch(`${this._apiEndpoint}/pdp/proof-sets/created/${txHash}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        if (response.status === 404) {
            throw new Error(`Proof set creation not found for transaction hash: ${txHash}`);
        }
        if (response.status !== 200) {
            const errorText = await response.text();
            throw new Error(`Failed to get proof set creation status: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const data = await response.json();
        return validateProofSetCreationStatusResponse(data);
    }
    async getRootAdditionStatus(proofSetId, txHash) {
        const response = await fetch(`${this._apiEndpoint}/pdp/proof-sets/${proofSetId}/roots/added/${txHash}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        if (response.status === 404) {
            throw new Error(`Root addition not found for transaction: ${txHash}`);
        }
        if (response.status !== 200) {
            const errorText = await response.text();
            throw new Error(`Failed to get root addition status: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const data = await response.json();
        return validateRootAdditionStatusResponse(data);
    }
    async findPiece(commP, size) {
        const parsedCommP = asCommP(commP);
        if (parsedCommP == null) {
            throw new Error(`Invalid CommP: ${String(commP)}`);
        }
        const url = constructFindPieceUrl(this._apiEndpoint, parsedCommP, size);
        const response = await fetch(url, {
            method: 'GET',
            headers: {}
        });
        if (response.status === 404) {
            throw new Error(`Piece not found: ${parsedCommP.toString()}`);
        }
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to find piece: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const data = await response.json();
        return validateFindPieceResponse(data);
    }
    async uploadPiece(data) {
        const uint8Data = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
        const commP = await calculateCommP(uint8Data);
        const size = uint8Data.length;
        const hashBytes = commP.multihash.digest;
        const hashHex = toHex(hashBytes);
        const checkData = {
            name: MULTIHASH_CODES.SHA2_256_TRUNC254_PADDED,
            hash: hashHex,
            size
        };
        const requestBody = {
            check: checkData
        };
        const createResponse = await fetch(`${this._apiEndpoint}/pdp/piece`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });
        if (createResponse.status === 200) {
            return {
                commP,
                size
            };
        }
        if (createResponse.status !== 201) {
            const errorText = await createResponse.text();
            throw new Error(`Failed to create upload session: ${createResponse.status} ${createResponse.statusText} - ${errorText}`);
        }
        const location = createResponse.headers.get('Location');
        if (location == null) {
            throw new Error('Server did not provide Location header in response (may be restricted by CORS policy)');
        }
        const locationMatch = location.match(/\/(?:pdp\/)?piece\/upload\/([a-fA-F0-9-]+)/);
        if (locationMatch == null) {
            throw new Error(`Invalid Location header format: ${location}`);
        }
        const uploadUuid = locationMatch[1];
        const uploadResponse = await fetch(`${this._apiEndpoint}/pdp/piece/upload/${uploadUuid}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/octet-stream',
                'Content-Length': uint8Data.length.toString()
            },
            body: uint8Data
        });
        if (uploadResponse.status !== 204) {
            const errorText = await uploadResponse.text();
            throw new Error(`Failed to upload piece: ${uploadResponse.status} ${uploadResponse.statusText} - ${errorText}`);
        }
        return {
            commP,
            size
        };
    }
    async downloadPiece(commP) {
        const parsedCommP = asCommP(commP);
        if (parsedCommP == null) {
            throw new Error(`Invalid CommP: ${String(commP)}`);
        }
        const downloadUrl = constructPieceUrl(this._retrievalEndpoint, parsedCommP);
        const response = await fetch(downloadUrl);
        return await downloadAndValidateCommP(response, parsedCommP);
    }
    async getProofSet(proofSetId) {
        const response = await fetch(`${this._apiEndpoint}/pdp/proof-sets/${proofSetId}`, {
            method: 'GET',
            headers: {
                Accept: 'application/json'
            }
        });
        if (response.status === 404) {
            throw new Error(`Proof set not found: ${proofSetId}`);
        }
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to fetch proof set: ${response.status} ${response.statusText} - ${errorText}`);
        }
        const data = await response.json();
        const converted = asProofSetData(data);
        if (converted == null) {
            throw new Error('Invalid proof set data response format');
        }
        return converted;
    }
    _encodeProofSetCreateData(data) {
        const signature = data.signature.startsWith('0x') ? data.signature : `0x${data.signature}`;
        const abiCoder = ethers.AbiCoder.defaultAbiCoder();
        const encoded = abiCoder.encode(['string', 'address', 'bool', 'bytes'], [data.metadata, data.payer, data.withCDN, signature]);
        return encoded.slice(2);
    }
    _encodeAddRootsExtraData(data) {
        const signature = data.signature.startsWith('0x') ? data.signature : `0x${data.signature}`;
        const abiCoder = ethers.AbiCoder.defaultAbiCoder();
        const encoded = abiCoder.encode(['bytes', 'string'], [signature, data.metadata]);
        return encoded.slice(2);
    }
    async ping() {
        const response = await fetch(`${this._apiEndpoint}/pdp/ping`, {
            method: 'GET',
            headers: {}
        });
        if (response.status !== 200) {
            const errorText = await response.text().catch(() => 'Unknown error');
            throw new Error(`Provider ping failed: ${response.status} ${response.statusText} - ${errorText}`);
        }
    }
    getApiEndpoint() {
        return this._apiEndpoint;
    }
    getAuthHelper() {
        if (this._authHelper == null) {
            throw new Error('AuthHelper is not available for an operation that requires signing');
        }
        return this._authHelper;
    }
}
//# sourceMappingURL=server.js.map