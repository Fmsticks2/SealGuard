import { ethers } from 'ethers';
import { asCommP, toPieceSize } from '../commp/index.js';
const EIP712_TYPES = {
    CreateProofSet: [
        { name: 'clientDataSetId', type: 'uint256' },
        { name: 'withCDN', type: 'bool' },
        { name: 'payee', type: 'address' }
    ],
    Cid: [
        { name: 'data', type: 'bytes' }
    ],
    RootData: [
        { name: 'root', type: 'Cid' },
        { name: 'rawSize', type: 'uint256' }
    ],
    AddRoots: [
        { name: 'clientDataSetId', type: 'uint256' },
        { name: 'firstAdded', type: 'uint256' },
        { name: 'rootData', type: 'RootData[]' }
    ],
    ScheduleRemovals: [
        { name: 'clientDataSetId', type: 'uint256' },
        { name: 'rootIds', type: 'uint256[]' }
    ],
    DeleteProofSet: [
        { name: 'clientDataSetId', type: 'uint256' }
    ]
};
export class PDPAuthHelper {
    signer;
    domain;
    constructor(serviceContractAddress, signer, chainId) {
        this.signer = signer;
        this.domain = {
            name: 'PandoraService',
            version: '1',
            chainId: Number(chainId),
            verifyingContract: serviceContractAddress
        };
    }
    getUnderlyingSigner() {
        if ('signer' in this.signer && this.signer.constructor.name === 'NonceManager') {
            return this.signer.signer;
        }
        return this.signer;
    }
    async isMetaMaskSigner() {
        try {
            const actualSigner = this.getUnderlyingSigner();
            if (actualSigner.constructor.name === 'Wallet') {
                return false;
            }
            const provider = actualSigner.provider;
            if (provider == null) {
                return false;
            }
            if ('_eip1193Provider' in provider) {
                return true;
            }
            if (typeof globalThis !== 'undefined' && 'window' in globalThis) {
                const win = globalThis;
                if (win.window?.ethereum != null) {
                    return true;
                }
            }
            if ('send' in provider || 'request' in provider) {
                return true;
            }
        }
        catch (error) {
        }
        return false;
    }
    async signWithMetaMask(types, value) {
        const provider = this.signer.provider;
        if (provider == null) {
            throw new Error('No provider available');
        }
        const signerAddress = await this.signer.getAddress();
        let primaryType = '';
        for (const typeName of Object.keys(types)) {
            if (typeName !== 'Cid' && typeName !== 'RootData') {
                primaryType = typeName;
                break;
            }
        }
        const typedData = {
            types: {
                EIP712Domain: [
                    { name: 'name', type: 'string' },
                    { name: 'version', type: 'string' },
                    { name: 'chainId', type: 'uint256' },
                    { name: 'verifyingContract', type: 'address' }
                ],
                ...types
            },
            primaryType,
            domain: this.domain,
            message: value
        };
        let eip1193Provider;
        if ('_eip1193Provider' in provider) {
            eip1193Provider = provider._eip1193Provider;
        }
        else if ('request' in provider) {
            eip1193Provider = provider;
        }
        else {
            eip1193Provider = provider;
        }
        let signature;
        if (eip1193Provider != null && 'request' in eip1193Provider) {
            signature = await eip1193Provider.request({
                method: 'eth_signTypedData_v4',
                params: [signerAddress.toLowerCase(), JSON.stringify(typedData)]
            });
        }
        else {
            signature = await provider.send('eth_signTypedData_v4', [
                signerAddress.toLowerCase(),
                JSON.stringify(typedData)
            ]);
        }
        return signature;
    }
    async signCreateProofSet(clientDataSetId, payee, withCDN = false) {
        let signature;
        const useMetaMask = await this.isMetaMaskSigner();
        if (useMetaMask) {
            const value = {
                clientDataSetId: clientDataSetId.toString(),
                withCDN,
                payee
            };
            signature = await this.signWithMetaMask({ CreateProofSet: EIP712_TYPES.CreateProofSet }, value);
        }
        else {
            const value = {
                clientDataSetId: BigInt(clientDataSetId),
                withCDN,
                payee
            };
            const actualSigner = this.getUnderlyingSigner();
            signature = await actualSigner.signTypedData(this.domain, { CreateProofSet: EIP712_TYPES.CreateProofSet }, value);
        }
        const sig = ethers.Signature.from(signature);
        const signedData = ethers.TypedDataEncoder.hash(this.domain, { CreateProofSet: EIP712_TYPES.CreateProofSet }, {
            clientDataSetId: BigInt(clientDataSetId),
            withCDN,
            payee
        });
        return {
            signature,
            v: sig.v,
            r: sig.r,
            s: sig.s,
            signedData
        };
    }
    async signAddRoots(clientDataSetId, firstRootId, rootDataArray) {
        const formattedRootData = [];
        for (const root of rootDataArray) {
            const commP = typeof root.cid === 'string' ? asCommP(root.cid) : root.cid;
            if (commP == null) {
                throw new Error(`Invalid CommP: ${String(root.cid)}`);
            }
            formattedRootData.push({
                root: {
                    data: commP.bytes
                },
                rawSize: BigInt(toPieceSize(root.rawSize))
            });
        }
        let signature;
        const useMetaMask = await this.isMetaMaskSigner();
        if (useMetaMask) {
            const value = {
                clientDataSetId: clientDataSetId.toString(),
                firstAdded: firstRootId.toString(),
                rootData: formattedRootData.map(item => ({
                    root: {
                        data: ethers.hexlify(item.root.data)
                    },
                    rawSize: item.rawSize.toString()
                }))
            };
            const types = {
                AddRoots: EIP712_TYPES.AddRoots,
                RootData: EIP712_TYPES.RootData,
                Cid: EIP712_TYPES.Cid
            };
            signature = await this.signWithMetaMask(types, value);
        }
        else {
            const value = {
                clientDataSetId: BigInt(clientDataSetId),
                firstAdded: BigInt(firstRootId),
                rootData: formattedRootData
            };
            const types = {
                AddRoots: EIP712_TYPES.AddRoots,
                RootData: EIP712_TYPES.RootData,
                Cid: EIP712_TYPES.Cid
            };
            const actualSigner = this.getUnderlyingSigner();
            signature = await actualSigner.signTypedData(this.domain, types, value);
        }
        const sig = ethers.Signature.from(signature);
        const signedData = ethers.TypedDataEncoder.hash(this.domain, {
            AddRoots: EIP712_TYPES.AddRoots,
            RootData: EIP712_TYPES.RootData,
            Cid: EIP712_TYPES.Cid
        }, {
            clientDataSetId: BigInt(clientDataSetId),
            firstAdded: BigInt(firstRootId),
            rootData: formattedRootData
        });
        return {
            signature,
            v: sig.v,
            r: sig.r,
            s: sig.s,
            signedData
        };
    }
    async signScheduleRemovals(clientDataSetId, rootIds) {
        const rootIdsBigInt = rootIds.map(id => BigInt(id));
        let signature;
        const useMetaMask = await this.isMetaMaskSigner();
        if (useMetaMask) {
            const value = {
                clientDataSetId: clientDataSetId.toString(),
                rootIds: rootIdsBigInt.map(id => id.toString())
            };
            signature = await this.signWithMetaMask({ ScheduleRemovals: EIP712_TYPES.ScheduleRemovals }, value);
        }
        else {
            const value = {
                clientDataSetId: BigInt(clientDataSetId),
                rootIds: rootIdsBigInt
            };
            const actualSigner = this.getUnderlyingSigner();
            signature = await actualSigner.signTypedData(this.domain, { ScheduleRemovals: EIP712_TYPES.ScheduleRemovals }, value);
        }
        const sig = ethers.Signature.from(signature);
        const signedData = ethers.TypedDataEncoder.hash(this.domain, { ScheduleRemovals: EIP712_TYPES.ScheduleRemovals }, {
            clientDataSetId: BigInt(clientDataSetId),
            rootIds: rootIdsBigInt
        });
        return {
            signature,
            v: sig.v,
            r: sig.r,
            s: sig.s,
            signedData
        };
    }
    async signDeleteProofSet(clientDataSetId) {
        let signature;
        const useMetaMask = await this.isMetaMaskSigner();
        if (useMetaMask) {
            const value = {
                clientDataSetId: clientDataSetId.toString()
            };
            signature = await this.signWithMetaMask({ DeleteProofSet: EIP712_TYPES.DeleteProofSet }, value);
        }
        else {
            const value = {
                clientDataSetId: BigInt(clientDataSetId)
            };
            const actualSigner = this.getUnderlyingSigner();
            signature = await actualSigner.signTypedData(this.domain, { DeleteProofSet: EIP712_TYPES.DeleteProofSet }, value);
        }
        const sig = ethers.Signature.from(signature);
        const signedData = ethers.TypedDataEncoder.hash(this.domain, { DeleteProofSet: EIP712_TYPES.DeleteProofSet }, {
            clientDataSetId: BigInt(clientDataSetId)
        });
        return {
            signature,
            v: sig.v,
            r: sig.r,
            s: sig.s,
            signedData
        };
    }
    async getSignerAddress() {
        return await this.signer.getAddress();
    }
}
//# sourceMappingURL=auth.js.map