import type { ethers } from 'ethers';
import type { CommP } from './commp/index.js';
export type { CommP };
export type PrivateKey = string;
export type Address = string;
export type TokenAmount = number | bigint;
export type ProofSetId = string;
export type StorageProvider = string;
export type FilecoinNetworkType = 'mainnet' | 'calibration';
export type TokenIdentifier = 'USDFC' | string;
export interface SynapseOptions {
    privateKey?: PrivateKey;
    rpcURL?: string;
    authorization?: string;
    provider?: ethers.Provider;
    signer?: ethers.Signer;
    disableNonceManager?: boolean;
    withCDN?: boolean;
    pandoraAddress?: string;
    pdpVerifierAddress?: string;
    pieceRetriever?: PieceRetriever;
    subgraphService?: SubgraphRetrievalService;
    subgraphConfig?: SubgraphConfig;
}
export interface StorageOptions {
    proofSetId?: ProofSetId;
    storageProvider?: StorageProvider;
}
export interface UploadTask {
    commp: () => Promise<CommP>;
    store: () => Promise<StorageProvider>;
    done: () => Promise<string>;
}
export interface DownloadOptions {
}
export interface PieceRetriever {
    fetchPiece: (commp: CommP, client: string, options?: {
        providerAddress?: string;
        withCDN?: boolean;
        signal?: AbortSignal;
    }) => Promise<Response>;
}
export interface SubgraphConfig {
    endpoint?: string;
    goldsky?: {
        projectId: string;
        subgraphName: string;
        version: string;
    };
    apiKey?: string;
}
export interface SubgraphRetrievalService {
    getApprovedProvidersForCommP: (commP: CommP) => Promise<ApprovedProviderInfo[]>;
    getProviderByAddress: (address: string) => Promise<ApprovedProviderInfo | null>;
}
export interface AuthSignature {
    signature: string;
    v: number;
    r: string;
    s: string;
    signedData: string;
}
export interface RootData {
    cid: CommP | string;
    rawSize: number;
}
export interface ProofSetInfo {
    railId: number;
    payer: string;
    payee: string;
    commissionBps: number;
    metadata: string;
    rootMetadata: string[];
    clientDataSetId: number;
    withCDN: boolean;
}
export interface EnhancedProofSetInfo extends ProofSetInfo {
    pdpVerifierProofSetId: number;
    nextRootId: number;
    currentRootCount: number;
    isLive: boolean;
    isManaged: boolean;
}
export interface ApprovedProviderInfo {
    owner: string;
    pdpUrl: string;
    pieceRetrievalUrl: string;
    registeredAt: number;
    approvedAt: number;
}
export interface StorageCreationCallbacks {
    onProviderSelected?: (provider: ApprovedProviderInfo) => void;
    onProofSetResolved?: (info: {
        isExisting: boolean;
        proofSetId: number;
        provider: ApprovedProviderInfo;
    }) => void;
    onProofSetCreationStarted?: (transaction: ethers.TransactionResponse, statusUrl?: string) => void;
    onProofSetCreationProgress?: (status: {
        transactionMined: boolean;
        transactionSuccess: boolean;
        proofSetLive: boolean;
        serverConfirmed: boolean;
        proofSetId?: number;
        elapsedMs: number;
        receipt?: ethers.TransactionReceipt;
    }) => void;
}
export interface StorageServiceOptions {
    providerId?: number;
    providerAddress?: string;
    proofSetId?: number;
    withCDN?: boolean;
    callbacks?: StorageCreationCallbacks;
}
export interface PreflightInfo {
    estimatedCost: {
        perEpoch: bigint;
        perDay: bigint;
        perMonth: bigint;
    };
    allowanceCheck: {
        sufficient: boolean;
        message?: string;
    };
    selectedProvider: ApprovedProviderInfo;
    selectedProofSetId: number;
}
export interface UploadCallbacks {
    onUploadComplete?: (commp: CommP) => void;
    onRootAdded?: (transaction?: ethers.TransactionResponse) => void;
    onRootConfirmed?: (rootIds: number[]) => void;
}
export interface UploadResult {
    commp: CommP;
    size: number;
    rootId?: number;
}
export interface StorageInfo {
    pricing: {
        noCDN: {
            perTiBPerMonth: bigint;
            perTiBPerDay: bigint;
            perTiBPerEpoch: bigint;
        };
        withCDN: {
            perTiBPerMonth: bigint;
            perTiBPerDay: bigint;
            perTiBPerEpoch: bigint;
        };
        tokenAddress: string;
        tokenSymbol: string;
    };
    providers: ApprovedProviderInfo[];
    serviceParameters: {
        network: FilecoinNetworkType;
        epochsPerMonth: bigint;
        epochsPerDay: bigint;
        epochDuration: number;
        minUploadSize: number;
        maxUploadSize: number;
        pandoraAddress: string;
        paymentsAddress: string;
        pdpVerifierAddress: string;
    };
    allowances: {
        service: string;
        rateAllowance: bigint;
        lockupAllowance: bigint;
        rateUsed: bigint;
        lockupUsed: bigint;
    } | null;
}
export interface ProofSetData {
    id: number;
    roots: ProofSetRootData[];
    nextChallengeEpoch: number;
}
export interface ProofSetRootData {
    rootId: number;
    rootCid: CommP;
    subrootCid: CommP;
    subrootOffset: number;
}
export interface PieceStatus {
    exists: boolean;
    proofSetLastProven: Date | null;
    proofSetNextProofDue: Date | null;
    retrievalUrl: string | null;
    rootId?: number;
    inChallengeWindow?: boolean;
    hoursUntilChallengeWindow?: number;
    isProofOverdue?: boolean;
}
//# sourceMappingURL=types.d.ts.map