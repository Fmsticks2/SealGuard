!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("ethers")):"function"==typeof define&&define.amd?define("SynapseSDK",["ethers"],t):"object"==typeof exports?exports.SynapseSDK=t(require("ethers")):e.SynapseSDK=t(e.ethers)}(this,e=>(()=>{"use strict";var t={320:t=>{t.exports=e}},r={};function n(e){var o=r[e];if(void 0!==o)return o.exports;var i=r[e]={exports:{}};return t[e](i,i.exports,n),i.exports}n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var o={};n.d(o,{default:()=>Rn});var i={};n.r(i),n.d(i,{code:()=>Ue,digest:()=>Te,name:()=>Ee,size:()=>De});var s={};n.r(s),n.d(s,{computeNode:()=>Yt,create:()=>Zt,depth:()=>Wt,from:()=>Xt,offset:()=>Ht,path:()=>jt,resolveRoot:()=>Kt,truncate:()=>Jt,truncatedHash:()=>Qt,validateLevelIndex:()=>er,verify:()=>qt});var a={};n.r(a),n.d(a,{tD:()=>br,y1:()=>Ar});var c={};n.r(c),n.d(c,{FIL_COMMITMENT_UNSEALED:()=>Er,SHA2_256_TRUNC254_PADDED:()=>Dr,asCommP:()=>Tr,calculate:()=>$r,createCommPStream:()=>kr,downloadAndValidateCommP:()=>xr,downloadAndValidateCommPFromUrl:()=>Br,toPieceSize:()=>Nr,toZeroPaddedSize:()=>Rr});var d={};n.r(d),n.d(d,{PDPAuthHelper:()=>hn,PDPServer:()=>ln,PDPVerifier:()=>gn,asProofSetData:()=>dn,asProofSetRootData:()=>cn,isFindPieceResponse:()=>nn,isProofSetCreationStatusResponse:()=>tn,isRootAdditionStatusResponse:()=>rn,validateFindPieceResponse:()=>an,validateProofSetCreationStatusResponse:()=>on,validateRootAdditionStatusResponse:()=>sn});var l={};n.r(l),n.d(l,{CHAIN_IDS:()=>Fr,CONTRACT_ABIS:()=>Lr,CONTRACT_ADDRESSES:()=>qr,GENESIS_TIMESTAMPS:()=>Vr,MULTIHASH_CODES:()=>Gr,PDPAuthHelper:()=>hn,PDPServer:()=>ln,PDPVerifier:()=>gn,PandoraService:()=>wn,PaymentsService:()=>fn,RPC_URLS:()=>Wr,SIZE_CONSTANTS:()=>jr,StorageService:()=>pn,SubgraphService:()=>An,Synapse:()=>Dn,TIME_CONSTANTS:()=>zr,TIMING_CONSTANTS:()=>Hr,TOKENS:()=>Or,asProofSetData:()=>dn,asProofSetRootData:()=>cn,calculateLastProofDate:()=>Zr,constructFindPieceUrl:()=>en,constructPieceUrl:()=>Xr,createError:()=>Mr,dateToEpoch:()=>Qr,epochToDate:()=>Kr,getGenesisTimestamp:()=>Yr,isFindPieceResponse:()=>nn,isProofSetCreationStatusResponse:()=>tn,isRootAdditionStatusResponse:()=>rn,timeUntilEpoch:()=>Jr,validateFindPieceResponse:()=>an,validateProofSetCreationStatusResponse:()=>on,validateRootAdditionStatusResponse:()=>sn});var u=n(320);const h=new Uint8Array(0);function p(e){return e.reduce((e,t)=>e+t.toString(16).padStart(2,"0"),"")}function f(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0}function g(e){if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")}const w=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<e.length;o++){var i=e.charAt(o),s=i.charCodeAt(0);if(255!==r[s])throw new TypeError(i+" is ambiguous");r[s]=o}var a=e.length,c=e.charAt(0),d=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function u(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var n=0,o=0;e[t]===c;)n++,t++;for(var i=(e.length-t)*d+1>>>0,s=new Uint8Array(i);e[t];){var l=r[e.charCodeAt(t)];if(255===l)return;for(var u=0,h=i-1;(0!==l||u<o)&&-1!==h;h--,u++)l+=a*s[h]>>>0,s[h]=l%256>>>0,l=l/256>>>0;if(0!==l)throw new Error("Non-zero carry");o=u,t++}if(" "!==e[t]){for(var p=i-o;p!==i&&0===s[p];)p++;for(var f=new Uint8Array(n+(i-p)),g=n;p!==i;)f[g++]=s[p++];return f}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,o=0,i=t.length;o!==i&&0===t[o];)o++,r++;for(var s=(i-o)*l+1>>>0,d=new Uint8Array(s);o!==i;){for(var u=t[o],h=0,p=s-1;(0!==u||h<n)&&-1!==p;p--,h++)u+=256*d[p]>>>0,d[p]=u%a>>>0,u=u/a>>>0;if(0!==u)throw new Error("Non-zero carry");n=h,o++}for(var f=s-n;f!==s&&0===d[f];)f++;for(var g=c.repeat(r);f<s;++f)g+=e.charAt(d[f]);return g},decodeUnsafe:u,decode:function(e){var r=u(e);if(r)return r;throw new Error(`Non-${t} character`)}}};class v{name;prefix;baseEncode;constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class y{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,r){this.name=e,this.prefix=t;const n=t.codePointAt(0);if(void 0===n)throw new Error("Invalid prefix character");this.prefixCodePoint=n,this.baseDecode=r}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return m(this,e)}}class S{decoders;constructor(e){this.decoders=e}or(e){return m(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(null!=r)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function m(e,t){return new S({...e.decoders??{[e.prefix]:e},...t.decoders??{[t.prefix]:t}})}class P{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,r,n){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=n,this.encoder=new v(e,t,r),this.decoder=new y(e,t,n)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function b({name:e,prefix:t,encode:r,decode:n}){return new P(e,t,r,n)}function A({name:e,prefix:t,alphabet:r}){const{encode:n,decode:o}=w(r,e);return b({prefix:t,name:e,encode:n,decode:e=>g(o(e))})}function C({name:e,prefix:t,bitsPerChar:r,alphabet:n}){const o=function(e){const t={};for(let r=0;r<e.length;++r)t[e[r]]=r;return t}(n);return b({prefix:t,name:e,encode:e=>function(e,t,r){const n="="===t[t.length-1],o=(1<<r)-1;let i="",s=0,a=0;for(let n=0;n<e.length;++n)for(a=a<<8|e[n],s+=8;s>r;)s-=r,i+=t[o&a>>s];if(0!==s&&(i+=t[o&a<<r-s]),n)for(;i.length*r&7;)i+="=";return i}(e,n,r),decode:t=>function(e,t,r,n){let o=e.length;for(;"="===e[o-1];)--o;const i=new Uint8Array(o*r/8|0);let s=0,a=0,c=0;for(let d=0;d<o;++d){const o=t[e[d]];if(void 0===o)throw new SyntaxError(`Non-${n} character`);a=a<<r|o,s+=r,s>=8&&(s-=8,i[c++]=255&a>>s)}if(s>=r||255&a<<8-s)throw new SyntaxError("Unexpected end of data");return i}(t,o,r,e)})}const I=C({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),_=(C({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),C({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),C({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),C({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),C({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),C({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),C({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),C({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),A({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"})),E=(A({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),A({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}));A({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var D=128,R=-128,N=Math.pow(2,31),T=128,U=127,$=Math.pow(2,7),k=Math.pow(2,14),x=Math.pow(2,21),B=Math.pow(2,28),M=Math.pow(2,35),O=Math.pow(2,42),F=Math.pow(2,49),L=Math.pow(2,56),z=Math.pow(2,63);const V={encode:function e(t,r,n){r=r||[];for(var o=n=n||0;t>=N;)r[n++]=255&t|D,t/=128;for(;t&R;)r[n++]=255&t|D,t>>>=7;return r[n]=0|t,e.bytes=n-o+1,r},decode:function e(t,r){var n,o=0,i=(r=r||0,0),s=r,a=t.length;do{if(s>=a)throw e.bytes=0,new RangeError("Could not decode varint");n=t[s++],o+=i<28?(n&U)<<i:(n&U)*Math.pow(2,i),i+=7}while(n>=T);return e.bytes=s-r,o},encodingLength:function(e){return e<$?1:e<k?2:e<x?3:e<B?4:e<M?5:e<O?6:e<F?7:e<L?8:e<z?9:10}};function j(e,t=0){return[V.decode(e,t),V.decode.bytes]}function H(e,t,r=0){return V.encode(e,t,r),t}function W(e){return V.encodingLength(e)}function q(e,t){const r=t.byteLength,n=W(e),o=n+W(r),i=new Uint8Array(o+r);return H(e,i,0),H(r,i,n),i.set(t,o),new G(e,r,t,i)}class G{code;size;digest;bytes;constructor(e,t,r,n){this.code=e,this.size=t,this.digest=r,this.bytes=n}}function K(e,t){const{bytes:r,version:n}=e;return 0===n?function(e,t,r){const{prefix:n}=r;if(n!==E.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const o=t.get(n);if(null==o){const o=r.encode(e).slice(1);return t.set(n,o),o}return o}(r,Y(e),t??E.encoder):function(e,t,r){const{prefix:n}=r,o=t.get(n);if(null==o){const o=r.encode(e);return t.set(n,o),o}return o}(r,Y(e),t??I.encoder)}const Q=new WeakMap;function Y(e){const t=Q.get(e);if(null==t){const t=new Map;return Q.set(e,t),t}return t}class J{code;version;multihash;bytes;"/";constructor(e,t,r,n){this.code=t,this.version=e,this.multihash=r,this.bytes=n,this["/"]=n}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==Z)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==X)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return J.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=q(e,t);return J.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return J.equals(this,e)}static equals(e,t){const r=t;return null!=r&&e.code===r.code&&e.version===r.version&&function(e,t){if(e===t)return!0;{const r=t;return e.code===r.code&&e.size===r.size&&r.bytes instanceof Uint8Array&&f(e.bytes,r.bytes)}}(e.multihash,r.multihash)}toString(e){return K(this,e)}toJSON(){return{"/":K(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(null==e)return null;const t=e;if(t instanceof J)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:r,multihash:n,bytes:o}=t;return new J(e,r,n,o??ee(e,r,n.bytes))}if(!0===t[te]){const{version:e,multihash:r,code:n}=t,o=function(e){const t=g(e),[r,n]=j(t),[o,i]=j(t.subarray(n)),s=t.subarray(n+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new G(r,o,s,t)}(r);return J.create(e,n,o)}return null}static create(e,t,r){if("number"!=typeof t)throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==Z)throw new Error(`Version 0 CID must use dag-pb (code: ${Z}) block encoding`);return new J(e,t,r,r.bytes);case 1:{const n=ee(e,t,r.bytes);return new J(e,t,r,n)}default:throw new Error("Invalid version")}}static createV0(e){return J.create(0,Z,e)}static createV1(e,t){return J.create(1,e,t)}static decode(e){const[t,r]=J.decodeFirst(e);if(0!==r.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=J.inspectBytes(e),r=t.size-t.multihashSize,n=g(e.subarray(r,r+t.multihashSize));if(n.byteLength!==t.multihashSize)throw new Error("Incorrect length");const o=n.subarray(t.multihashSize-t.digestSize),i=new G(t.multihashCode,t.digestSize,o,n);return[0===t.version?J.createV0(i):J.createV1(t.codec,i),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[r,n]=j(e.subarray(t));return t+=n,r};let n=r(),o=Z;if(18===n?(n=0,t=0):o=r(),0!==n&&1!==n)throw new RangeError(`Invalid CID version ${n}`);const i=t,s=r(),a=r(),c=t+a;return{version:n,codec:o,multihashCode:s,digestSize:a,multihashSize:c-i,size:c}}static parse(e,t){const[r,n]=function(e,t){switch(e[0]){case"Q":{const r=t??E;return[E.prefix,r.decode(`${E.prefix}${e}`)]}case E.prefix:{const r=t??E;return[E.prefix,r.decode(e)]}case I.prefix:{const r=t??I;return[I.prefix,r.decode(e)]}case _.prefix:{const r=t??_;return[_.prefix,r.decode(e)]}default:if(null==t)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}}(e,t),o=J.decode(n);if(0===o.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return Y(o).set(r,e),o}}const Z=112,X=18;function ee(e,t,r){const n=W(e),o=n+W(t),i=new Uint8Array(o+r.byteLength);return H(e,i,0),H(t,i,n),i.set(r,o),i}const te=Symbol.for("@ipld/js-cid/CID"),re=(BigInt(4),254),ne=127,oe=BigInt(ne),ie=BigInt(128),se=.9921875,ae=32,ce=BigInt(ae),de=2*ae+1,le=()=>ue,ue=(e=>{if(e instanceof Uint8Array){if(e.length>ae)return e.subarray(0,ae);if(e.length==ae)return e}const t=new Uint8Array(ae);return t.set([...e]),t})(new Uint8Array(ae).fill(0));function he(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function pe(e,t){!function(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}Object.freeze(ue.buffer);const fe=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),ge=(e,t)=>e<<32-t|e>>>t;if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error("Non little-endian hardware is not supported");function we(e){if("string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),!(e instanceof Uint8Array))throw new Error("expected Uint8Array, got "+typeof e);return e}class ve{clone(){return this._cloneInto()}}function ye(e){const t=t=>e().update(we(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}class Se extends ve{constructor(e,t,r,n){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=fe(this.buffer)}update(e){he(this);const{view:t,buffer:r,blockLen:n}=this,o=(e=we(e)).length;for(let i=0;i<o;){const s=Math.min(n-this.pos,o-i);if(s===n){const t=fe(e);for(;n<=o-i;i+=n)this.process(t,i);continue}r.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===n&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){he(this),pe(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>n-i&&(this.process(r,0),i=0);for(let e=i;e<n;e++)t[e]=0;!function(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),a=Number(r&i),c=n?4:0,d=n?0:4;e.setUint32(t+c,s,n),e.setUint32(t+d,a,n)}(r,n-8,BigInt(8*this.length),o),this.process(r,0);const s=fe(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,d=this.get();if(c>d.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)s.setUint32(4*e,d[e],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:o,destroyed:i,pos:s}=this;return e.length=n,e.pos=s,e.finished=o,e.destroyed=i,n%t&&e.buffer.set(r),e}}const me=(e,t,r)=>e&t^~e&r,Pe=(e,t,r)=>e&t^e&r^t&r,be=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Ae=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Ce=new Uint32Array(64);class Ie extends Se{constructor(){super(64,32,8,!1),this.A=0|Ae[0],this.B=0|Ae[1],this.C=0|Ae[2],this.D=0|Ae[3],this.E=0|Ae[4],this.F=0|Ae[5],this.G=0|Ae[6],this.H=0|Ae[7]}get(){const{A:e,B:t,C:r,D:n,E:o,F:i,G:s,H:a}=this;return[e,t,r,n,o,i,s,a]}set(e,t,r,n,o,i,s,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)Ce[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=Ce[e-15],r=Ce[e-2],n=ge(t,7)^ge(t,18)^t>>>3,o=ge(r,17)^ge(r,19)^r>>>10;Ce[e]=o+Ce[e-7]+n+Ce[e-16]|0}let{A:r,B:n,C:o,D:i,E:s,F:a,G:c,H:d}=this;for(let e=0;e<64;e++){const t=d+(ge(s,6)^ge(s,11)^ge(s,25))+me(s,a,c)+be[e]+Ce[e]|0,l=(ge(r,2)^ge(r,13)^ge(r,22))+Pe(r,n,o)|0;d=c,c=a,a=s,s=i+t|0,i=o,o=n,n=r,r=t+l|0}r=r+this.A|0,n=n+this.B|0,o=o+this.C|0,i=i+this.D|0,s=s+this.E|0,a=a+this.F|0,c=c+this.G|0,d=d+this.H|0,this.set(r,n,o,i,s,a,c,d)}roundClean(){Ce.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const _e=ye(()=>new Ie),Ee="sha2-256",De=32,Re=new Uint8Array([18,32]);class Ne{constructor(e){this.code=18,this.name=Ee,this.bytes=e,this.size=De,this.digest=e.subarray(2)}}const Te=e=>{const t=new Uint8Array(Re.length+De);return t.set(Re,0),t.set(_e(e),Re.length),new Ne(t)},Ue=18,$e=["string","number","bigint","symbol"],ke=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];class xe{constructor(e,t,r){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=r}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}xe.uint=new xe(0,"uint",!0),xe.negint=new xe(1,"negint",!0),xe.bytes=new xe(2,"bytes",!0),xe.string=new xe(3,"string",!0),xe.array=new xe(4,"array",!1),xe.map=new xe(5,"map",!1),xe.tag=new xe(6,"tag",!1),xe.float=new xe(7,"float",!0),xe.false=new xe(7,"false",!0),xe.true=new xe(7,"true",!0),xe.null=new xe(7,"null",!0),xe.undefined=new xe(7,"undefined",!0),xe.break=new xe(7,"break",!0);class Be{constructor(e,t,r){this.type=e,this.value=t,this.encodedLength=r,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const Me=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"==typeof globalThis.Buffer.isBuffer,Oe=new TextDecoder,Fe=new TextEncoder;function Le(e){return Me&&globalThis.Buffer.isBuffer(e)}const ze=Me?(e,t,r)=>r-t>64?globalThis.Buffer.from(e.subarray(t,r)).toString("utf8"):Ge(e,t,r):(e,t,r)=>r-t>64?Oe.decode(e.subarray(t,r)):Ge(e,t,r),Ve=Me?e=>e.length>64?globalThis.Buffer.from(e):qe(e):e=>e.length>64?Fe.encode(e):qe(e),je=Me?(e,t,r)=>Le(e)?new Uint8Array(e.subarray(t,r)):e.slice(t,r):(e,t,r)=>e.slice(t,r),He=Me?(e,t)=>{return e=e.map(e=>e instanceof Uint8Array?e:globalThis.Buffer.from(e)),(r=globalThis.Buffer.concat(e,t))instanceof Uint8Array?Le(r)?new Uint8Array(r.buffer,r.byteOffset,r.byteLength):r:Uint8Array.from(r);var r}:(e,t)=>{const r=new Uint8Array(t);let n=0;for(let t of e)n+t.length>r.length&&(t=t.subarray(0,r.length-n)),r.set(t,n),n+=t.length;return r},We=Me?e=>globalThis.Buffer.allocUnsafe(e):e=>new Uint8Array(e);function qe(e){const t=[];let r=0;for(let n=0;n<e.length;n++){let o=e.charCodeAt(n);o<128?t[r++]=o:o<2048?(t[r++]=o>>6|192,t[r++]=63&o|128):55296==(64512&o)&&n+1<e.length&&56320==(64512&e.charCodeAt(n+1))?(o=65536+((1023&o)<<10)+(1023&e.charCodeAt(++n)),t[r++]=o>>18|240,t[r++]=o>>12&63|128,t[r++]=o>>6&63|128,t[r++]=63&o|128):(t[r++]=o>>12|224,t[r++]=o>>6&63|128,t[r++]=63&o|128)}return t}function Ge(e,t,r){const n=[];for(;t<r;){const o=e[t];let i=null,s=o>239?4:o>223?3:o>191?2:1;if(t+s<=r){let r,n,a,c;switch(s){case 1:o<128&&(i=o);break;case 2:r=e[t+1],128==(192&r)&&(c=(31&o)<<6|63&r,c>127&&(i=c));break;case 3:r=e[t+1],n=e[t+2],128==(192&r)&&128==(192&n)&&(c=(15&o)<<12|(63&r)<<6|63&n,c>2047&&(c<55296||c>57343)&&(i=c));break;case 4:r=e[t+1],n=e[t+2],a=e[t+3],128==(192&r)&&128==(192&n)&&128==(192&a)&&(c=(15&o)<<18|(63&r)<<12|(63&n)<<6|63&a,c>65535&&c<1114112&&(i=c))}}null===i?(i=65533,s=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|1023&i),n.push(i),t+=s}return function(e){const t=e.length;if(t<=Ke)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=Ke));return r}(n)}const Ke=4096;const Qe="CBOR decode error:",Ye="CBOR encode error:",Je=[];function Ze(e,t,r){if(e.length-t<r)throw new Error(`${Qe} not enough data for type`)}Je[23]=1,Je[24]=2,Je[25]=3,Je[26]=5,Je[27]=9;const Xe=[24,256,65536,4294967296,BigInt("18446744073709551616")];function et(e,t,r){Ze(e,t,1);const n=e[t];if(!0===r.strict&&n<Xe[0])throw new Error(`${Qe} integer encoded in more bytes than necessary (strict decode)`);return n}function tt(e,t,r){Ze(e,t,2);const n=e[t]<<8|e[t+1];if(!0===r.strict&&n<Xe[1])throw new Error(`${Qe} integer encoded in more bytes than necessary (strict decode)`);return n}function rt(e,t,r){Ze(e,t,4);const n=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3];if(!0===r.strict&&n<Xe[2])throw new Error(`${Qe} integer encoded in more bytes than necessary (strict decode)`);return n}function nt(e,t,r){Ze(e,t,8);const n=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3],o=16777216*e[t+4]+(e[t+5]<<16)+(e[t+6]<<8)+e[t+7],i=(BigInt(n)<<BigInt(32))+BigInt(o);if(!0===r.strict&&i<Xe[3])throw new Error(`${Qe} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(!0===r.allowBigInt)return i;throw new Error(`${Qe} integers outside of the safe integer range are not supported`)}function ot(e,t){return it(e,0,t.value)}function it(e,t,r){if(r<Xe[0]){const n=Number(r);e.push([t|n])}else if(r<Xe[1]){const n=Number(r);e.push([24|t,n])}else if(r<Xe[2]){const n=Number(r);e.push([25|t,n>>>8,255&n])}else if(r<Xe[3]){const n=Number(r);e.push([26|t,n>>>24&255,n>>>16&255,n>>>8&255,255&n])}else{const n=BigInt(r);if(!(n<Xe[4]))throw new Error(`${Qe} encountered BigInt larger than allowable range`);{const r=[27|t,0,0,0,0,0,0,0];let o=Number(n&BigInt(4294967295)),i=Number(n>>BigInt(32)&BigInt(4294967295));r[8]=255&o,o>>=8,r[7]=255&o,o>>=8,r[6]=255&o,o>>=8,r[5]=255&o,r[4]=255&i,i>>=8,r[3]=255&i,i>>=8,r[2]=255&i,i>>=8,r[1]=255&i,e.push(r)}}}ot.encodedSize=function(e){return it.encodedSize(e.value)},it.encodedSize=function(e){return e<Xe[0]?1:e<Xe[1]?2:e<Xe[2]?3:e<Xe[3]?5:9},ot.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};const st=BigInt(-1),at=BigInt(1);function ct(e,t){const r=t.value,n="bigint"==typeof r?r*st-at:-1*r-1;it(e,t.type.majorEncoded,n)}function dt(e,t,r,n){Ze(e,t,r+n);const o=je(e,t+r,t+r+n);return new Be(xe.bytes,o,r+n)}function lt(e,t,r,n){return dt(e,t,1,r)}function ut(e){return void 0===e.encodedBytes&&(e.encodedBytes=e.type===xe.string?Ve(e.value):e.value),e.encodedBytes}function ht(e,t){const r=ut(t);it(e,t.type.majorEncoded,r.length),e.push(r)}function pt(e,t,r,n,o){const i=r+n;Ze(e,t,i);const s=new Be(xe.string,ze(e,t+r,t+i),i);return!0===o.retainStringBytes&&(s.byteValue=je(e,t+r,t+i)),s}function ft(e,t,r,n){return pt(e,t,1,r,n)}ct.encodedSize=function(e){const t=e.value,r="bigint"==typeof t?t*st-at:-1*t-1;return r<Xe[0]?1:r<Xe[1]?2:r<Xe[2]?3:r<Xe[3]?5:9},ct.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0},ht.encodedSize=function(e){const t=ut(e);return it.encodedSize(t.length)+t.length},ht.compareTokens=function(e,t){return r=ut(e),n=ut(t),r.length<n.length?-1:r.length>n.length?1:function(e,t){if(Le(e)&&Le(t))return e.compare(t);for(let r=0;r<e.length;r++)if(e[r]!==t[r])return e[r]<t[r]?-1:1;return 0}(r,n);var r,n};const gt=ht;function wt(e,t,r,n){return new Be(xe.array,n,r)}function vt(e,t,r,n){return wt(0,0,1,r)}function yt(e,t){it(e,xe.array.majorEncoded,t.value)}function St(e,t,r,n){return new Be(xe.map,n,r)}function mt(e,t,r,n){return St(0,0,1,r)}function Pt(e,t){it(e,xe.map.majorEncoded,t.value)}function bt(e,t,r,n){return new Be(xe.tag,r,1)}function At(e,t){it(e,xe.tag.majorEncoded,t.value)}function Ct(e,t,r){if(r){if(!1===r.allowNaN&&Number.isNaN(e))throw new Error(`${Qe} NaN values are not supported`);if(!1===r.allowInfinity&&(e===1/0||e===-1/0))throw new Error(`${Qe} Infinity values are not supported`)}return new Be(xe.float,e,t)}function It(e,t,r){const n=t.value;if(!1===n)e.push([20|xe.float.majorEncoded]);else if(!0===n)e.push([21|xe.float.majorEncoded]);else if(null===n)e.push([22|xe.float.majorEncoded]);else if(void 0===n)e.push([23|xe.float.majorEncoded]);else{let t,i=!1;r&&!0===r.float64||(Rt(n),t=Nt(Dt,1),n===t||Number.isNaN(n)?(Dt[0]=249,e.push(Dt.slice(0,3)),i=!0):(Tt(n),t=Ut(Dt,1),n===t&&(Dt[0]=250,e.push(Dt.slice(0,5)),i=!0))),i||(o=n,Et.setFloat64(0,o,!1),t=$t(Dt,1),Dt[0]=251,e.push(Dt.slice(0,9)))}var o}yt.compareTokens=ot.compareTokens,yt.encodedSize=function(e){return it.encodedSize(e.value)},Pt.compareTokens=ot.compareTokens,Pt.encodedSize=function(e){return it.encodedSize(e.value)},At.compareTokens=ot.compareTokens,At.encodedSize=function(e){return it.encodedSize(e.value)},It.encodedSize=function(e,t){const r=e.value;if(!1===r||!0===r||null==r)return 1;if(!t||!0!==t.float64){Rt(r);let e=Nt(Dt,1);if(r===e||Number.isNaN(r))return 3;if(Tt(r),e=Ut(Dt,1),r===e)return 5}return 9};const _t=new ArrayBuffer(9),Et=new DataView(_t,1),Dt=new Uint8Array(_t,0);function Rt(e){if(e===1/0)Et.setUint16(0,31744,!1);else if(e===-1/0)Et.setUint16(0,64512,!1);else if(Number.isNaN(e))Et.setUint16(0,32256,!1);else{Et.setFloat32(0,e);const t=Et.getUint32(0),r=(2139095040&t)>>23,n=8388607&t;if(255===r)Et.setUint16(0,31744,!1);else if(0===r)Et.setUint16(0,(2147483648&e)>>16|n>>13,!1);else{const e=r-127;e<-24?Et.setUint16(0,0):e<-14?Et.setUint16(0,(2147483648&t)>>16|1<<24+e,!1):Et.setUint16(0,(2147483648&t)>>16|e+15<<10|n>>13,!1)}}}function Nt(e,t){if(e.length-t<2)throw new Error(`${Qe} not enough data for float16`);const r=(e[t]<<8)+e[t+1];if(31744===r)return 1/0;if(64512===r)return-1/0;if(32256===r)return NaN;const n=r>>10&31,o=1023&r;let i;return i=0===n?o*2**-24:31!==n?(o+1024)*2**(n-25):0===o?1/0:NaN,32768&r?-i:i}function Tt(e){Et.setFloat32(0,e,!1)}function Ut(e,t){if(e.length-t<4)throw new Error(`${Qe} not enough data for float32`);const r=(e.byteOffset||0)+t;return new DataView(e.buffer,r,4).getFloat32(0,!1)}function $t(e,t){if(e.length-t<8)throw new Error(`${Qe} not enough data for float64`);const r=(e.byteOffset||0)+t;return new DataView(e.buffer,r,8).getFloat64(0,!1)}function kt(e,t,r){throw new Error(`${Qe} encountered invalid minor (${r}) for major ${e[t]>>>5}`)}function xt(e){return()=>{throw new Error(`${Qe} ${e}`)}}It.compareTokens=ot.compareTokens;const Bt=[];for(let e=0;e<=23;e++)Bt[e]=kt;Bt[24]=function(e,t,r,n){return new Be(xe.uint,et(e,t+1,n),2)},Bt[25]=function(e,t,r,n){return new Be(xe.uint,tt(e,t+1,n),3)},Bt[26]=function(e,t,r,n){return new Be(xe.uint,rt(e,t+1,n),5)},Bt[27]=function(e,t,r,n){return new Be(xe.uint,nt(e,t+1,n),9)},Bt[28]=kt,Bt[29]=kt,Bt[30]=kt,Bt[31]=kt;for(let e=32;e<=55;e++)Bt[e]=kt;Bt[56]=function(e,t,r,n){return new Be(xe.negint,-1-et(e,t+1,n),2)},Bt[57]=function(e,t,r,n){return new Be(xe.negint,-1-tt(e,t+1,n),3)},Bt[58]=function(e,t,r,n){return new Be(xe.negint,-1-rt(e,t+1,n),5)},Bt[59]=function(e,t,r,n){const o=nt(e,t+1,n);if("bigint"!=typeof o){const e=-1-o;if(e>=Number.MIN_SAFE_INTEGER)return new Be(xe.negint,e,9)}if(!0!==n.allowBigInt)throw new Error(`${Qe} integers outside of the safe integer range are not supported`);return new Be(xe.negint,st-BigInt(o),9)},Bt[60]=kt,Bt[61]=kt,Bt[62]=kt,Bt[63]=kt;for(let e=64;e<=87;e++)Bt[e]=lt;Bt[88]=function(e,t,r,n){return dt(e,t,2,et(e,t+1,n))},Bt[89]=function(e,t,r,n){return dt(e,t,3,tt(e,t+1,n))},Bt[90]=function(e,t,r,n){return dt(e,t,5,rt(e,t+1,n))},Bt[91]=function(e,t,r,n){const o=nt(e,t+1,n);if("bigint"==typeof o)throw new Error(`${Qe} 64-bit integer bytes lengths not supported`);return dt(e,t,9,o)},Bt[92]=kt,Bt[93]=kt,Bt[94]=kt,Bt[95]=xt("indefinite length bytes/strings are not supported");for(let e=96;e<=119;e++)Bt[e]=ft;Bt[120]=function(e,t,r,n){return pt(e,t,2,et(e,t+1,n),n)},Bt[121]=function(e,t,r,n){return pt(e,t,3,tt(e,t+1,n),n)},Bt[122]=function(e,t,r,n){return pt(e,t,5,rt(e,t+1,n),n)},Bt[123]=function(e,t,r,n){const o=nt(e,t+1,n);if("bigint"==typeof o)throw new Error(`${Qe} 64-bit integer string lengths not supported`);return pt(e,t,9,o,n)},Bt[124]=kt,Bt[125]=kt,Bt[126]=kt,Bt[127]=xt("indefinite length bytes/strings are not supported");for(let e=128;e<=151;e++)Bt[e]=vt;Bt[152]=function(e,t,r,n){return wt(0,0,2,et(e,t+1,n))},Bt[153]=function(e,t,r,n){return wt(0,0,3,tt(e,t+1,n))},Bt[154]=function(e,t,r,n){return wt(0,0,5,rt(e,t+1,n))},Bt[155]=function(e,t,r,n){const o=nt(e,t+1,n);if("bigint"==typeof o)throw new Error(`${Qe} 64-bit integer array lengths not supported`);return wt(0,0,9,o)},Bt[156]=kt,Bt[157]=kt,Bt[158]=kt,Bt[159]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${Qe} indefinite length items not allowed`);return wt(0,0,1,1/0)};for(let e=160;e<=183;e++)Bt[e]=mt;Bt[184]=function(e,t,r,n){return St(0,0,2,et(e,t+1,n))},Bt[185]=function(e,t,r,n){return St(0,0,3,tt(e,t+1,n))},Bt[186]=function(e,t,r,n){return St(0,0,5,rt(e,t+1,n))},Bt[187]=function(e,t,r,n){const o=nt(e,t+1,n);if("bigint"==typeof o)throw new Error(`${Qe} 64-bit integer map lengths not supported`);return St(0,0,9,o)},Bt[188]=kt,Bt[189]=kt,Bt[190]=kt,Bt[191]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${Qe} indefinite length items not allowed`);return St(0,0,1,1/0)};for(let e=192;e<=215;e++)Bt[e]=bt;Bt[216]=function(e,t,r,n){return new Be(xe.tag,et(e,t+1,n),2)},Bt[217]=function(e,t,r,n){return new Be(xe.tag,tt(e,t+1,n),3)},Bt[218]=function(e,t,r,n){return new Be(xe.tag,rt(e,t+1,n),5)},Bt[219]=function(e,t,r,n){return new Be(xe.tag,nt(e,t+1,n),9)},Bt[220]=kt,Bt[221]=kt,Bt[222]=kt,Bt[223]=kt;for(let e=224;e<=243;e++)Bt[e]=xt("simple values are not supported");Bt[244]=kt,Bt[245]=kt,Bt[246]=kt,Bt[247]=function(e,t,r,n){if(!1===n.allowUndefined)throw new Error(`${Qe} undefined values are not supported`);return!0===n.coerceUndefinedToNull?new Be(xe.null,null,1):new Be(xe.undefined,void 0,1)},Bt[248]=xt("simple values are not supported"),Bt[249]=function(e,t,r,n){return Ct(Nt(e,t+1),3,n)},Bt[250]=function(e,t,r,n){return Ct(Ut(e,t+1),5,n)},Bt[251]=function(e,t,r,n){return Ct($t(e,t+1),9,n)},Bt[252]=kt,Bt[253]=kt,Bt[254]=kt,Bt[255]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${Qe} indefinite length items not allowed`);return new Be(xe.break,void 0,1)};const Mt=[];for(let e=0;e<24;e++)Mt[e]=new Be(xe.uint,e,1);for(let e=-1;e>=-24;e--)Mt[31-e]=new Be(xe.negint,e,1);Mt[64]=new Be(xe.bytes,new Uint8Array(0),1),Mt[96]=new Be(xe.string,"",1),Mt[128]=new Be(xe.array,0,1),Mt[160]=new Be(xe.map,0,1),Mt[244]=new Be(xe.false,!1,1),Mt[245]=new Be(xe.true,!0,1),Mt[246]=new Be(xe.null,null,1),function(){const e=[];e[xe.uint.major]=ot,e[xe.negint.major]=ct,e[xe.bytes.major]=ht,e[xe.string.major]=gt,e[xe.array.major]=yt,e[xe.map.major]=Pt,e[xe.tag.major]=At,e[xe.float.major]=It}(),new class{constructor(e=256){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),null!==this._initReuseChunk&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let t=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const r=t.length-(this.maxCursor-this.cursor)-1;t.set(e,r)}else{if(t){const e=t.length-(this.maxCursor-this.cursor)-1;e<t.length&&(this.chunks[this.chunks.length-1]=t.subarray(0,e),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(t=We(this.chunkSize),this.chunks.push(t),this.maxCursor+=t.length,null===this._initReuseChunk&&(this._initReuseChunk=t),t.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let t;if(1===this.chunks.length){const r=this.chunks[0];e&&this.cursor>r.length/2?(t=this.cursor===r.length?r:r.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):t=je(r,0,this.cursor)}else t=He(this.chunks,this.cursor);return e&&this.reset(),t}};class Ot{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do{if(t.obj===e)return!0}while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${Ye} object contains circular references`);return new Ot(t,e)}}const Ft={null:new Be(xe.null,null),undefined:new Be(xe.undefined,void 0),true:new Be(xe.true,!0),false:new Be(xe.false,!1),emptyArray:new Be(xe.array,0),emptyMap:new Be(xe.map,0)},Lt={number:(e,t,r,n)=>Number.isInteger(e)&&Number.isSafeInteger(e)?new Be(e>=0?xe.uint:xe.negint,e):new Be(xe.float,e),bigint:(e,t,r,n)=>e>=BigInt(0)?new Be(xe.uint,e):new Be(xe.negint,e),Uint8Array:(e,t,r,n)=>new Be(xe.bytes,e),string:(e,t,r,n)=>new Be(xe.string,e),boolean:(e,t,r,n)=>e?Ft.true:Ft.false,null:(e,t,r,n)=>Ft.null,undefined:(e,t,r,n)=>Ft.undefined,ArrayBuffer:(e,t,r,n)=>new Be(xe.bytes,new Uint8Array(e)),DataView:(e,t,r,n)=>new Be(xe.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,t,r,n){if(!e.length)return!0===r.addBreakTokens?[Ft.emptyArray,new Be(xe.break)]:Ft.emptyArray;n=Ot.createCheck(n,e);const o=[];let i=0;for(const t of e)o[i++]=zt(t,r,n);return r.addBreakTokens?[new Be(xe.array,e.length),o,new Be(xe.break)]:[new Be(xe.array,e.length),o]},Object(e,t,r,n){const o="Object"!==t,i=o?e.keys():Object.keys(e),s=o?e.size:i.length;if(!s)return!0===r.addBreakTokens?[Ft.emptyMap,new Be(xe.break)]:Ft.emptyMap;n=Ot.createCheck(n,e);const a=[];let c=0;for(const t of i)a[c++]=[zt(t,r,n),zt(o?e.get(t):e[t],r,n)];return function(e,t){t.mapSorter&&e.sort(t.mapSorter)}(a,r),r.addBreakTokens?[new Be(xe.map,s),a,new Be(xe.break)]:[new Be(xe.map,s),a]}};Lt.Map=Lt.Object,Lt.Buffer=Lt.Uint8Array;for(const e of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))Lt[`${e}Array`]=Lt.DataView;function zt(e,t={},r){const n=function(e){if(null===e)return"null";if(void 0===e)return"undefined";if(!0===e||!1===e)return"boolean";const t=typeof e;if($e.includes(t))return t;if("function"===t)return"Function";if(Array.isArray(e))return"Array";if(function(e){return e&&e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer.call(null,e)}(e))return"Buffer";return function(e){const t=Object.prototype.toString.call(e).slice(8,-1);if(ke.includes(t))return t}(e)||"Object"}(e),o=t&&t.typeEncoders&&t.typeEncoders[n]||Lt[n];if("function"==typeof o){const i=o(e,n,t,r);if(null!=i)return i}const i=Lt[n];if(!i)throw new Error(`${Ye} unsupported type: ${n}`);return i(e,n,t,r)}Symbol.for("DONE"),Symbol.for("BREAK");const Vt={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,rejectDuplicateMapKeys:!0,tags:[]};Vt.tags[42]=function(e){if(0!==e[0])throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return J.decode(e.subarray(1))},Vt.tags.slice();const jt=([,e])=>e,Ht=([e])=>e,Wt=e=>jt(e).length,qt=(e,{tree:t,node:r})=>{const n=Kt(e,r);return n.error?{error:new Error(`computing root: ${n.error.message}`)}:f(n.ok,t)?{ok:{}}:{error:new Error("inclusion proof does not lead to the same root")}},Gt=63;function Kt(e,t){if(Wt(e)>Gt)return{error:new RangeError("merkle proofs with depths greater than 63 are not supported")};let r=Ht(e);if(r>>BigInt(Wt(e))!==0n)return{error:new RangeError("offset greater than width of the tree")};let n=t,o=0n;for(const t of jt(e))o=1n&r,r>>=1n,n=1n===o?Yt(t,n):Yt(n,t);return{ok:n}}function Qt(e,t={}){const r=t.hasher||i,{digest:n}=r.digest(e);return Jt(n)}const Yt=(e,t,r)=>{const n=new Uint8Array(e.length+t.length);return n.set(e,0),n.set(t,e.length),Qt(n,r)};function Jt(e){return e[ae-1]&=63,e}const Zt=({offset:e,path:t})=>[e,t],Xt=e=>{const[t,r]=Array.isArray(e)?e:[e.offset,e.path];return Zt({offset:BigInt(t),path:r})},er=(e,t,r)=>{if(t<0)throw new RangeError("level can not be negative");if(t>e)throw new RangeError(`level too high: ${t} >= ${e}`);if(r>(1<<e-t)-1)throw new RangeError(`index too large for level: idx ${r}, level ${t} : ${(1<<e-t)-1}`)},tr=e=>{return 2n**BigInt((t=(e+oe-1n)/oe)<=1n?0:(e=>{let t=0n;for(;e>>=1n;)t++;return Number(t)})(BigInt(t)-1n)+1);var t},rr=e=>nr(2n**BigInt(e)),nr=e=>e*ce,or=4113,ir=De,sr=10+De,ar=W(or),cr=ar+W(sr)+sr;rr(255),BigInt(re),BigInt(256);class dr{constructor(e){this.bytes=e;const[t]=j(e);if(t!==or)throw new RangeError("Expected multihash with code 4113");let r=ar;const[n,o]=j(e,r);r+=o;const i=e.subarray(r);if(i.length!==n)throw new RangeError(`Invalid multihash size expected ${r+n} bytes, got ${e.length} bytes`);this.digest=i}get name(){return"fr32-sha2-256-trunc254-padded-binary-tree"}get code(){return or}get size(){return this.digest.length}get padding(){return(({digest:e})=>{const[t]=j(e);return BigInt(t)})(this)}get height(){return(({digest:e})=>{const[,t]=j(e);return e[t]})(this)}get root(){return(({digest:e})=>{const[,t]=j(e);return e.subarray(t+1,t+1+De)})(this)}}const lr=new class{constructor(){this.bytes=new Uint8Array(64*ae),this.bytes.set(le(),0),this.node=le(),this.length=ae}slice(e,t){for(;this.length<t;)this.node=Yt(this.node,this.node),this.bytes.set(this.node,this.length),this.length+=ae;return this.bytes.subarray(e,t)}},ur=e=>{if(e<0||e>=64)throw new Error("Only levels between 0 and 63 inclusive are available");return lr.slice(ae*e,ae*(e+1))},hr=e=>{const t=e.length/ae,r=new Array(t);for(let n=0;n<t;n++){const t=n*ae,o=e.subarray(t,t+ae);r[n]=o}return r};function pr(e){const t=Math.max(e,de),r=Math.floor(Math.log2(t)),n=Math.ceil(se*2**(r+1));return t<=n?n:Math.ceil(se*2**(r+2))}const fr=e=>pr(e)/se,gr=(e,t=new Uint8Array(fr(e.length)))=>{const r=pr(e.byteLength)/ne;for(let n=0;n<r;n++){const r=n*ne,o=128*n;t.set(e.subarray(r,r+32),o),t[o+31]&=63;for(let n=32;n<64;n++)t[o+n]=e[r+n]<<2|e[r+n-1]>>6;t[o+63]&=63;for(let n=64;n<96;n++)t[o+n]=e[r+n]<<4|e[r+n-1]>>4;t[o+95]&=63;for(let n=96;n<127;n++)t[o+n]=e[r+n]<<6|e[r+n-1]>>2;t[o+127]=e[r+126]>>2}return t},wr=rr(255)*BigInt(re)/BigInt(256),vr=()=>new yr;class yr{constructor(){this.bytesWritten=0n,this.buffer=new Uint8Array(ne),this.offset=0,this.layers=[[]]}count(){return this.bytesWritten}digest(){const e=new Uint8Array(cr),t=this.digestInto(e,0,!0);return(e=>new dr(e))(e.subarray(0,t))}digestInto(e,t=0,r=!0){const{buffer:n,layers:o,offset:i,bytesWritten:s}=this;let[a,...c]=o;(i>0||0n===s)&&(a=[...a,...hr(gr(n.fill(0,i)))]);const d=mr([a,...c]),l=d.length-1,[u]=d[l],h=Number((e=>(e=>tr(e)*oe)(e)-e)(this.bytesWritten)),p=W(h);let f=t;if(r){H(4113,e,f),f+=ar;const t=p+1+ir,r=W(t);H(t,e,f),f+=r}return H(h,e,f),f+=p,e[f]=l,f+=1,e.set(u,f),f+=u.length,f-t}write(e){const{buffer:t,offset:r,layers:n}=this,o=n[0],{length:i}=e;if(0===i)return this;if(this.bytesWritten+BigInt(i)>wr)throw new RangeError(`Writing ${i} bytes exceeds max payload size of ${wr}`);if(r+i<t.length)return t.set(e,r),this.offset+=i,this.bytesWritten+=BigInt(i),this;{const n=t.length-r;t.set(e.subarray(0,n),r),o.push(...hr(gr(t)));let s=n;for(;s+ne<i;){const t=e.subarray(s,s+ne);o.push(...hr(gr(t))),s+=ne}return this.buffer.set(e.subarray(s),0),this.offset=i-s,this.bytesWritten+=BigInt(i),Sr(this.layers),this}}reset(){return this.offset=0,this.bytesWritten=0n,this.layers.length=1,this.layers[0].length=0,this}dispose(){this.reset()}get code(){return 4113}get name(){return"fr32-sha2-256-trunc254-padded-binary-tree"}}const Sr=e=>Pr(e,!1),mr=e=>Pr([...e],!0),Pr=(e,t)=>{let r=0;for(;r<e.length;){let n=e[r+1];const o=e[r];t&&o.length%2>0&&n&&o.push(ur(r)),r+=1,n=n?t?[...n]:n:[];let i=0;for(;i+1<o.length;){const e=Yt(o[i],o[i+1]);delete o[i],delete o[i+1],n.push(e),i+=2}n.length&&(e[r]=n),o.splice(0,i)}return e};BigInt(256);const br=16,Ar=8,{y1:Cr,tD:Ir}=a,_r=BigInt(ae+Cr+Cr+Ir);BigInt(ae),Number(_r),rr(60),(()=>{const e=(e=>{const t=BigInt(e);return t<ie?{error:RangeError(`Minimum piece size is ${ie} bytes`)}:1!==(e=>{let t=0;for(let r=0n;r<64n;r++)0n!=(e&1n<<r)&&t++;return t})(t)?{error:RangeError("Piece size must be a power of 2")}:{ok:t}})(2n**35n);if(e.error)throw e.error;e.ok})();const Er=61697,Dr=4114;function Rr(e){return pr(e)}function Nr(e){return fr(e)}function Tr(e){return"string"==typeof e?function(e){try{const t=J.parse(e);return t.code!==Er||t.multihash.code!==Dr?null:t}catch{return null}}(e):"object"==typeof e&&null!==J.asCID(e)?(t=e).code!==Er||t.multihash.code!==Dr?null:e:null;var t}function Ur(e){const t=q(Dr,e.bytes.subarray(e.bytes.length-ir));return J.create(1,Er,t)}function $r(e){const t=vr();for(let r=0;r<e.length;r+=2048)t.write(e.subarray(r,r+2048));return Ur(t.digest())}function kr(){const e=vr();let t=!1,r=null;return{stream:new TransformStream({transform(t,r){e.write(t),r.enqueue(t)},flush(){const n=e.digest();r=Ur(n),t=!0}}),getCommP:()=>t?r:null}}async function xr(e,t){const r=Tr(t);if(null==r)throw new Error(`Invalid CommP: ${String(t)}`);if(!e.ok)throw new Error(`Download failed: ${e.status} ${e.statusText}`);if(null==e.body)throw new Error("Response body is null");const{stream:n,getCommP:o}=kr(),i=[],s=new TransformStream({transform(e,t){i.push(e),t.enqueue(e)}}),a=e.body.pipeThrough(n).pipeThrough(s).getReader();try{for(;;){const{done:e}=await a.read();if(e)break}}finally{a.releaseLock()}const c=o();if(null==c)throw new Error("Failed to calculate CommP from stream");if(c.toString()!==r.toString())throw new Error(`CommP verification failed. Expected: ${String(r)}, Got: ${String(c)}`);const d=i.reduce((e,t)=>e+t.length,0),l=new Uint8Array(d);let u=0;for(const e of i)l.set(e,u),u+=e.length;return l}async function Br(e,t){const r=await fetch(e);return await xr(r,t)}function Mr(e,t,r,n){let o=`${e} ${t} failed: ${r}`;return null!=n&&n instanceof Error&&(o=`${o} - ${n.message}`),null!=n?new Error(o,{cause:n}):new Error(o)}const Or={USDFC:"USDFC",FIL:"FIL"},Fr={mainnet:314,calibration:314159},Lr={ERC20:["function balanceOf(address owner) view returns (uint256)","function decimals() view returns (uint8)","function symbol() view returns (string)","function approve(address spender, uint256 amount) returns (bool)","function allowance(address owner, address spender) view returns (uint256)","function transfer(address to, uint256 amount) returns (bool)"],PAYMENTS:["function deposit(address token, address to, uint256 amount)","function withdraw(address token, uint256 amount)","function accounts(address token, address owner) view returns (uint256 funds, uint256 lockupCurrent, uint256 lockupRate, uint256 lockupLastSettledAt)","function setOperatorApproval(address token, address operator, bool approved, uint256 rateAllowance, uint256 lockupAllowance)","function operatorApprovals(address token, address client, address operator) view returns (bool isApproved, uint256 rateAllowance, uint256 rateUsed, uint256 lockupAllowance, uint256 lockupUsed)"],PANDORA_SERVICE:["function registerServiceProvider(string pdpUrl, string pieceRetrievalUrl) external","function approveServiceProvider(address provider) external","function rejectServiceProvider(address provider) external","function removeServiceProvider(uint256 providerId) external","function addServiceProvider(address provider, string pdpUrl, string pieceRetrievalUrl) external","function isProviderApproved(address provider) external view returns (bool)","function getProviderIdByAddress(address provider) external view returns (uint256)","function getApprovedProvider(uint256 providerId) external view returns (tuple(address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt))","function pendingProviders(address provider) external view returns (string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt)","function approvedProviders(uint256 providerId) external view returns (address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt)","function nextServiceProviderId() external view returns (uint256)","function owner() external view returns (address)","function getServicePrice() external view returns (tuple(uint256 pricePerTiBPerMonthNoCDN, uint256 pricePerTiBPerMonthWithCDN, address tokenAddress, uint256 epochsPerMonth) pricing)","function approvedProvidersMap(address) external view returns (bool)","function providerToId(address) external view returns (uint256)","function getAllApprovedProviders() external view returns (tuple(address owner, string pdpUrl, string pieceRetrievalUrl, uint256 registeredAt, uint256 approvedAt)[])","function getClientProofSets(address client) external view returns (tuple(uint256 railId, address payer, address payee, uint256 commissionBps, string metadata, string[] rootMetadata, uint256 clientDataSetId, bool withCDN)[])","function clientDataSetIDs(address client) external view returns (uint256)","function railToProofSet(uint256 railId) external view returns (uint256 proofSetId)","function getProofSet(uint256 id) public view returns (tuple(uint256 railId, address payer, address payee, uint256 commissionBps, string metadata, string[] rootMetadata, uint256 clientDataSetId, bool withCDN) info)","function getMaxProvingPeriod() external view returns (uint64)","function challengeWindow() external view returns (uint256)","function maxProvingPeriod() external view returns (uint64)","function challengeWindowSize() external view returns (uint256)"],PDP_VERIFIER:["function getNextRootId(uint256 setId) public view returns (uint256)","function proofSetLive(uint256 setId) public view returns (bool)","function getProofSetLeafCount(uint256 setId) public view returns (uint256)","function getProofSetOwner(uint256 setId) public view returns (address, address)","function getProofSetListener(uint256 setId) public view returns (address)","event ProofSetCreated(uint256 indexed setId, address indexed owner)"]},zr={EPOCH_DURATION:30,EPOCHS_PER_DAY:2880n,EPOCHS_PER_MONTH:86400n,DAYS_PER_MONTH:30n,DEFAULT_LOCKUP_DAYS:10n},Vr={mainnet:1598306400,calibration:1667326380},jr={KiB:1024n,MiB:1048576n,GiB:1073741824n,TiB:1099511627776n,MAX_UPLOAD_SIZE:209715200,MIN_UPLOAD_SIZE:65},Hr={TRANSACTION_PROPAGATION_TIMEOUT_MS:3e4,TRANSACTION_PROPAGATION_POLL_INTERVAL_MS:2e3,PROOF_SET_CREATION_TIMEOUT_MS:42e4,PROOF_SET_CREATION_POLL_INTERVAL_MS:2e3,PIECE_PARKING_TIMEOUT_MS:42e4,PIECE_PARKING_POLL_INTERVAL_MS:5e3,TRANSACTION_CONFIRMATIONS:1,ROOT_ADDITION_TIMEOUT_MS:42e4,ROOT_ADDITION_POLL_INTERVAL_MS:1e3},Wr={mainnet:{http:"https://api.node.glif.io/rpc/v1",websocket:"wss://wss.node.glif.io/apigw/lotus/rpc/v1"},calibration:{http:"https://api.calibration.node.glif.io/rpc/v1",websocket:"wss://wss.calibration.node.glif.io/apigw/lotus/rpc/v1"}},qr={USDFC:{mainnet:"0x80B98d3aa09ffff255c3ba4A241111Ff1262F045",calibration:"0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0"},PAYMENTS:{mainnet:"",calibration:"0x0E690D3e60B0576D01352AB03b258115eb84A047"},PANDORA_SERVICE:{mainnet:"",calibration:"0xf49ba5eaCdFD5EE3744efEdf413791935FE4D4c5"},PDP_VERIFIER:{mainnet:"",calibration:"0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC"}},Gr={SHA2_256_TRUNC254_PADDED:"sha2-256-trunc254-padded"};function Kr(e,t){const r=Vr[t],n=zr.EPOCH_DURATION;return new Date(1e3*(r+e*n))}function Qr(e,t){const r=Vr[t],n=zr.EPOCH_DURATION,o=Math.floor(e.getTime()/1e3)-r;return Math.floor(o/n)}function Yr(e){return Vr[e]}function Jr(e,t){const r=e-t,n=r*zr.EPOCH_DURATION;return{epochs:r,seconds:n,minutes:n/60,hours:n/3600,days:n/86400}}function Zr(e,t,r){if(0===e)return null;const n=e-t;return n<=0?null:Kr(n,r)}function Xr(e,t){return`${e.replace(/\/$/,"")}/piece/${t.toString()}`}function en(e,t,r=0){const n=e.replace(/\/$/,""),o=p(t.multihash.digest);return`${n}/pdp/piece?${new URLSearchParams({name:Gr.SHA2_256_TRUNC254_PADDED,hash:o,size:r.toString()}).toString()}`}function tn(e){if("object"!=typeof e||null==e)return!1;const t=e;if("string"!=typeof t.createMessageHash)return!1;const r="boolean"==typeof t.proofSetCreated,n="boolean"==typeof t.proofsetCreated;return!(!r&&!n||"string"!=typeof t.service||"string"!=typeof t.txStatus||null!==t.ok&&"boolean"!=typeof t.ok||void 0!==t.proofSetId&&"number"!=typeof t.proofSetId)}function rn(e){if("object"!=typeof e||null==e)return!1;const t=e;if("string"!=typeof t.txHash)return!1;if("string"!=typeof t.txStatus)return!1;if("number"!=typeof t.proofSetId)return!1;if("number"!=typeof t.rootCount)return!1;if(null!==t.addMessageOk&&"boolean"!=typeof t.addMessageOk)return!1;if(void 0!==t.confirmedRootIds){if(!Array.isArray(t.confirmedRootIds))return!1;for(const e of t.confirmedRootIds)if("number"!=typeof e)return!1}return!0}function nn(e){if("object"!=typeof e||null==e)return!1;const t=e,r="string"==typeof t.pieceCid,n="string"==typeof t.piece_cid;return!(!r&&!n)&&null!=Tr(t.pieceCid??t.piece_cid)}function on(e){if(!tn(e))throw new Error("Invalid proof set creation status response format");const t=e,r={createMessageHash:t.createMessageHash,proofSetCreated:t.proofSetCreated??t.proofsetCreated,service:t.service,txStatus:t.txStatus,ok:t.ok};return void 0!==t.proofSetId&&(r.proofSetId=t.proofSetId),r}function sn(e){if(!rn(e))throw new Error("Invalid root addition status response format");return e}function an(e){if(!nn(e)){if("object"==typeof e&&null!=e){const t=e,r=t.pieceCid??t.piece_cid;if(null!=r&&null==Tr(r))throw new Error("Invalid find piece response: pieceCid is not a valid CommP")}throw new Error("Invalid find piece response format")}const t=e,r=Tr(t.pieceCid??t.piece_cid);if(null==r)throw new Error("Invalid find piece response: pieceCid is not a valid CommP");return{pieceCid:r,piece_cid:t.piece_cid}}function cn(e){if("object"!=typeof e||null==e)return null;const t=e;if("number"!=typeof t.rootId)return null;if("string"!=typeof t.rootCid)return null;if("string"!=typeof t.subrootCid)return null;if("number"!=typeof t.subrootOffset)return null;const r=Tr(t.rootCid),n=Tr(t.subrootCid);return null==r||null==n?null:{rootId:t.rootId,rootCid:r,subrootCid:n,subrootOffset:t.subrootOffset}}function dn(e){if("object"!=typeof e||null==e)return null;const t=e;if("number"!=typeof t.id)return null;if(!Array.isArray(t.roots))return null;const r=[];for(const e of t.roots){const t=cn(e);if(null==t)return null;r.push(t)}return"number"!=typeof t.nextChallengeEpoch?null:{id:t.id,roots:r,nextChallengeEpoch:t.nextChallengeEpoch}}class ln{_apiEndpoint;_retrievalEndpoint;_authHelper;_serviceName;constructor(e,t,r,n="public"){if(""===t.trim())throw new Error("PDP API endpoint is required");if(""===r.trim())throw new Error("PDP retrieval endpoint is required");this._apiEndpoint=t.replace(/\/$/,""),this._retrievalEndpoint=r.replace(/\/$/,""),this._authHelper=e,this._serviceName=n}async createProofSet(e,t,r,n){const o=await this.getAuthHelper().signCreateProofSet(e,t,r),i={recordKeeper:n,extraData:`0x${this._encodeProofSetCreateData({metadata:"",payer:await this.getAuthHelper().getSignerAddress(),withCDN:r,signature:o.signature})}`},s=await fetch(`${this._apiEndpoint}/pdp/proof-sets`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(i)});if(201!==s.status){const e=await s.text();throw new Error(`Failed to create proof set: ${s.status} ${s.statusText} - ${e}`)}const a=s.headers.get("Location");if(null==a)throw new Error("Server did not provide Location header in response");const c=a.match(/\/pdp\/proof-sets\/created\/(.+)$/);if(null==c)throw new Error(`Invalid Location header format: ${a}`);return{txHash:c[1],statusUrl:`${this._apiEndpoint}${a}`}}async addRoots(e,t,r,n){if(0===n.length)throw new Error("At least one root must be provided");for(const e of n)if(null==Tr(e.cid))throw new Error(`Invalid CommP: ${String(e.cid)}`);const o=await this.getAuthHelper().signAddRoots(t,r,n),i=this._encodeAddRootsExtraData({signature:o.signature,metadata:""}),s={roots:n.map(e=>{const t="string"==typeof e.cid?e.cid:e.cid.toString();return{rootCid:t,subroots:[{subrootCid:t}]}}),extraData:`0x${i}`},a=await fetch(`${this._apiEndpoint}/pdp/proof-sets/${e}/roots`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(s)});if(201!==a.status){const e=await a.text();throw new Error(`Failed to add roots to proof set: ${a.status} ${a.statusText} - ${e}`)}const c=a.headers.get("Location");let d,l;if(null!=c){const e=c.match(/\/roots\/added\/([0-9a-fA-Fx]+)$/);null!=e&&(d=e[1],d.startsWith("0x")||(d="0x"+d),l=`${this._apiEndpoint}${c}`)}const u=await a.text();return{message:""!==u?u:`Roots added to proof set ID ${e} successfully`,txHash:d,statusUrl:l}}async getProofSetCreationStatus(e){const t=await fetch(`${this._apiEndpoint}/pdp/proof-sets/created/${e}`,{method:"GET",headers:{"Content-Type":"application/json"}});if(404===t.status)throw new Error(`Proof set creation not found for transaction hash: ${e}`);if(200!==t.status){const e=await t.text();throw new Error(`Failed to get proof set creation status: ${t.status} ${t.statusText} - ${e}`)}return on(await t.json())}async getRootAdditionStatus(e,t){const r=await fetch(`${this._apiEndpoint}/pdp/proof-sets/${e}/roots/added/${t}`,{method:"GET",headers:{"Content-Type":"application/json"}});if(404===r.status)throw new Error(`Root addition not found for transaction: ${t}`);if(200!==r.status){const e=await r.text();throw new Error(`Failed to get root addition status: ${r.status} ${r.statusText} - ${e}`)}return sn(await r.json())}async findPiece(e,t){const r=Tr(e);if(null==r)throw new Error(`Invalid CommP: ${String(e)}`);const n=en(this._apiEndpoint,r,t),o=await fetch(n,{method:"GET",headers:{}});if(404===o.status)throw new Error(`Piece not found: ${r.toString()}`);if(!o.ok){const e=await o.text();throw new Error(`Failed to find piece: ${o.status} ${o.statusText} - ${e}`)}return an(await o.json())}async uploadPiece(e){const t=e instanceof ArrayBuffer?new Uint8Array(e):e,r=await $r(t),n=t.length,o=p(r.multihash.digest),i={check:{name:Gr.SHA2_256_TRUNC254_PADDED,hash:o,size:n}},s=await fetch(`${this._apiEndpoint}/pdp/piece`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(i)});if(200===s.status)return{commP:r,size:n};if(201!==s.status){const e=await s.text();throw new Error(`Failed to create upload session: ${s.status} ${s.statusText} - ${e}`)}const a=s.headers.get("Location");if(null==a)throw new Error("Server did not provide Location header in response (may be restricted by CORS policy)");const c=a.match(/\/(?:pdp\/)?piece\/upload\/([a-fA-F0-9-]+)/);if(null==c)throw new Error(`Invalid Location header format: ${a}`);const d=c[1],l=await fetch(`${this._apiEndpoint}/pdp/piece/upload/${d}`,{method:"PUT",headers:{"Content-Type":"application/octet-stream","Content-Length":t.length.toString()},body:t});if(204!==l.status){const e=await l.text();throw new Error(`Failed to upload piece: ${l.status} ${l.statusText} - ${e}`)}return{commP:r,size:n}}async downloadPiece(e){const t=Tr(e);if(null==t)throw new Error(`Invalid CommP: ${String(e)}`);const r=Xr(this._retrievalEndpoint,t),n=await fetch(r);return await xr(n,t)}async getProofSet(e){const t=await fetch(`${this._apiEndpoint}/pdp/proof-sets/${e}`,{method:"GET",headers:{Accept:"application/json"}});if(404===t.status)throw new Error(`Proof set not found: ${e}`);if(!t.ok){const e=await t.text();throw new Error(`Failed to fetch proof set: ${t.status} ${t.statusText} - ${e}`)}const r=dn(await t.json());if(null==r)throw new Error("Invalid proof set data response format");return r}_encodeProofSetCreateData(e){const t=e.signature.startsWith("0x")?e.signature:`0x${e.signature}`;return u.ethers.AbiCoder.defaultAbiCoder().encode(["string","address","bool","bytes"],[e.metadata,e.payer,e.withCDN,t]).slice(2)}_encodeAddRootsExtraData(e){const t=e.signature.startsWith("0x")?e.signature:`0x${e.signature}`;return u.ethers.AbiCoder.defaultAbiCoder().encode(["bytes","string"],[t,e.metadata]).slice(2)}async ping(){const e=await fetch(`${this._apiEndpoint}/pdp/ping`,{method:"GET",headers:{}});if(200!==e.status){const t=await e.text().catch(()=>"Unknown error");throw new Error(`Provider ping failed: ${e.status} ${e.statusText} - ${t}`)}}getApiEndpoint(){return this._apiEndpoint}getAuthHelper(){if(null==this._authHelper)throw new Error("AuthHelper is not available for an operation that requires signing");return this._authHelper}}const un={CreateProofSet:[{name:"clientDataSetId",type:"uint256"},{name:"withCDN",type:"bool"},{name:"payee",type:"address"}],Cid:[{name:"data",type:"bytes"}],RootData:[{name:"root",type:"Cid"},{name:"rawSize",type:"uint256"}],AddRoots:[{name:"clientDataSetId",type:"uint256"},{name:"firstAdded",type:"uint256"},{name:"rootData",type:"RootData[]"}],ScheduleRemovals:[{name:"clientDataSetId",type:"uint256"},{name:"rootIds",type:"uint256[]"}],DeleteProofSet:[{name:"clientDataSetId",type:"uint256"}]};class hn{signer;domain;constructor(e,t,r){this.signer=t,this.domain={name:"PandoraService",version:"1",chainId:Number(r),verifyingContract:e}}getUnderlyingSigner(){return"signer"in this.signer&&"NonceManager"===this.signer.constructor.name?this.signer.signer:this.signer}async isMetaMaskSigner(){try{const e=this.getUnderlyingSigner();if("Wallet"===e.constructor.name)return!1;const t=e.provider;if(null==t)return!1;if("_eip1193Provider"in t)return!0;if("undefined"!=typeof globalThis&&"window"in globalThis){const e=globalThis;if(null!=e.window?.ethereum)return!0}if("send"in t||"request"in t)return!0}catch(e){}return!1}async signWithMetaMask(e,t){const r=this.signer.provider;if(null==r)throw new Error("No provider available");const n=await this.signer.getAddress();let o="";for(const t of Object.keys(e))if("Cid"!==t&&"RootData"!==t){o=t;break}const i={types:{EIP712Domain:[{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"}],...e},primaryType:o,domain:this.domain,message:t};let s,a;return s="_eip1193Provider"in r?r._eip1193Provider:r,a=null!=s&&"request"in s?await s.request({method:"eth_signTypedData_v4",params:[n.toLowerCase(),JSON.stringify(i)]}):await r.send("eth_signTypedData_v4",[n.toLowerCase(),JSON.stringify(i)]),a}async signCreateProofSet(e,t,r=!1){let n;if(await this.isMetaMaskSigner()){const o={clientDataSetId:e.toString(),withCDN:r,payee:t};n=await this.signWithMetaMask({CreateProofSet:un.CreateProofSet},o)}else{const o={clientDataSetId:BigInt(e),withCDN:r,payee:t},i=this.getUnderlyingSigner();n=await i.signTypedData(this.domain,{CreateProofSet:un.CreateProofSet},o)}const o=u.ethers.Signature.from(n),i=u.ethers.TypedDataEncoder.hash(this.domain,{CreateProofSet:un.CreateProofSet},{clientDataSetId:BigInt(e),withCDN:r,payee:t});return{signature:n,v:o.v,r:o.r,s:o.s,signedData:i}}async signAddRoots(e,t,r){const n=[];for(const e of r){const t="string"==typeof e.cid?Tr(e.cid):e.cid;if(null==t)throw new Error(`Invalid CommP: ${String(e.cid)}`);n.push({root:{data:t.bytes},rawSize:BigInt(Nr(e.rawSize))})}let o;if(await this.isMetaMaskSigner()){const r={clientDataSetId:e.toString(),firstAdded:t.toString(),rootData:n.map(e=>({root:{data:u.ethers.hexlify(e.root.data)},rawSize:e.rawSize.toString()}))},i={AddRoots:un.AddRoots,RootData:un.RootData,Cid:un.Cid};o=await this.signWithMetaMask(i,r)}else{const r={clientDataSetId:BigInt(e),firstAdded:BigInt(t),rootData:n},i={AddRoots:un.AddRoots,RootData:un.RootData,Cid:un.Cid},s=this.getUnderlyingSigner();o=await s.signTypedData(this.domain,i,r)}const i=u.ethers.Signature.from(o),s=u.ethers.TypedDataEncoder.hash(this.domain,{AddRoots:un.AddRoots,RootData:un.RootData,Cid:un.Cid},{clientDataSetId:BigInt(e),firstAdded:BigInt(t),rootData:n});return{signature:o,v:i.v,r:i.r,s:i.s,signedData:s}}async signScheduleRemovals(e,t){const r=t.map(e=>BigInt(e));let n;if(await this.isMetaMaskSigner()){const t={clientDataSetId:e.toString(),rootIds:r.map(e=>e.toString())};n=await this.signWithMetaMask({ScheduleRemovals:un.ScheduleRemovals},t)}else{const t={clientDataSetId:BigInt(e),rootIds:r},o=this.getUnderlyingSigner();n=await o.signTypedData(this.domain,{ScheduleRemovals:un.ScheduleRemovals},t)}const o=u.ethers.Signature.from(n),i=u.ethers.TypedDataEncoder.hash(this.domain,{ScheduleRemovals:un.ScheduleRemovals},{clientDataSetId:BigInt(e),rootIds:r});return{signature:n,v:o.v,r:o.r,s:o.s,signedData:i}}async signDeleteProofSet(e){let t;if(await this.isMetaMaskSigner()){const r={clientDataSetId:e.toString()};t=await this.signWithMetaMask({DeleteProofSet:un.DeleteProofSet},r)}else{const r={clientDataSetId:BigInt(e)},n=this.getUnderlyingSigner();t=await n.signTypedData(this.domain,{DeleteProofSet:un.DeleteProofSet},r)}const r=u.ethers.Signature.from(t),n=u.ethers.TypedDataEncoder.hash(this.domain,{DeleteProofSet:un.DeleteProofSet},{clientDataSetId:BigInt(e)});return{signature:t,v:r.v,r:r.r,s:r.s,signedData:n}}async getSignerAddress(){return await this.signer.getAddress()}}class pn{_synapse;_provider;_pdpServer;_pandoraService;_pandoraAddress;_withCDN;_proofSetId;_signer;proofSetId;storageProvider;static validateRawSize(e,t){if(e<jr.MIN_UPLOAD_SIZE)throw Mr("StorageService",t,`Data size (${e} bytes) is below minimum allowed size (${jr.MIN_UPLOAD_SIZE} bytes).`);if(e>jr.MAX_UPLOAD_SIZE)throw Mr("StorageService",t,`Data size (${e} bytes) exceeds maximum allowed size (${jr.MAX_UPLOAD_SIZE} bytes)`)}constructor(e,t,r,n,o){this._synapse=e,this._provider=r,this._proofSetId=n,this._withCDN=o.withCDN??!1,this._signer=e.getSigner(),this._pandoraService=t,this.proofSetId=n.toString(),this.storageProvider=r.owner,this._pandoraAddress=e.getPandoraAddress();const i=new hn(this._pandoraAddress,this._signer,e.getChainId());this._pdpServer=new ln(i,r.pdpUrl,r.pieceRetrievalUrl)}static async create(e,t,r){const n=e.getSigner(),o=await n.getAddress(),i=await pn.resolveProviderAndProofSet(e,t,o,r);try{r.callbacks?.onProviderSelected?.(i.provider)}catch(e){console.error("Error in onProviderSelected callback:",e)}let s;if(-1===i.proofSetId)s=await pn.createProofSet(e,t,i.provider,r.withCDN??!1,r.callbacks);else{s=i.proofSetId;try{r.callbacks?.onProofSetResolved?.({isExisting:!0,proofSetId:s,provider:i.provider})}catch(e){console.error("Error in onProofSetResolved callback:",e)}}return new pn(e,t,i.provider,s,r)}static async createProofSet(e,t,r,n,o){const i=e.getSigner(),s=await i.getAddress(),a=await t.getNextClientDataSetId(s),c=e.getPandoraAddress(),d=new hn(c,i,e.getChainId()),l=new ln(d,r.pdpUrl,r.pieceRetrievalUrl),u=await l.createProofSet(a,r.owner,n,c),{txHash:h,statusUrl:p}=u,f=e.getProvider();let g=null;const w=Date.now(),v=Hr.TRANSACTION_PROPAGATION_TIMEOUT_MS,y=Hr.TRANSACTION_PROPAGATION_POLL_INTERVAL_MS;for(;Date.now()-w<v;){try{if(g=await f.getTransaction(h),null!==g)break}catch(e){console.warn(`Failed to fetch transaction ${h}, retrying...`,e)}await new Promise(e=>setTimeout(e,y))}if(null===g)throw Mr("StorageService","create",`Transaction ${h} not found after ${v/1e3} seconds. The transaction may not have propagated to the RPC node.`);try{o?.onProofSetCreationStarted?.(g,p)}catch(e){console.error("Error in onProofSetCreationStarted callback:",e)}let S;try{S=await t.waitForProofSetCreationWithStatus(g,l,Hr.PROOF_SET_CREATION_TIMEOUT_MS,Hr.PROOF_SET_CREATION_POLL_INTERVAL_MS,async(e,t)=>{if(null!=o?.onProofSetCreationProgress)try{let r;if(e.chainStatus.transactionMined&&null!=e.chainStatus.blockNumber)try{r=await g.wait(Hr.TRANSACTION_CONFIRMATIONS)??void 0}catch(e){console.error("Failed to fetch transaction receipt:",e)}o.onProofSetCreationProgress({transactionMined:e.chainStatus.transactionMined,transactionSuccess:e.chainStatus.transactionSuccess,proofSetLive:e.chainStatus.proofSetLive,serverConfirmed:!0===e.serverStatus?.ok,proofSetId:e.summary.proofSetId??void 0,elapsedMs:t,receipt:r})}catch(e){console.error("Error in onProofSetCreationProgress callback:",e)}})}catch(e){throw Mr("StorageService","waitForProofSetCreation",e instanceof Error?e.message:"Proof set creation failed")}if(!S.summary.isComplete||null==S.summary.proofSetId)throw Mr("StorageService","waitForProofSetCreation",`Proof set creation failed: ${S.summary.error??"Transaction may have failed"}`);const m=S.summary.proofSetId;try{o?.onProofSetResolved?.({isExisting:!1,proofSetId:m,provider:r})}catch(e){console.error("Error in onProofSetResolved callback:",e)}return m}static async resolveProviderAndProofSet(e,t,r,n){return null!=n.proofSetId?await pn.resolveByProofSetId(n.proofSetId,t,r,n):null!=n.providerId?await pn.resolveByProviderId(n.providerId,t,r,n.withCDN??!1):null!=n.providerAddress?await pn.resolveByProviderAddress(n.providerAddress,t,r,n.withCDN??!1):await pn.smartSelectProvider(t,r,n.withCDN??!1,e.getSigner())}static async resolveByProofSetId(e,t,r,n){const o=(await t.getClientProofSetsWithDetails(r)).find(t=>t.pdpVerifierProofSetId===e);if(null==o||!o.isLive||!o.isManaged)throw Mr("StorageService","resolveByProofSetId",`Proof set ${e} not found, not owned by ${r}, or not managed by the current Pandora contract`);null==n.providerId&&null==n.providerAddress||await pn.validateProofSetConsistency(o,n,t);const i=await t.getProviderIdByAddress(o.payee);if(0===i)throw Mr("StorageService","resolveByProofSetId",`Provider ${o.payee} for proof set ${e} is not currently approved`);return{provider:await t.getApprovedProvider(i),proofSetId:e,isExisting:!0}}static async validateProofSetConsistency(e,t,r){if(null!=t.providerId){const n=await r.getProviderIdByAddress(e.payee);if(n!==t.providerId)throw Mr("StorageService","validateProofSetConsistency",`Proof set ${e.pdpVerifierProofSetId} belongs to provider ID ${n}, but provider ID ${t.providerId} was requested`)}if(null!=t.providerAddress&&e.payee.toLowerCase()!==t.providerAddress.toLowerCase())throw Mr("StorageService","validateProofSetConsistency",`Proof set ${e.pdpVerifierProofSetId} belongs to provider ${e.payee}, but provider ${t.providerAddress} was requested`)}static async resolveByProviderId(e,t,r,n){const[o,i]=await Promise.all([t.getApprovedProvider(e),t.getClientProofSetsWithDetails(r)]);if("0x0000000000000000000000000000000000000000"===o.owner)throw Mr("StorageService","resolveByProviderId",`Provider ID ${e} not found or not approved`);const s=i.filter(e=>e.payee.toLowerCase()===o.owner.toLowerCase()&&e.isLive&&e.isManaged&&e.withCDN===n);if(s.length>0){const e=s.sort((e,t)=>e.currentRootCount>0&&0===t.currentRootCount?-1:t.currentRootCount>0&&0===e.currentRootCount?1:e.pdpVerifierProofSetId-t.pdpVerifierProofSetId);return{provider:o,proofSetId:e[0].pdpVerifierProofSetId,isExisting:!0}}return{provider:o,proofSetId:-1,isExisting:!1}}static async resolveByProviderAddress(e,t,r,n){const o=await t.getProviderIdByAddress(e);if(0===o)throw Mr("StorageService","resolveByProviderAddress",`Provider ${e} is not currently approved`);return await pn.resolveByProviderId(o,t,r,n)}static async smartSelectProvider(e,t,r,n){const o=(await e.getClientProofSetsWithDetails(t)).filter(e=>e.isLive&&e.isManaged&&e.withCDN===r);if(o.length>0){const s=o.sort((e,t)=>e.currentRootCount>0&&0===t.currentRootCount?-1:t.currentRootCount>0&&0===e.currentRootCount?1:e.pdpVerifierProofSetId-t.pdpVerifierProofSetId);async function*a(){const t=new Set;for(const r of s){const n=r.payee.toLowerCase();if(t.has(n))continue;t.add(n);const o=await e.getProviderIdByAddress(r.payee);if(0===o){console.warn(`Provider ${r.payee} for proof set ${r.pdpVerifierProofSetId} is not currently approved, skipping`);continue}const i=await e.getApprovedProvider(o);yield i}}const c=await pn.selectProviderWithPing(a()),d=s.find(e=>e.payee.toLowerCase()===c.owner.toLowerCase());if(null==d)throw Mr("StorageService","smartSelectProvider","Selected provider not found in proof sets");return{provider:c,proofSetId:d.pdpVerifierProofSetId,isExisting:!0}}const i=await e.getAllApprovedProviders();if(0===i.length)throw Mr("StorageService","smartSelectProvider","No approved storage providers available");return{provider:await pn.selectRandomProvider(i,n),proofSetId:-1,isExisting:!1}}static async selectRandomProvider(e,t){if(0===e.length)throw Mr("StorageService","selectRandomProvider","No providers available");return await pn.selectProviderWithPing(async function*(){const r=[...e];for(;r.length>0;){let e;if(void 0!==globalThis.crypto&&null!=globalThis.crypto.getRandomValues){const t=new Uint8Array(1);globalThis.crypto.getRandomValues(t),e=t[0]%r.length}else{const n=Date.now()*Math.random()*(await t.getAddress()).split("").reduce((e,t)=>e+t.charCodeAt(0),0)%r.length;e=Math.floor(Math.abs(n))}const n=r.splice(e,1)[0];yield n}}())}static async selectProviderWithPing(e){let t=0;for await(const r of e){t++;try{const e=new ln(null,r.pdpUrl,r.pieceRetrievalUrl);return await e.ping(),r}catch(e){console.warn(`Provider ${r.owner} failed ping test:`,e instanceof Error?e.message:String(e))}}if(0===t)throw Mr("StorageService","selectProviderWithPing","No reachable storage providers available after ping validation");throw Mr("StorageService","selectProviderWithPing",`All ${t} available storage providers failed ping validation`)}async preflightUpload(e){pn.validateRawSize(e,"preflightUpload");const t=await this._pandoraService.checkAllowanceForStorage(e,this._withCDN,this._synapse.payments);return{estimatedCost:{perEpoch:t.costs.perEpoch,perDay:t.costs.perDay,perMonth:t.costs.perMonth},allowanceCheck:{sufficient:t.sufficient,message:t.message},selectedProvider:this._provider,selectedProofSetId:this._proofSetId}}async upload(e,t){const r=e instanceof ArrayBuffer?new Uint8Array(e):e,n=r.length;let o;pn.validateRawSize(n,"upload");try{o=await this._pdpServer.uploadPiece(r)}catch(e){throw Mr("StorageService","uploadPiece","Failed to upload piece to storage provider",e)}const i=Hr.PIECE_PARKING_TIMEOUT_MS,s=Hr.PIECE_PARKING_POLL_INTERVAL_MS,a=Date.now();let c=!1;for(;Date.now()-a<i;)try{await this._pdpServer.findPiece(o.commP,o.size),c=!0;break}catch{Date.now()-a+s<i&&await new Promise(e=>setTimeout(e,s))}if(!c)throw Mr("StorageService","findPiece","Timeout waiting for piece to be parked on storage provider");null!=t?.onUploadComplete&&t.onUploadComplete(o.commP);try{const e=await this._pandoraService.getAddRootsInfo(this._proofSetId),r=[{cid:o.commP,rawSize:o.size}],n=await this._pdpServer.addRoots(this._proofSetId,e.clientDataSetId,e.nextRootId,r);let i=e.nextRootId;if(null!=n.txHash){let e=null;const r=Date.now(),o=Hr.TRANSACTION_PROPAGATION_TIMEOUT_MS,s=Hr.TRANSACTION_PROPAGATION_POLL_INTERVAL_MS;for(;Date.now()-r<o;){try{if(e=await this._synapse.getProvider().getTransaction(n.txHash),null!==e)break}catch{}await new Promise(e=>setTimeout(e,s))}if(null==e)throw Mr("StorageService","addRoots",`Server returned transaction hash ${n.txHash} but transaction was not found on-chain after ${o/1e3} seconds`);let a;t?.onRootAdded?.(e);try{a=await e.wait(Hr.TRANSACTION_CONFIRMATIONS)}catch(e){throw Mr("StorageService","addRoots","Failed to wait for transaction confirmation",e)}if(1!==a?.status)throw Mr("StorageService","addRoots","Root addition transaction failed on-chain");const c=Hr.ROOT_ADDITION_TIMEOUT_MS,d=Hr.ROOT_ADDITION_POLL_INTERVAL_MS,l=Date.now();let u=null,h=!1;for(;Date.now()-l<c;)try{const e=await this._pdpServer.getRootAdditionStatus(this._proofSetId,n.txHash);if("pending"===e.txStatus){await new Promise(e=>setTimeout(e,d));continue}if(!1===e.addMessageOk)throw new Error("Root addition failed: Transaction was unsuccessful");if(null!=e.confirmedRootIds&&e.confirmedRootIds.length>0){i=e.confirmedRootIds[0],t?.onRootConfirmed?.(e.confirmedRootIds),h=!0;break}await new Promise(e=>setTimeout(e,d))}catch(e){if(u=e,e instanceof Error&&e.message.includes("not found")){await new Promise(e=>setTimeout(e,d));continue}throw Mr("StorageService","addRoots",`Failed to verify root addition with server: ${e instanceof Error?e.message:"Unknown error"}`,e)}if(!h)throw Mr("StorageService","addRoots",`Failed to verify root addition after ${c/1e3} seconds: ${null!=u?u.message:"Server did not provide confirmation"}. The transaction was confirmed on-chain but the server failed to acknowledge it.`,u)}else t?.onRootAdded?.();return{commp:o.commP,size:o.size,rootId:i}}catch(e){throw Mr("StorageService","addRoots","Failed to add root to proof set",e)}}async providerDownload(e,t){return await this._synapse.download(e,{providerAddress:this._provider.owner,withCDN:this._withCDN})}async download(e,t){return await this.providerDownload(e,t)}async getProviderInfo(){return await this._synapse.getProviderInfo(this.storageProvider)}async getProofSetRoots(){return(await this._pdpServer.getProofSet(this._proofSetId)).roots.map(e=>e.rootCid)}async pieceStatus(e){const t=Tr(e);if(null==t)throw Mr("StorageService","pieceStatus","Invalid CommP provided");const[r,n,o]=await Promise.all([this._pdpServer.findPiece(t,0).then(()=>!0).catch(()=>!1),this._pdpServer.getProofSet(this._proofSetId).catch(e=>(console.debug("Failed to get proof set data:",e),null)),this._synapse.payments.getCurrentEpoch()]),i=r,s=this._synapse.getNetwork();let a,c=null,d=null,l=null,u=!1,h=0,p=!1;if(i){const[e,r]=await Promise.all([this.getProviderInfo().catch(()=>null),null!=n?Promise.all([this._pandoraService.getMaxProvingPeriod(),this._pandoraService.getChallengeWindow()]).then(([e,t])=>({maxProvingPeriod:e,challengeWindow:t})).catch(()=>null):Promise.resolve(null)]);if(null!=e&&(c=`${e.pieceRetrievalUrl.replace(/\/$/,"")}/piece/${t.toString()}`),null!=n&&null!=r){const e=n.roots.find(e=>e.rootCid.toString()===t.toString());if(null!=e)if(a=e.rootId,n.nextChallengeEpoch>0){const e=n.nextChallengeEpoch,t=e+r.challengeWindow;l=Kr(t,s);const i=Zr(n.nextChallengeEpoch,r.maxProvingPeriod,s);null!=i&&(d=i),u=o>=e&&o<t,p=o>=t,o<e&&(h=Jr(e,Number(o)).hours)}else console.debug("Proof set has nextChallengeEpoch=0, may have just been proven")}}return{exists:i,proofSetLastProven:d,proofSetNextProofDue:l,retrievalUrl:c,rootId:a,inChallengeWindow:u,hoursUntilChallengeWindow:h,isProofOverdue:p}}}class fn{_provider;_signer;_network;_disableNonceManager;_usdfcContract=null;_paymentsContract=null;constructor(e,t,r,n){this._provider=e,this._signer=t,this._network=r,this._disableNonceManager=n}_getUsdfcContract(){if(null==this._usdfcContract){const e=qr.USDFC[this._network];if(null==e)throw new Error(`USDFC contract not deployed on ${this._network} network`);this._usdfcContract=new u.ethers.Contract(e,Lr.ERC20,this._signer)}return this._usdfcContract}_getPaymentsContract(){if(null==this._paymentsContract){const e=qr.PAYMENTS[this._network];if(null==e||""===e)throw new Error(`Payments contract not deployed on ${this._network} network. Currently only Calibration testnet is supported.`);this._paymentsContract=new u.ethers.Contract(e,Lr.PAYMENTS,this._signer)}return this._paymentsContract}async balance(e=Or.USDFC){if(e!==Or.USDFC)throw Mr("PaymentsService","payments contract balance check",`Token "${e}" is not supported. Currently only USDFC token is supported for payments contract balance queries.`);return(await this.accountInfo(e)).availableFunds}async accountInfo(e=Or.USDFC){if(e!==Or.USDFC)throw Mr("PaymentsService","account info",`Token "${e}" is not supported. Currently only USDFC token is supported.`);const t=await this._signer.getAddress(),r=qr.USDFC[this._network],n=this._getPaymentsContract();let o;try{o=await n.accounts(r,t)}catch(e){throw Mr("PaymentsService","account info","Failed to read account information from payments contract. This could indicate the contract is not properly deployed, the ABI is incorrect, or there are network connectivity issues.",e)}const[i,s,a,c]=o,d=await this.getCurrentEpoch()-BigInt(c),l=BigInt(s)+BigInt(a)*d,u=BigInt(i)-l;return{funds:BigInt(i),lockupCurrent:BigInt(s),lockupRate:BigInt(a),lockupLastSettledAt:BigInt(c),availableFunds:u>0n?u:0n}}async getCurrentEpoch(){const e=await this._provider.getBlock("latest");if(null==e)throw Mr("PaymentsService","getCurrentEpoch","Failed to get latest block");return BigInt(e.number)}async walletBalance(e){if(null==e||e===Or.FIL)try{const e=await this._signer.getAddress();return await this._provider.getBalance(e)}catch(e){throw Mr("PaymentsService","wallet FIL balance check","Unable to retrieve FIL balance from wallet. This could be due to network connectivity issues, RPC endpoint problems, or wallet connection issues.",e)}if(e===Or.USDFC)try{const e=await this._signer.getAddress(),t=this._getUsdfcContract();return await t.balanceOf(e)}catch(e){throw Mr("PaymentsService","wallet USDFC balance check","Unexpected error while checking USDFC token balance in wallet.",e)}throw Mr("PaymentsService","wallet balance check",`Token "${e}" is not supported. Currently only USDFC token is supported for balance queries.`)}decimals(e=Or.USDFC){return 18}async allowance(e,t){if(e!==Or.USDFC)throw Mr("PaymentsService","allowance",`Token "${e}" is not supported. Currently only USDFC token is supported.`);const r=await this._signer.getAddress(),n=this._getUsdfcContract();try{return await n.allowance(r,t)}catch(e){throw Mr("PaymentsService","allowance check","Failed to check token allowance. This could indicate network connectivity issues or an invalid spender address.",e)}}async approve(e,t,r){if(e!==Or.USDFC)throw Mr("PaymentsService","approve",`Token "${e}" is not supported. Currently only USDFC token is supported.`);const n="bigint"==typeof r?r:BigInt(r);if(n<0n)throw Mr("PaymentsService","approve","Approval amount cannot be negative");const o=await this._signer.getAddress(),i=this._getUsdfcContract(),s={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(o,"pending");s.nonce=e}try{return await i.approve(t,n,s)}catch(r){throw Mr("PaymentsService","approve",`Failed to approve ${t} to spend ${n.toString()} ${e}`,r)}}async approveService(e,t,r,n=Or.USDFC){if(n!==Or.USDFC)throw Mr("PaymentsService","approveService",`Token "${n}" is not supported. Currently only USDFC token is supported.`);const o="bigint"==typeof t?t:BigInt(t),i="bigint"==typeof r?r:BigInt(r);if(o<0n||i<0n)throw Mr("PaymentsService","approveService","Allowance values cannot be negative");const s=await this._signer.getAddress(),a=qr.USDFC[this._network],c=this._getPaymentsContract(),d={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(s,"pending");d.nonce=e}try{return await c.setOperatorApproval(a,e,!0,o,i,d)}catch(t){throw Mr("PaymentsService","approveService",`Failed to approve service ${e} as operator for ${n}`,t)}}async revokeService(e,t=Or.USDFC){if(t!==Or.USDFC)throw Mr("PaymentsService","revokeService",`Token "${t}" is not supported. Currently only USDFC token is supported.`);const r=await this._signer.getAddress(),n=qr.USDFC[this._network],o=this._getPaymentsContract(),i={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(r,"pending");i.nonce=e}try{return await o.setOperatorApproval(n,e,!1,0n,0n,i)}catch(r){throw Mr("PaymentsService","revokeService",`Failed to revoke service ${e} as operator for ${t}`,r)}}async serviceApproval(e,t=Or.USDFC){if(t!==Or.USDFC)throw Mr("PaymentsService","serviceApproval",`Token "${t}" is not supported. Currently only USDFC token is supported.`);const r=await this._signer.getAddress(),n=qr.USDFC[this._network],o=this._getPaymentsContract();try{const t=await o.operatorApprovals(n,r,e);return{isApproved:t[0],rateAllowance:t[1],lockupAllowance:t[2],rateUsed:t[3],lockupUsed:t[4]}}catch(t){throw Mr("PaymentsService","serviceApproval",`Failed to check service approval status for ${e}`,t)}}async deposit(e,t=Or.USDFC,r){if(t!==Or.USDFC)throw Mr("PaymentsService","deposit",`Unsupported token: ${t}`);const n="bigint"==typeof e?e:BigInt(e);if(n<=0n)throw Mr("PaymentsService","deposit","Invalid amount");const o=await this._signer.getAddress(),i=qr.USDFC[this._network],s=this._getUsdfcContract(),a=this._getPaymentsContract(),c=await s.balanceOf(o);if(c<n)throw Mr("PaymentsService","deposit",`Insufficient USDFC: have ${BigInt(c).toString()}, need ${n.toString()}`);const d=qr.PAYMENTS[this._network];if(null==d)throw Mr("PaymentsService","deposit",`Payments contract not deployed on ${this._network}`);const l=await this.allowance(t,d);if(r?.onAllowanceCheck?.(l,n),l<n){const e=await this.approve(t,d,n);r?.onApprovalTransaction?.(e);const o=await e.wait(Hr.TRANSACTION_CONFIRMATIONS);null!=o&&r?.onApprovalConfirmed?.(o)}r?.onDepositStarting?.();const u={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(o,"pending");u.nonce=e}return await a.deposit(i,o,n,u)}async withdraw(e,t=Or.USDFC){if(t!==Or.USDFC)throw Mr("PaymentsService","withdraw",`Unsupported token: ${t}`);const r="bigint"==typeof e?e:BigInt(e);if(r<=0n)throw Mr("PaymentsService","withdraw","Invalid amount");const n=await this._signer.getAddress(),o=qr.USDFC[this._network],i=this._getPaymentsContract(),s=await this.accountInfo(t);if(s.availableFunds<r)throw Mr("PaymentsService","withdraw",`Insufficient available balance: have ${s.availableFunds.toString()}, need ${r.toString()}`);const a={};if(this._disableNonceManager){const e=await this._provider.getTransactionCount(n,"pending");a.nonce=e}return await i.withdraw(o,r,a)}}class gn{_provider;_contractAddress;_contract;constructor(e,t){this._provider=e,this._contractAddress=t,this._contract=new u.ethers.Contract(this._contractAddress,Lr.PDP_VERIFIER,this._provider)}async proofSetLive(e){return await this._contract.proofSetLive(e)}async getNextRootId(e){const t=await this._contract.getNextRootId(e);return Number(t)}async getProofSetListener(e){return await this._contract.getProofSetListener(e)}async getProofSetOwner(e){const[t,r]=await this._contract.getProofSetOwner(e);return{owner:t,proposedOwner:r}}async getProofSetLeafCount(e){const t=await this._contract.getProofSetLeafCount(e);return Number(t)}extractProofSetIdFromReceipt(e){try{for(const t of e.logs)try{const e=this._contract.interface.parseLog({topics:t.topics,data:t.data});if(null!=e&&"ProofSetCreated"===e.name)return Number(e.args.setId)}catch(e){continue}return null}catch(e){throw new Error(`Failed to extract proof set ID from receipt: ${e instanceof Error?e.message:String(e)}`)}}getContractAddress(){return this._contract.target}}class wn{_provider;_pandoraAddress;_pdpVerifierAddress;_pandoraContract=null;_pdpVerifier=null;constructor(e,t,r){this._provider=e,this._pandoraAddress=t,this._pdpVerifierAddress=r}_getPandoraContract(){return null==this._pandoraContract&&(this._pandoraContract=new u.ethers.Contract(this._pandoraAddress,Lr.PANDORA_SERVICE,this._provider)),this._pandoraContract}_getPDPVerifier(){return null==this._pdpVerifier&&(this._pdpVerifier=new gn(this._provider,this._pdpVerifierAddress)),this._pdpVerifier}async getClientProofSets(e){const t=this._getPandoraContract();try{const r=await t.getClientProofSets(e),n=[];for(let e=0;e<r.length;e++){const t=r[e];"0x0000000000000000000000000000000000000000"!==t.payer&&0!==Number(t.railId)&&n.push({railId:Number(t.railId),payer:t.payer,payee:t.payee,commissionBps:Number(t.commissionBps),metadata:t.metadata,rootMetadata:t.rootMetadata,clientDataSetId:Number(t.clientDataSetId),withCDN:t.withCDN})}return n}catch(e){throw new Error(`Failed to get client proof sets: ${e instanceof Error?e.message:String(e)}`)}}async getClientProofSetsWithDetails(e,t=!1){const r=await this.getClientProofSets(e),n=this._getPDPVerifier(),o=this._getPandoraContract(),i=r.map(async e=>{try{const r=await o.railToProofSet(e.railId);if(0===Number(r))return t?null:{...e,pdpVerifierProofSetId:0,nextRootId:0,currentRootCount:0,isLive:!1,isManaged:!1};const[i,s]=await Promise.all([n.proofSetLive(Number(r)),n.getProofSetListener(Number(r)).catch(()=>null)]),a=null!=s&&s.toLowerCase()===this._pandoraAddress.toLowerCase();if(t&&!a)return null;const c=i?await n.getNextRootId(Number(r)):0;return{...e,pdpVerifierProofSetId:Number(r),nextRootId:Number(c),currentRootCount:Number(c),isLive:i,isManaged:a}}catch(t){throw new Error(`Failed to get details for proof set with rail ID ${e.railId}: ${t instanceof Error?t.message:String(t)}`)}});return(await Promise.all(i)).filter(e=>null!==e)}async getAddRootsInfo(e){try{const t=this._getPandoraContract(),r=this._getPDPVerifier(),[n,o,i,s]=await Promise.all([r.proofSetLive(Number(e)),r.getNextRootId(Number(e)),r.getProofSetListener(Number(e)),t.getProofSet(Number(e))]);if(!n)throw new Error(`Proof set ${e} does not exist or is not live`);if(i.toLowerCase()!==this._pandoraAddress.toLowerCase())throw new Error(`Proof set ${e} is not managed by this Pandora contract (${this._pandoraAddress}), managed by ${String(i)}`);const a=Number(s.clientDataSetId);return{nextRootId:Number(o),clientDataSetId:a,currentRootCount:Number(o)}}catch(e){throw new Error(`Failed to get add roots info: ${e instanceof Error?e.message:String(e)}`)}}async getNextClientDataSetId(e){try{const t=this._getPandoraContract(),r=await t.clientDataSetIDs(e);return Number(r)}catch(e){throw new Error(`Failed to get next client dataset ID: ${e instanceof Error?e.message:String(e)}`)}}async verifyProofSetCreation(e){try{const t="string"==typeof e?e:e.hash;let r;if(r="string"==typeof e?await this._provider.getTransactionReceipt(t):await e.wait(Hr.TRANSACTION_CONFIRMATIONS),null==r)return{transactionMined:!1,transactionSuccess:!1,proofSetLive:!1};if(1!==r.status)return{transactionMined:!0,transactionSuccess:!1,proofSetLive:!1,blockNumber:r.blockNumber,gasUsed:r.gasUsed,error:"Transaction failed"};const n=this._getPDPVerifier(),o=await n.extractProofSetIdFromReceipt(r);return null==o?{transactionMined:!0,transactionSuccess:!0,proofSetLive:!1,blockNumber:r.blockNumber,gasUsed:r.gasUsed,error:"Could not find ProofSetCreated event in transaction"}:{transactionMined:!0,transactionSuccess:!0,proofSetId:o,proofSetLive:await n.proofSetLive(o),blockNumber:r.blockNumber,gasUsed:r.gasUsed}}catch(e){return{transactionMined:!1,transactionSuccess:!1,proofSetLive:!1,error:`Verification failed: ${e instanceof Error?e.message:String(e)}`}}}async getComprehensiveProofSetStatus(e,t){const r="string"==typeof e?e:e.hash;let n=null;try{n=await t.getProofSetCreationStatus(r)}catch(e){}const o=await this.verifyProofSetCreation(e);return{txHash:r,serverStatus:n,chainStatus:o,summary:{isComplete:o.transactionMined&&o.proofSetLive&&null!=n&&!0===n.ok,isLive:o.proofSetLive,proofSetId:o.proofSetId??n?.proofSetId??null,error:o.error??null}}}async waitForProofSetCreationWithStatus(e,t,r=Hr.PROOF_SET_CREATION_TIMEOUT_MS,n=Hr.PROOF_SET_CREATION_POLL_INTERVAL_MS,o){const i=Date.now();for(;Date.now()-i<r;){const r=await this.getComprehensiveProofSetStatus(e,t);if(null!=o)try{await o(r,Date.now()-i)}catch(e){console.error("Error in progress callback:",e)}if(r.summary.isComplete||null!=r.summary.error)return r;await new Promise(e=>setTimeout(e,n))}throw new Error(`Timeout waiting for proof set creation after ${r}ms`)}async calculateStorageCost(e){const t=this._getPandoraContract();let r,n,o;try{const e=await t.getServicePrice();r=BigInt(e.pricePerTiBPerMonthNoCDN),n=BigInt(e.pricePerTiBPerMonthWithCDN),o=BigInt(e.epochsPerMonth)}catch(e){throw console.error("Error calling getServicePrice:",e),e}const i=BigInt(e),s=r*i/(jr.TiB*o),a=n*i/(jr.TiB*o);return{perEpoch:s,perDay:s*zr.EPOCHS_PER_DAY,perMonth:s*o,withCDN:{perEpoch:a,perDay:a*zr.EPOCHS_PER_DAY,perMonth:a*o}}}async checkAllowanceForStorage(e,t,r,n){const o=await r.serviceApproval(this._pandoraAddress,Or.USDFC),i=await this.calculateStorageCost(e),s=t?i.withCDN:i,a=s.perEpoch,c=a*(BigInt(n??zr.DEFAULT_LOCKUP_DAYS)*zr.EPOCHS_PER_DAY),d=BigInt(o.rateUsed)+a,l=BigInt(o.lockupUsed)+c,u=o.rateAllowance>=d&&o.lockupAllowance>=l;let h;if(!u){const e=[];o.rateAllowance<d&&e.push(`Rate allowance insufficient: current ${String(o.rateAllowance)}, need ${String(d)}`),o.lockupAllowance<l&&e.push(`Lockup allowance insufficient: current ${String(o.lockupAllowance)}, need ${String(l)}`),h=e.join(". ")}return{rateAllowanceNeeded:d,lockupAllowanceNeeded:l,currentRateAllowance:o.rateAllowance,currentLockupAllowance:o.lockupAllowance,currentRateUsed:o.rateUsed,currentLockupUsed:o.lockupUsed,sufficient:u,message:h,costs:{perEpoch:s.perEpoch,perDay:s.perDay,perMonth:s.perMonth},depositAmountNeeded:c}}async prepareStorageUpload(e,t){const r=await this.calculateStorageCost(e.dataSize),n=!0===e.withCDN?r.withCDN:r,o=await this.checkAllowanceForStorage(e.dataSize,e.withCDN??!1,t),i=[],s=await t.accountInfo(Or.USDFC),a=n.perMonth;if(s.availableFunds<a){const e=a-s.availableFunds;i.push({type:"deposit",description:`Deposit ${e} USDFC to payments contract`,execute:async()=>await t.deposit(e,Or.USDFC)})}return o.sufficient||i.push({type:"approveService",description:`Approve service with rate allowance ${o.rateAllowanceNeeded} and lockup allowance ${o.lockupAllowanceNeeded}`,execute:async()=>await t.approveService(this._pandoraAddress,o.rateAllowanceNeeded,o.lockupAllowanceNeeded,Or.USDFC)}),{estimatedCost:{perEpoch:n.perEpoch,perDay:n.perDay,perMonth:n.perMonth},allowanceCheck:{sufficient:o.sufficient,message:o.message},actions:i}}async registerServiceProvider(e,t,r){const n=this._getPandoraContract().connect(e);return await n.registerServiceProvider(t,r)}async approveServiceProvider(e,t){const r=this._getPandoraContract().connect(e);return await r.approveServiceProvider(t)}async rejectServiceProvider(e,t){const r=this._getPandoraContract().connect(e);return await r.rejectServiceProvider(t)}async removeServiceProvider(e,t){const r=this._getPandoraContract().connect(e);return await r.removeServiceProvider(t)}async addServiceProvider(e,t,r,n){const o=this._getPandoraContract().connect(e);return await o.addServiceProvider(t,r,n)}async isProviderApproved(e){const t=this._getPandoraContract();return await t.isProviderApproved(e)}async getProviderIdByAddress(e){const t=this._getPandoraContract(),r=await t.getProviderIdByAddress(e);return Number(r)}async getApprovedProvider(e){const t=this._getPandoraContract(),r=await t.getApprovedProvider(e);return{owner:r.owner,pdpUrl:r.pdpUrl,pieceRetrievalUrl:r.pieceRetrievalUrl,registeredAt:Number(r.registeredAt),approvedAt:Number(r.approvedAt)}}async getPendingProvider(e){const t=this._getPandoraContract(),r=await t.pendingProviders(e);return{pdpUrl:r.pdpUrl,pieceRetrievalUrl:r.pieceRetrievalUrl,registeredAt:Number(r.registeredAt)}}async getNextProviderId(){const e=this._getPandoraContract(),t=await e.nextServiceProviderId();return Number(t)}async getOwner(){const e=this._getPandoraContract();return await e.owner()}async isOwner(e){const t=await e.getAddress(),r=await this.getOwner();return t.toLowerCase()===r.toLowerCase()}async getAllApprovedProviders(){const e=this._getPandoraContract();return(await e.getAllApprovedProviders()).map(e=>({owner:e.owner,pdpUrl:e.pdpUrl,pieceRetrievalUrl:e.pieceRetrievalUrl,registeredAt:Number(e.registeredAt),approvedAt:Number(e.approvedAt)}))}async getServicePrice(){const e=this._getPandoraContract(),t=await e.getServicePrice();return{pricePerTiBPerMonthNoCDN:t.pricePerTiBPerMonthNoCDN,pricePerTiBPerMonthWithCDN:t.pricePerTiBPerMonthWithCDN,tokenAddress:t.tokenAddress,epochsPerMonth:t.epochsPerMonth}}async getMaxProvingPeriod(){const e=this._getPandoraContract(),t=await e.getMaxProvingPeriod();return Number(t)}async getChallengeWindow(){const e=this._getPandoraContract(),t=await e.challengeWindow();return Number(t)}async getProvingPeriodInHours(){return 30*await this.getMaxProvingPeriod()/3600}async getChallengeWindowInMinutes(){return 30*await this.getChallengeWindow()/60}async getProvingPeriodInfo(){const[e,t]=await Promise.all([this.getMaxProvingPeriod(),this.getChallengeWindow()]);return{maxProvingPeriodEpochs:e,challengeWindowEpochs:t,maxProvingPeriodHours:30*e/3600,challengeWindowMinutes:30*t/60,epochDurationSeconds:30}}}const vn="\n    query GetApprovedProvidersForCommP($cid: Bytes!) {\n      roots(where: { cid: $cid }) {\n        id\n        proofSet {\n          setId\n          owner {\n            id\n            address\n            pdpUrl\n            pieceRetrievalUrl\n            registeredAt\n            status\n            approvedAt\n          }\n        }\n      }\n    }\n  ",yn="\n    query Provider($providerId: ID!) {\n      provider(id: $providerId) {\n        id\n        address\n        pdpUrl\n        pieceRetrievalUrl\n        registeredAt\n        approvedAt\n      }\n    }\n  ",Sn="\n    query ProvidersFlexible($where: Provider_filter, $first: Int, $skip: Int, $orderBy: Provider_orderBy, $orderDirection: OrderDirection) {\n      providers(\n        where: $where\n        first: $first\n        skip: $skip\n        orderBy: $orderBy\n        orderDirection: $orderDirection\n      ) {\n        id\n        address\n        pdpUrl\n        pieceRetrievalUrl\n        registeredAt\n        approvedAt\n        status\n        totalFaultedPeriods\n        totalFaultedRoots\n        totalProofSets\n        totalRoots\n        totalDataSize\n        createdAt\n        updatedAt\n      }\n    }\n  ",mn="\n    query ProofSetsFlexible($where: ProofSet_filter, $first: Int, $skip: Int, $orderBy: ProofSet_orderBy, $orderDirection: OrderDirection) {\n      proofSets(\n        where: $where\n        first: $first\n        skip: $skip\n        orderBy: $orderBy\n        orderDirection: $orderDirection\n      ) {\n        id\n        setId\n        listener\n        clientAddr\n        withCDN\n        isActive\n        leafCount\n        challengeRange\n        lastProvenEpoch\n        nextChallengeEpoch\n        totalRoots\n        totalDataSize\n        totalProofs\n        totalProvedRoots\n        totalFaultedPeriods\n        totalFaultedRoots\n        metadata\n        createdAt\n        updatedAt\n        owner {\n          id\n          address\n          pdpUrl\n          pieceRetrievalUrl\n          registeredAt\n          approvedAt\n        }\n        rail {\n          id\n          railId\n          token\n          paymentRate\n          lockupPeriod\n          settledUpto\n          endEpoch\n        }\n      }\n    }\n  ",Pn="\n    query RootsFlexible($where: Root_filter, $first: Int, $skip: Int, $orderBy: Root_orderBy, $orderDirection: OrderDirection) {\n      roots(\n        where: $where\n        first: $first\n        skip: $skip\n        orderBy: $orderBy\n        orderDirection: $orderDirection\n      ) {\n        id\n        setId\n        rootId\n        rawSize\n        leafCount\n        cid\n        removed\n        totalProofsSubmitted\n        totalPeriodsFaulted\n        lastProvenEpoch\n        lastProvenAt\n        lastFaultedEpoch\n        lastFaultedAt\n        createdAt\n        metadata\n        proofSet {\n          id\n          setId\n          isActive\n          owner {\n            id\n            address\n            pdpUrl\n            pieceRetrievalUrl\n            registeredAt\n            approvedAt\n          }\n        }\n      }\n    }\n  ",bn="\n    query FaultRecordsFlexible($where: FaultRecord_filter, $first: Int, $skip: Int, $orderBy: FaultRecord_orderBy, $orderDirection: OrderDirection) {\n      faultRecords(\n        where: $where\n        first: $first\n        skip: $skip\n        orderBy: $orderBy\n        orderDirection: $orderDirection\n      ) {\n        id\n        proofSetId\n        rootIds\n        currentChallengeEpoch\n        nextChallengeEpoch\n        periodsFaulted\n        deadline\n        createdAt\n        proofSet {\n          id\n          setId\n          owner {\n            id\n            address\n            pdpUrl\n            pieceRetrievalUrl\n            registeredAt\n            approvedAt\n          }\n        }\n      }\n    }\n  ";class An{endpoint;headers;constructor(e){this.endpoint=this.resolveEndpoint(e),this.headers=this.buildHeaders(e.apiKey)}resolveEndpoint(e){if(null!=e.endpoint&&""!==e.endpoint.trim())return e.endpoint.trim();if(null!=e.goldsky)return this.buildGoldskyEndpoint(e.goldsky);throw Mr("SubgraphService","constructor","Invalid configuration: provide either endpoint or complete goldsky config")}buildGoldskyEndpoint(e){const{projectId:t,subgraphName:r,version:n}=e;if(null==t?.trim()||""===t?.trim()||null==r?.trim()||""===r?.trim()||null==n?.trim()||""===n?.trim())throw Mr("SubgraphService","constructor","Incomplete Goldsky config: projectId, subgraphName, and version required");return`https://api.goldsky.com/api/public/${t}/subgraphs/${r}/${n}/gn`}buildHeaders(e){const t={"Content-Type":"application/json"};return null!=e&&""!==e?{...t,Authorization:`Bearer ${e}`}:t}normalizeQueryOptions(e={}){return{where:{},first:10,skip:0,orderBy:"createdAt",orderDirection:"desc",...e}}async executeQuery(e,t,r){try{const n=await fetch(this.endpoint,{method:"POST",headers:this.headers,body:JSON.stringify({query:e,variables:t})});if(!n.ok){const e=await n.text();throw Mr("SubgraphService",r,`HTTP ${n.status}: ${e}`)}const o=await n.json();if(null!=o.errors&&o.errors.length>0)throw Mr("SubgraphService",r,`GraphQL errors: ${o.errors.map(e=>e.message).join("; ")}`);return o.data}catch(e){if(e instanceof Error&&"SynapseError"===e.name)throw e;throw Mr("SubgraphService",r,`Query execution failed: ${e.message}`,{cause:e})}}transformProviderData(e){return{owner:null!=e.address&&""!==e.address?e.address:e.id,pdpUrl:e.pdpUrl,pieceRetrievalUrl:e.pieceRetrievalUrl,registeredAt:this.parseTimestamp(e.registeredAt),approvedAt:this.parseTimestamp(e.approvedAt)}}parseTimestamp(e){if(null==e)return 0;const t=Number(e);return isNaN(t)?0:t}safeConvertHexToCid(e){try{const t=function(e){const t=e.match(/../g);return null!=t?new Uint8Array(t.map(e=>parseInt(e,16))):h}(e.startsWith("0x")?e.slice(2):e),r=Tr(J.decode(t));if(null==r)throw new Error(`Failed to convert CID to CommP format: ${e}`);return r}catch(e){return console.warn(`SubgraphService: queryProviders: Failed to convert CID to CommP format: ${e instanceof Error?e.message:"Unknown error"}`),null}}isValidProviderData(e){return null!=e?.id&&""!==e.id.trim()&&null!=e?.pdpUrl&&""!==e.pdpUrl.trim()&&null!=e?.pieceRetrievalUrl&&""!==e.pieceRetrievalUrl.trim()}async getApprovedProvidersForCommP(e){const t=Tr(e);if(null==t)throw Mr("SubgraphService","getApprovedProvidersForCommP","Invalid CommP");const r=p(t.bytes),n=await this.executeQuery(vn,{cid:r},"getApprovedProvidersForCommP");if(null==n?.roots||0===n.roots.length)return console.log(`SubgraphService: No providers found for CommP: ${t.toString()}`),[];const o=n.roots.reduce((e,t)=>{const r=t.proofSet.owner,n=r?.address?.toLowerCase();return"Approved"!==r?.status||null==n||""===n||e.has(n)?e:this.isValidProviderData(r)?(e.set(n,r),e):(console.warn("SubgraphService: Skipping incomplete provider data for approved provider:",r),e)},new Map);return Array.from(o.values()).map(e=>this.transformProviderData(e))}async getProviderByAddress(e){const t=await this.executeQuery(yn,{providerId:e},"getProviderByAddress");return null==t?.provider?(console.log(`SubgraphService: No provider found for address: ${e}`),null):this.transformProviderData(t.provider)}async queryProviders(e={}){const t=await this.executeQuery(Sn,this.normalizeQueryOptions(e),"queryProviders");return null==t?.providers||0===t?.providers?.length?(console.log("SubgraphService: No providers found for the given criteria"),[]):t.providers.filter(e=>this.isValidProviderData(e)).map(e=>this.transformProviderData(e))}async queryProofSets(e={}){const t=await this.executeQuery(mn,this.normalizeQueryOptions(e),"queryProofSets");return null==t?.proofSets||0===t?.proofSets?.length?(console.log("SubgraphService: No proof sets found for the given criteria"),[]):t.proofSets.map(e=>({id:e.id,setId:this.parseTimestamp(e.setId),listener:e.listener??"",clientAddr:e.clientAddr??"",withCDN:e.withCDN??!1,isActive:e.isActive,leafCount:this.parseTimestamp(e.leafCount),challengeRange:this.parseTimestamp(e.challengeRange),lastProvenEpoch:this.parseTimestamp(e.lastProvenEpoch),nextChallengeEpoch:this.parseTimestamp(e.nextChallengeEpoch),totalRoots:this.parseTimestamp(e.totalRoots),totalDataSize:this.parseTimestamp(e.totalDataSize),totalProofs:this.parseTimestamp(e.totalProofs),totalProvedRoots:this.parseTimestamp(e.totalProvedRoots),totalFaultedPeriods:this.parseTimestamp(e.totalFaultedPeriods),totalFaultedRoots:this.parseTimestamp(e.totalFaultedRoots),metadata:e.metadata??"",createdAt:this.parseTimestamp(e.createdAt),updatedAt:this.parseTimestamp(e.updatedAt),owner:null!=e.owner?this.transformProviderData(e.owner):{owner:"",pdpUrl:"",pieceRetrievalUrl:"",registeredAt:0,approvedAt:0},rail:null!=e.rail?{id:e.rail.id,railId:this.parseTimestamp(e.rail.railId),token:e.rail.token,paymentRate:this.parseTimestamp(e.rail.paymentRate),lockupPeriod:this.parseTimestamp(e.rail.lockupPeriod),settledUpto:this.parseTimestamp(e.rail.settledUpto),endEpoch:this.parseTimestamp(e.rail.endEpoch)}:void 0}))}async queryRoots(e={}){const t=await this.executeQuery(Pn,this.normalizeQueryOptions(e),"queryRoots");return null==t?.roots||0===t?.roots?.length?(console.log("SubgraphService: No roots found for the given criteria"),[]):t.roots.map(e=>({id:e.id,setId:this.parseTimestamp(e.setId),rootId:this.parseTimestamp(e.rootId),rawSize:this.parseTimestamp(e.rawSize),leafCount:this.parseTimestamp(e.leafCount),cid:this.safeConvertHexToCid(e.cid),removed:e.removed,totalProofsSubmitted:this.parseTimestamp(e.totalProofsSubmitted),totalPeriodsFaulted:this.parseTimestamp(e.totalPeriodsFaulted),lastProvenEpoch:this.parseTimestamp(e.lastProvenEpoch),lastProvenAt:this.parseTimestamp(e.lastProvenAt),lastFaultedEpoch:this.parseTimestamp(e.lastFaultedEpoch),lastFaultedAt:this.parseTimestamp(e.lastFaultedAt),createdAt:this.parseTimestamp(e.createdAt),metadata:e.metadata??"",proofSet:{id:e.proofSet.id,setId:this.parseTimestamp(e.proofSet.setId),isActive:e.proofSet.isActive,owner:this.transformProviderData(e.proofSet.owner)}}))}async queryFaultRecords(e={}){const t=await this.executeQuery(bn,this.normalizeQueryOptions(e),"queryFaultRecords");return null==t?.faultRecords||0===t?.faultRecords?.length?(console.log("SubgraphService: No fault records found for the given criteria"),[]):t.faultRecords.map(e=>({id:e.id,proofSetId:this.parseTimestamp(e.proofSetId),rootIds:e.rootIds.map(e=>this.parseTimestamp(e)),currentChallengeEpoch:this.parseTimestamp(e.currentChallengeEpoch),nextChallengeEpoch:this.parseTimestamp(e.nextChallengeEpoch),periodsFaulted:this.parseTimestamp(e.periodsFaulted),deadline:this.parseTimestamp(e.deadline),createdAt:this.parseTimestamp(e.createdAt),proofSet:{id:e.proofSet.id,setId:this.parseTimestamp(e.proofSet.setId),owner:this.transformProviderData(e.proofSet.owner)}}))}}async function Cn(e,t,r,n){const o=[],i=[],s=e.map(async(e,r)=>{const s=new AbortController;i[r]=s,null!=n&&(n.addEventListener("abort",()=>{s.abort(n.reason)},{once:!0}),n.aborted&&s.abort(n.reason));try{const n=en(e.pdpUrl,t),i=await fetch(n,{signal:s.signal});if(!i.ok)throw o.push({provider:e.owner,error:`findPiece returned ${i.status}`}),new Error("Provider does not have piece");const a=Xr(e.pieceRetrievalUrl,t),c=await fetch(a,{signal:s.signal});if(c.ok)return{response:c,index:r};throw o.push({provider:e.owner,error:`download returned ${c.status}`}),new Error(`Download failed with status ${c.status}`)}catch(t){const r=t.message??"Unknown error";throw o.some(t=>t.provider===e.owner)||o.push({provider:e.owner,error:r}),console.warn(`Failed to fetch from provider ${e.owner}:`,r),t}});try{const{response:e,index:t}=await Promise.any(s);return i.forEach((e,r)=>{r!==t&&e.abort()}),e}catch(e){if(e instanceof AggregateError){const e=o.map(e=>`${e.provider}: ${e.error}`).join("; ");throw Mr(r,"fetchPiecesFromProviders",`All providers failed to serve piece ${t.toString()}. Details: ${e}`)}throw e}}class In{pandoraService;childRetriever;constructor(e,t){this.pandoraService=e,this.childRetriever=t}async findProviders(e,t){if(null!=t){const e=await this.pandoraService.getProviderIdByAddress(t);if(0===e)throw Mr("ChainRetriever","findProviders",`Provider ${t} not found or not approved`);return[await this.pandoraService.getApprovedProvider(e)]}const r=(await this.pandoraService.getClientProofSetsWithDetails(e)).filter(e=>e.isLive&&e.currentRootCount>0);if(0===r.length)throw Mr("ChainRetriever","findProviders",`No active proof sets with data found for client ${e}`);const n=[...new Set(r.map(e=>e.payee))];return await Promise.all(n.map(async e=>{const t=await this.pandoraService.getProviderIdByAddress(e);return await this.pandoraService.getApprovedProvider(t)}))}async fetchPiece(e,t,r){const n=async n=>{if(void 0!==this.childRetriever)return await this.childRetriever.fetchPiece(e,t,r);throw Mr("ChainRetriever","fetchPiece",`Failed to retrieve piece ${e.toString()}: ${n}`)};let o=[];try{o=await this.findProviders(t,r?.providerAddress)}catch(e){return await n("Provider discovery failed and no additional retriever method was configured")}if(0===o.length)return await n("No providers found and no additional retriever method was configured");try{return await Cn(o,e,"ChainRetriever",r?.signal)}catch(e){return await n("All provider retrieval attempts failed and no additional retriever method was configured")}}}class _n{baseRetriever;network;constructor(e,t){this.baseRetriever=e,this.network=t}hostname(){return"mainnet"===this.network?"filcdn.io":"calibration.filcdn.io"}async fetchPiece(e,t,r){if(!0===r?.withCDN){const n=`https://${t}.${this.hostname()}/${e.toString()}`;try{const e=await fetch(n,{signal:r?.signal});if(e.ok)return e;402===e.status?console.warn("CDN requires payment. Please initialise Synapse SDK with the option `withCDN: true` and re-upload your files."):console.warn("CDN fetch failed with status:",e.status)}catch(e){console.warn("CDN fetch failed:",e)}}return console.log("Falling back to direct retrieval"),await this.baseRetriever.fetchPiece(e,t,r)}}class En{subgraphService;childRetriever;constructor(e,t){this.subgraphService=e,this.childRetriever=t}async findProviders(e,t){if(null!=t){const e=await this.subgraphService.getProviderByAddress(t);return null!==e?[e]:[]}return await this.subgraphService.getApprovedProvidersForCommP(e)}async fetchPiece(e,t,r){const n=async n=>{if(void 0!==this.childRetriever)return await this.childRetriever.fetchPiece(e,t,r);throw Mr("SubgraphRetriever","fetchPiece",`Failed to retrieve piece ${e.toString()}: ${n}`)};let o=[];try{o=await this.findProviders(e,r?.providerAddress)}catch(e){return await n("Provider discovery failed and no additional retriever method was configured")}if(0===o.length)return await n("No providers found and no additional retriever method was configured");try{return await Cn(o,e,"SubgraphRetriever",r?.signal)}catch(e){return await n("All provider retrieval attempts failed and no additional retriever method was configured")}}}class Dn{_signer;_network;_withCDN;_payments;_provider;_pandoraAddress;_pdpVerifierAddress;_pandoraService;_pieceRetriever;static async create(e){if(1!==[e.privateKey,e.provider,e.signer].filter(Boolean).length)throw new Error("Must provide exactly one of: privateKey, provider, or signer");if(null!=e.privateKey&&null==e.rpcURL)throw new Error("rpcURL is required when using privateKey");let t,r,n;if(null!=e.privateKey&&null!=e.rpcURL){if(e.rpcURL.startsWith("ws://")||e.rpcURL.startsWith("wss://"))t=new u.ethers.WebSocketProvider(e.rpcURL);else if(null!=e.authorization){const r=new u.ethers.FetchRequest(e.rpcURL);r.setHeader("Authorization",e.authorization),t=new u.ethers.JsonRpcProvider(r)}else t=new u.ethers.JsonRpcProvider(e.rpcURL);const n=new u.ethers.Wallet(e.privateKey,t);r=!0!==e.disableNonceManager?new u.ethers.NonceManager(n):n}else if(null!=e.provider){if(t=e.provider,!("getSigner"in t)||"function"!=typeof t.getSigner)throw new Error("Provider must support getSigner() method");{const n=await t.getSigner();r=!0!==e.disableNonceManager?new u.ethers.NonceManager(n):n}}else{if(null==e.signer)throw new Error("Invalid configuration");if(r=e.signer,null==r.provider)throw new Error("Signer must have a provider attached");t=r.provider,!0!==e.disableNonceManager&&(r=new u.ethers.NonceManager(r))}try{const e=await t.getNetwork(),r=Number(e.chainId);if(r===Fr.mainnet)n="mainnet";else{if(r!==Fr.calibration)throw new Error(`Unsupported network with chain ID ${r}. Synapse SDK only supports Filecoin mainnet (${Fr.mainnet}) and calibration (${Fr.calibration}) networks.`);n="calibration"}}catch(e){throw new Error("Failed to detect network from provider. Please ensure your RPC endpoint is accessible and responds to network queries. "+(e instanceof Error?`Underlying error: ${e.message}`:""))}const o=e.pandoraAddress??qr.PANDORA_SERVICE[n],i=e.pdpVerifierAddress??qr.PDP_VERIFIER[n],s=new wn(t,o,i);let a;if(null!=e.pieceRetriever)a=e.pieceRetriever;else{const t=new In(s);let r=t;if(null!=e.subgraphService||null!=e.subgraphConfig)try{let n;if(null!=e.subgraphService)n=e.subgraphService;else{if(null==e.subgraphConfig)throw new Error("Invalid subgraph configuration: neither service nor config provided");n=new An(e.subgraphConfig)}r=new En(n,t)}catch(e){throw new Error(`Failed to initialize subgraph piece retriever: ${e instanceof Error?e.message:String(e)}`)}a=new _n(r,n)}return new Dn(t,r,n,!0===e.disableNonceManager,!0===e.withCDN,e.pandoraAddress,e.pdpVerifierAddress,s,a)}constructor(e,t,r,n,o,i,s,a,c){if(this._provider=e,this._signer=t,this._network=r,this._withCDN=o,this._payments=new fn(e,t,r,n),this._pandoraService=a,this._pieceRetriever=c,this._pandoraAddress=i??qr.PANDORA_SERVICE[r],""===this._pandoraAddress||void 0===this._pandoraAddress)throw new Error(`No Pandora service address configured for network: ${r}`);if(this._pdpVerifierAddress=s??qr.PDP_VERIFIER[r],""===this._pdpVerifierAddress||void 0===this._pdpVerifierAddress)throw new Error(`No PDPVerifier contract address configured for network: ${r}`)}get payments(){return this._payments}getProvider(){return this._provider}getSigner(){return this._signer}getChainId(){return BigInt(Fr[this._network])}getPandoraAddress(){return this._pandoraAddress}getPDPVerifierAddress(){return this._pdpVerifierAddress}async createStorage(e){try{const t={...e,withCDN:e?.withCDN??this._withCDN};return await pn.create(this,this._pandoraService,t)}catch(e){throw Mr("Synapse","createStorage","Failed to create storage service",e)}}getNetwork(){return this._network}async getProviderInfo(e){try{if(!u.ethers.isAddress(e))throw new Error(`Invalid provider address: ${String(e)}`);const t=await this._pandoraService.getProviderIdByAddress(e);if(0===t)throw new Error(`Provider ${e} is not approved`);const r=await this._pandoraService.getApprovedProvider(t);if(r.owner===u.ethers.ZeroAddress)throw new Error(`Provider ${e} not found`);return r}catch(t){throw Mr("Synapse","getProviderInfo",`Failed to get provider info for ${e}`,t)}}async download(e,t){const r=Tr(e);if(null==r)throw Mr("Synapse","download",`Invalid CommP: ${String(e)}`);const n=await this._signer.getAddress(),o=await this._pieceRetriever.fetchPiece(r,n,{withCDN:t?.withCDN??this._withCDN,providerAddress:t?.providerAddress});return await xr(o,r)}async getStorageInfo(){try{const e=async()=>{try{const e=await this._payments.serviceApproval(this._pandoraAddress,Or.USDFC);return{service:this._pandoraAddress,rateAllowance:e.rateAllowance,lockupAllowance:e.lockupAllowance,rateUsed:e.rateUsed,lockupUsed:e.lockupUsed}}catch(e){return null}},[t,r,n]=await Promise.all([this._pandoraService.getServicePrice(),this._pandoraService.getAllApprovedProviders(),e()]),o=BigInt(t.epochsPerMonth),i=zr.EPOCHS_PER_DAY,s=BigInt(t.pricePerTiBPerMonthNoCDN)/o,a=BigInt(t.pricePerTiBPerMonthWithCDN)/o,c=BigInt(t.pricePerTiBPerMonthNoCDN)/zr.DAYS_PER_MONTH,d=BigInt(t.pricePerTiBPerMonthWithCDN)/zr.DAYS_PER_MONTH,l=r.filter(e=>e.owner!==u.ethers.ZeroAddress);return{pricing:{noCDN:{perTiBPerMonth:BigInt(t.pricePerTiBPerMonthNoCDN),perTiBPerDay:c,perTiBPerEpoch:s},withCDN:{perTiBPerMonth:BigInt(t.pricePerTiBPerMonthWithCDN),perTiBPerDay:d,perTiBPerEpoch:a},tokenAddress:t.tokenAddress,tokenSymbol:"USDFC"},providers:l,serviceParameters:{network:this._network,epochsPerMonth:o,epochsPerDay:i,epochDuration:zr.EPOCH_DURATION,minUploadSize:jr.MIN_UPLOAD_SIZE,maxUploadSize:jr.MAX_UPLOAD_SIZE,pandoraAddress:this._pandoraAddress,paymentsAddress:qr.PAYMENTS[this._network],pdpVerifierAddress:this._pdpVerifierAddress},allowances:n}}catch(e){throw Mr("Synapse","getStorageInfo","Failed to get storage service information",e)}}}const Rn={...l,...c,...d};return o.default})());